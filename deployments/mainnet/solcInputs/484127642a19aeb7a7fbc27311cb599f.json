{
  "language": "Solidity",
  "sources": {
    "contracts/access/Governable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../core/AddressProvider.sol\";\n\n/**\n * @notice Contract module which provides access control mechanism, where\n * the governor account is granted with exclusive access to specific functions.\n * @dev Uses the AddressProvider to get the governor\n */\nabstract contract Governable {\n    IAddressProvider public constant addressProvider = IAddressProvider(0xfbA0816A81bcAbBf3829bED28618177a2bf0e82A);\n\n    /// @dev Throws if called by any account other than the governor.\n    modifier onlyGovernor() {\n        require(msg.sender == addressProvider.governor(), \"not-governor\");\n        _;\n    }\n}\n"
    },
    "contracts/core/AddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../interfaces/core/IAddressProvider.sol\";\n\ncontract AddressProvider is IAddressProvider, Initializable {\n    /// @notice The governor account\n    address public governor;\n\n    /// @notice The proposed governor account. Becomes the new governor after acceptance\n    address public proposedGovernor;\n\n    /// @notice The PriceProvidersAggregator contract\n    IPriceProvidersAggregator public override providersAggregator;\n\n    /// @notice The StableCoinProvider contract\n    IStableCoinProvider public override stableCoinProvider;\n\n    /// @notice Emitted when providers aggregator is updated\n    event ProvidersAggregatorUpdated(\n        IPriceProvidersAggregator oldProvidersAggregator,\n        IPriceProvidersAggregator newProvidersAggregator\n    );\n\n    /// @notice Emitted when stable coin provider is updated\n    event StableCoinProviderUpdated(\n        IStableCoinProvider oldStableCoinProvider,\n        IStableCoinProvider newStableCoinProvider\n    );\n\n    /// @notice Emitted when governor is updated\n    event UpdatedGovernor(address indexed previousGovernor, address indexed proposedGovernor);\n\n    /**\n     * @dev Throws if called by any account other than the governor.\n     */\n    modifier onlyGovernor() {\n        require(governor == msg.sender, \"not-governor\");\n        _;\n    }\n\n    function initialize(address governor_) external initializer {\n        governor = governor_;\n        emit UpdatedGovernor(address(0), governor_);\n    }\n\n    /**\n     * @dev Allows new governor to accept governorship of the contract.\n     */\n    function acceptGovernorship() external {\n        require(msg.sender == proposedGovernor, \"not-the-proposed-governor\");\n        emit UpdatedGovernor(governor, proposedGovernor);\n        governor = proposedGovernor;\n        proposedGovernor = address(0);\n    }\n\n    /**\n     * @dev Transfers governorship of the contract to a new account (`proposedGovernor`).\n     * Can only be called by the current owner.\n     */\n    function transferGovernorship(address _proposedGovernor) external onlyGovernor {\n        require(_proposedGovernor != address(0), \"proposed-governor-is-zero\");\n        proposedGovernor = _proposedGovernor;\n    }\n\n    /**\n     * @notice Update PriceProvidersAggregator contract\n     */\n    function updateProvidersAggregator(IPriceProvidersAggregator providersAggregator_) external onlyGovernor {\n        require(address(providersAggregator_) != address(0), \"address-is-null\");\n        emit ProvidersAggregatorUpdated(providersAggregator, providersAggregator_);\n        providersAggregator = providersAggregator_;\n    }\n\n    /**\n     * @notice Update StableCoinProvider contract\n     */\n    function updateStableCoinProvider(IStableCoinProvider stableCoinProvider_) external onlyGovernor {\n        emit StableCoinProviderUpdated(stableCoinProvider, stableCoinProvider_);\n        stableCoinProvider = stableCoinProvider_;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = _setInitializedVersion(1);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        bool isTopLevelCall = _setInitializedVersion(version);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(version);\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        _setInitializedVersion(type(uint8).max);\n    }\n\n    function _setInitializedVersion(uint8 version) private returns (bool) {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\n        // of initializers, because in other contexts the contract may have been reentered.\n        if (_initializing) {\n            require(\n                version == 1 && !Address.isContract(address(this)),\n                \"Initializable: contract is already initialized\"\n            );\n            return false;\n        } else {\n            require(_initialized < version, \"Initializable: contract is already initialized\");\n            _initialized = version;\n            return true;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/core/IAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./IStableCoinProvider.sol\";\nimport \"./IPriceProvidersAggregator.sol\";\n\ninterface IAddressProvider {\n    function governor() external view returns (address);\n\n    function providersAggregator() external view returns (IPriceProvidersAggregator);\n\n    function stableCoinProvider() external view returns (IStableCoinProvider);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/core/IStableCoinProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IStableCoinProvider {\n    /**\n     * @notice Return the stable coin if pegged\n     * @dev Check price relation between both stable coins and revert if peg is too loose\n     * @return _stableCoin The primary stable coin if pass all checks\n     */\n    function getStableCoinIfPegged() external view returns (address _stableCoin);\n\n    /**\n     * @notice Convert given amount of stable coin to USD representation (18 decimals)\n     */\n    function toUsdRepresentation(uint256 stableCoinAmount_) external view returns (uint256 _usdAmount);\n}\n"
    },
    "contracts/interfaces/core/IPriceProvidersAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../libraries/DataTypes.sol\";\nimport \"./IPriceProvider.sol\";\n\n/**\n * @notice PriceProvidersAggregator interface\n * @dev Worth noting that the `_lastUpdatedAt` logic depends on the underlying price provider. In summary:\n * ChainLink: returns the last updated date from the aggregator\n * UniswapV2: returns the date of the latest pair oracle update\n * UniswapV3: assumes that the price is always updated (returns block.timestamp)\n * Flux: returns the last updated date from the aggregator\n * Umbrella (FCD): returns the last updated date returned from their oracle contract\n * Umbrella (Passport): returns the date of the latest pallet submission\n * Anytime that a quote performs more than one query, it uses the oldest date as the `_lastUpdatedAt`.\n * See more: https://github.com/bloqpriv/one-oracle/issues/64\n */\ninterface IPriceProvidersAggregator {\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param provider_ The price provider to get quote from\n     * @param token_ The address of asset\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(DataTypes.Provider provider_, address token_)\n        external\n        view\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Provider Providers' mapping\n     */\n    function priceProviders(DataTypes.Provider provider_) external view returns (IPriceProvider _priceProvider);\n\n    /**\n     * @notice Get quote\n     * @param provider_ The price provider to get quote from\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quote(\n        DataTypes.Provider provider_,\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @dev If providers aren't the same, uses native token as \"bridge\"\n     * @param providerIn_ The price provider to get quote for the tokenIn\n     * @param tokenIn_ The address of assetIn\n     * @param providerOut_ The price provider to get quote for the tokenOut\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quote(\n        DataTypes.Provider providerIn_,\n        address tokenIn_,\n        DataTypes.Provider providerOut_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param provider_ The price provider to get quote from\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(\n        DataTypes.Provider provider_,\n        address token_,\n        uint256 amountIn_\n    ) external view returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param provider_ The price provider to get quote from\n     * @param token_ The address of assetOut\n     * @param amountIn_ Input amount in USD\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(\n        DataTypes.Provider provider_,\n        address token_,\n        uint256 amountIn_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Set a price provider\n     * @dev Administrative function\n     * @param provider_ The provider (from enum)\n     * @param priceProvider_ The price provider contract\n     */\n    function setPriceProvider(DataTypes.Provider provider_, IPriceProvider priceProvider_) external;\n}\n"
    },
    "contracts/libraries/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nlibrary DataTypes {\n    /**\n     * @notice Price providers enumeration\n     */\n    enum Provider {\n        NONE,\n        CHAINLINK,\n        UNISWAP_V3,\n        UNISWAP_V2,\n        SUSHISWAP,\n        TRADERJOE,\n        PANGOLIN,\n        QUICKSWAP,\n        UMBRELLA_FIRST_CLASS,\n        UMBRELLA_PASSPORT,\n        FLUX\n    }\n\n    enum ExchangeType {\n        UNISWAP_V2,\n        SUSHISWAP,\n        TRADERJOE,\n        PANGOLIN,\n        QUICKSWAP,\n        UNISWAP_V3\n    }\n\n    enum SwapType {\n        EXACT_INPUT,\n        EXACT_OUTPUT\n    }\n}\n"
    },
    "contracts/interfaces/core/IPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IPriceProvider {\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of asset\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(address token_) external view returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(address token_, uint256 amountIn_)\n        external\n        view\n        returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetOut\n     * @param amountIn_ Input amount in USD\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(address token_, uint256 amountIn_)\n        external\n        view\n        returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n}\n"
    },
    "contracts/swapper/UniswapV2LikeExchange.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../dependencies/uniswap/libraries/UniswapV2Library.sol\";\nimport \"../access/Governable.sol\";\nimport \"../interfaces/swapper/IExchange.sol\";\n\n/**\n * @notice UniswapV2 Like Exchange\n */\ncontract UniswapV2LikeExchange is IExchange, Governable {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice The WETH-Like token (a.k.a. Native Token)\n     * @dev I.e. should be the most liquid token that offer best routers among trade pairs\n     * @dev It's usually the wrapper token of the chain's native coin but it isn't always true\n     * For instance: On Polygon, the `WETH` is more liquid than `WMATIC` on UniV3 protocol.\n     */\n    address public wethLike;\n\n    /**\n     * @notice The UniswapV2-Like factory contract\n     */\n    address public immutable factory;\n\n    bytes32 internal immutable initCodeHash;\n    /// @notice Emitted when wethLike token is updated\n    event WethLikeTokenUpdated(address oldWethLike, address newWethLike);\n\n    /**\n     * @dev Doesn't consider router.WETH() as `wethLike` because isn't guaranteed that it's the most liquid token.\n     */\n    constructor(\n        address factory_,\n        bytes32 initCodeHash_,\n        address wethLike_\n    ) {\n        factory = factory_;\n        initCodeHash = initCodeHash_;\n        wethLike = wethLike_;\n    }\n\n    /// @inheritdoc IExchange\n    function getAmountsIn(uint256 amountOut_, bytes memory path_) external view override returns (uint256 _amountIn) {\n        _amountIn = getAmountsIn(amountOut_, _decodePath(path_));\n    }\n\n    /// @inheritdoc IExchange\n    function getAmountsOut(uint256 amountIn_, bytes memory path_) external view override returns (uint256 _amountOut) {\n        _amountOut = getAmountsOut(amountIn_, _decodePath(path_));\n    }\n\n    /**\n     * @dev getBestAmountIn require a try/catch version of getAmountsIn and try/catch do not work with internal\n     * library functions, hence wrapped library call in this function so that it can be used in try/catch\n     */\n    function getAmountsIn(uint256 amountOut_, address[] memory path_) public view returns (uint256 _amountIn) {\n        _amountIn = UniswapV2Library.getAmountsIn(factory, initCodeHash, amountOut_, path_)[0];\n    }\n\n    /**\n     * @dev getBestAmountOut require a try/catch version of getAmountsOut and try/catch do not work with internal\n     * library functions, hence wrapped library call in this function so that it can be used in try/catch\n     */\n    function getAmountsOut(uint256 amountIn_, address[] memory path_) public view returns (uint256 _amountOut) {\n        _amountOut = UniswapV2Library.getAmountsOut(factory, initCodeHash, amountIn_, path_)[path_.length - 1];\n    }\n\n    /// @inheritdoc IExchange\n    function getBestAmountIn(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountOut_\n    ) external returns (uint256 _amountIn, bytes memory _path) {\n        // 1. Check IN-OUT pair\n        address[] memory _pathA = new address[](2);\n        _pathA[0] = tokenIn_;\n        _pathA[1] = tokenOut_;\n        uint256 _amountInA = _getAmountsIn(amountOut_, _pathA);\n\n        if (tokenIn_ == wethLike || tokenOut_ == wethLike) {\n            // Returns if one of the token is WETH-Like\n            require(_amountInA > 0, \"no-path-found\");\n            return (_amountInA, _encodePath(_pathA));\n        }\n\n        // 2. Check IN-WETH-OUT path\n        address[] memory _pathB = new address[](3);\n        _pathB[0] = tokenIn_;\n        _pathB[1] = wethLike;\n        _pathB[2] = tokenOut_;\n        uint256 _amountInB = _getAmountsIn(amountOut_, _pathB);\n\n        // 3. Get best route between paths A and B\n        require(_amountInA > 0 || _amountInB > 0, \"no-path-found\");\n\n        // Returns A if it's valid and better than B or if B isn't valid\n        if ((_amountInA > 0 && _amountInA < _amountInB) || _amountInB == 0) {\n            return (_amountInA, _encodePath(_pathA));\n        }\n        return (_amountInB, _encodePath(_pathB));\n    }\n\n    /// @inheritdoc IExchange\n    function getBestAmountOut(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external returns (uint256 _amountOut, bytes memory _path) {\n        // 1. Check IN-OUT pair\n        address[] memory _pathA = new address[](2);\n        _pathA[0] = tokenIn_;\n        _pathA[1] = tokenOut_;\n        uint256 _amountOutA = _getAmountsOut(amountIn_, _pathA);\n\n        if (tokenIn_ == wethLike || tokenOut_ == wethLike) {\n            // Returns if one of the token is WETH-Like\n            require(_amountOutA > 0, \"no-path-found\");\n            return (_amountOutA, _encodePath(_pathA));\n        }\n\n        // 2. Check IN-WETH-OUT path\n        address[] memory _pathB = new address[](3);\n        _pathB[0] = tokenIn_;\n        _pathB[1] = wethLike;\n        _pathB[2] = tokenOut_;\n        uint256 _amountOutB = _getAmountsOut(amountIn_, _pathB);\n\n        // 3. Get best route between paths A and B\n        require(_amountOutA > 0 || _amountOutB > 0, \"no-path-found\");\n        if (_amountOutA > _amountOutB) return (_amountOutA, _encodePath(_pathA));\n        return (_amountOutB, _encodePath(_pathB));\n    }\n\n    /// @inheritdoc IExchange\n    function swapExactInput(\n        bytes calldata path_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address outReceiver_\n    ) external returns (uint256 _amountOut) {\n        address[] memory _path = _decodePath(path_);\n        IERC20 _tokenIn = IERC20(_path[0]);\n        IERC20 _tokenOut = IERC20(_path[_path.length - 1]);\n\n        _tokenIn.safeTransfer(UniswapV2Library.pairFor(factory, initCodeHash, _path[0], _path[1]), amountIn_);\n        uint256 balanceBefore = _tokenOut.balanceOf(outReceiver_);\n        _swap(_path, outReceiver_);\n        _amountOut = _tokenOut.balanceOf(outReceiver_) - balanceBefore;\n        require(_amountOut >= amountOutMin_, \"Too little received\");\n    }\n\n    /// @inheritdoc IExchange\n    function swapExactOutput(\n        bytes calldata path_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address inSender_,\n        address outRecipient_\n    ) external returns (uint256 _amountIn) {\n        address[] memory _path = _decodePath(path_);\n        IERC20 _tokenIn = IERC20(_path[0]);\n\n        _amountIn = UniswapV2Library.getAmountsIn(factory, initCodeHash, amountOut_, _path)[0];\n        require(_amountIn <= amountInMax_, \"Too much requested\");\n\n        _tokenIn.safeTransfer(UniswapV2Library.pairFor(factory, initCodeHash, _path[0], _path[1]), _amountIn);\n        _swap(_path, outRecipient_);\n\n        // If swap end up costly less than _amountInMax then return remaining\n        uint256 _remainingAmountIn = amountInMax_ - _amountIn;\n        if (_remainingAmountIn > 0) {\n            _tokenIn.safeTransfer(inSender_, _remainingAmountIn);\n        }\n    }\n\n    /// @dev Returns `0` if reverts\n    function _getAmountsIn(uint256 _amountOut, address[] memory _path) internal view returns (uint256 _amountIn) {\n        try this.getAmountsIn(_amountOut, _path) returns (uint256 amountIn) {\n            _amountIn = amountIn;\n        } catch {}\n    }\n\n    /// @dev Returns `0` if reverts\n    function _getAmountsOut(uint256 amountIn_, address[] memory path_) internal view returns (uint256 _amountOut) {\n        try this.getAmountsOut(amountIn_, path_) returns (uint256 amountOut) {\n            _amountOut = amountOut;\n        } catch {}\n    }\n\n    /**\n     * @notice Encode path from `address[]` to `bytes`\n     */\n    function _encodePath(address[] memory path_) private pure returns (bytes memory _path) {\n        return abi.encode(path_);\n    }\n\n    /**\n     * @notice Encode path from `bytes` to `address[]`\n     */\n    function _decodePath(bytes memory path_) private pure returns (address[] memory _path) {\n        return abi.decode(path_, (address[]));\n    }\n\n    /**\n     * NOTICE:: This function is being used as is from Uniswap's V2SwapRouter.sol deployed\n     * at 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45 and licensed under GPL-2.0-or-later.\n     * - It does supports fee-on-transfer tokens\n     * - It does requires the initial amount to have already been sent to the first pair\n     */\n    function _swap(address[] memory path, address _to) private {\n        for (uint256 i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0, ) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, initCodeHash, input, output));\n            uint256 amountInput;\n            uint256 amountOutput;\n            // scope to avoid stack too deep errors\n            {\n                (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n                (uint256 reserveInput, uint256 reserveOutput) = input == token0\n                    ? (reserve0, reserve1)\n                    : (reserve1, reserve0);\n                amountInput = IERC20(input).balanceOf(address(pair)) - reserveInput;\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\n                ? (uint256(0), amountOutput)\n                : (amountOutput, uint256(0));\n            address to = i < path.length - 2\n                ? UniswapV2Library.pairFor(factory, initCodeHash, output, path[i + 2])\n                : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    /**\n     * @notice Update WETH-Like token\n     */\n    function updateWethLikeToken(address wethLike_) external onlyGovernor {\n        emit WethLikeTokenUpdated(wethLike, wethLike_);\n        wethLike = wethLike_;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/dependencies/uniswap/libraries/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport '@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol';\n\n/**\n * This is copied from Uniswap's V2SwapRouter.sol deployed at 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45\n * and licensed under GPL-2.0-or-later.\n * Changelog:\n * - Removed hardcoded initCodeHash and taking as param so that we can support multiple UniswapV2Like exchanges\n * - Added function getAmountsOut()\n */\nlibrary UniswapV2Library {\n    using LowGasSafeMath for uint256;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB);\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0));\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint160\n        (uint256(keccak256(abi.encodePacked(\n                hex'ff',\n                factory,\n                keccak256(abi.encodePacked(token0, token1)),\n                initCodeHash\n            )))));\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address factory,\n        bytes32 initCodeHash,\n        address tokenA,\n        address tokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, initCodeHash, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(amountIn > 0, 'INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0);\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        require(amountOut > 0, 'INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0);\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n        // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address factory,\n        bytes32 initCodeHash,\n        uint amountIn,\n        address[] memory path\n    ) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2);\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; i++) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, initCodeHash, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address factory,\n        bytes32 initCodeHash,\n        uint256 amountOut,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2);\n        amounts = new uint256[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory,initCodeHash, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/swapper/IExchange.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity <=0.8.9;\n\n/**\n * @notice Exchange interface\n */\ninterface IExchange {\n    /**\n     * @notice Get *spot* quote\n     * It will return the swap amount based on the current reserves of the given path (i.e. spot price)\n     * @dev It shouldn't be used as oracle!!!\n     */\n    function getAmountsIn(uint256 _amountOut, bytes memory path_) external returns (uint256 _amountIn);\n\n    /**\n     * @notice Get *spot* quote\n     * It will return the swap amount based on the current reserves of the given path (i.e. spot price)\n     * @dev It shouldn't be used as oracle!!!\n     */\n    function getAmountsOut(uint256 amountIn_, bytes memory path_) external returns (uint256 _amountOut);\n\n    /**\n     * @notice Get *spot* quote\n     * It will return the swap amount based on the current reserves of the best pair/path found (i.e. spot price)\n     * @dev It shouldn't be used as oracle!!!\n     */\n    function getBestAmountIn(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountOut_\n    ) external returns (uint256 _amountIn, bytes memory _path);\n\n    /**\n     * @notice Get *spot* quote\n     * It will return the swap amount based on the current reserves of the best pair/path found (i.e. spot price)\n     * @dev It shouldn't be used as oracle!!!\n     */\n    function getBestAmountOut(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external returns (uint256 _amountOut, bytes memory _path);\n\n    /**\n     * @notice Perform an exact input swap\n     * @dev Should transfer `amountIn_` before performing swap\n     */\n    function swapExactInput(\n        bytes calldata path_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address outReceiver_\n    ) external returns (uint256 _amountOut);\n\n    /**\n     * @notice Perform an exact output swap\n     * @dev Should transfer `amountInMax_` before performing swap\n     * @dev Sends swap remains - if any - to the `inSender_`\n     */\n    function swapExactOutput(\n        bytes calldata path_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address inSender_,\n        address outRecipient_\n    ) external returns (uint256 _amountIn);\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.0;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary LowGasSafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y);\n    }\n\n    /// @notice Returns x + y, reverts if overflows or underflows\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x + y) >= x == (y >= 0));\n    }\n\n    /// @notice Returns x - y, reverts if overflows or underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x - y) <= x == (y >= 0));\n    }\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/libraries/SafeUint128.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6;\n\n/// @title Safe uint128 casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeUint128 {\n    /// @notice Cast a uint256 to a uint128, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint128\n    function toUint128(uint256 y) internal pure returns (uint128 z) {\n        require((z = uint128(y)) == y, \"error-when-casting\");\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/IQuoter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Quoter Interface\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\ninterface IQuoter {\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\n    /// @param amountIn The amount of the first token to swap\n    /// @return amountOut The amount of the last token that would be received\n    function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\n\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\n    /// @param tokenIn The token being swapped in\n    /// @param tokenOut The token being swapped out\n    /// @param fee The fee of the token pool to consider for the pair\n    /// @param amountIn The desired input amount\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountOut The amount of `tokenOut` that would be received\n    function quoteExactInputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountOut);\n\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\n    /// @param amountOut The amount of the last token to receive\n    /// @return amountIn The amount of first token required to be paid\n    function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\n\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\n    /// @param tokenIn The token being swapped in\n    /// @param tokenOut The token being swapped out\n    /// @param fee The fee of the token pool to consider for the pair\n    /// @param amountOut The desired output amount\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\n    function quoteExactOutputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountOut,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountIn);\n}\n"
    },
    "contracts/swapper/RoutedSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../access/Governable.sol\";\nimport \"../interfaces/swapper/IRoutedSwapper.sol\";\nimport \"../interfaces/swapper/IExchange.sol\";\nimport \"../libraries/DataTypes.sol\";\n\n/**\n * @notice Routed Swapper contract\n * This contract execute swaps and quoted using pre-set swap routes\n */\ncontract RoutedSwapper is IRoutedSwapper, Governable {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /**\n     * @notice List of the supported exchanges\n     */\n    EnumerableSet.AddressSet private allExchanges;\n\n    /**\n     * @notice Mapping of exchanges' addresses by type\n     */\n    mapping(DataTypes.ExchangeType => address) public addressOf;\n\n    /**\n     * @notice Default swap routings\n     * @dev Used to save gas by using a preset routing instead of looking for the best\n     */\n    mapping(bytes => bytes) public defaultRoutings;\n\n    /// @notice Emitted when an exchange is added\n    event ExchangeUpdated(\n        DataTypes.ExchangeType indexed exchangeType,\n        address indexed oldExchange,\n        address indexed newExchange\n    );\n\n    /// @notice Emitted when exact-input swap is executed\n    event SwapExactInput(\n        IExchange indexed exchange,\n        bytes path,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    /// @notice Emitted when exact-output swap is executed\n    event SwapExactOutput(\n        IExchange indexed exchange,\n        bytes path,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 amountInMax,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    /// @notice Emitted when default routing is updated\n    event DefaultRoutingUpdated(bytes key, bytes oldRouting, bytes newRouting);\n\n    /// @inheritdoc IRoutedSwapper\n    function getAmountIn(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountOut_\n    ) public returns (uint256 _amountIn) {\n        bytes memory _defaultRouting = defaultRoutings[\n            abi.encodePacked(DataTypes.SwapType.EXACT_OUTPUT, tokenIn_, tokenOut_)\n        ];\n        require(_defaultRouting.length > 0, \"no-routing-found\");\n\n        (DataTypes.ExchangeType _exchangeType, bytes memory _path) = abi.decode(\n            _defaultRouting,\n            (DataTypes.ExchangeType, bytes)\n        );\n\n        _amountIn = IExchange(addressOf[_exchangeType]).getAmountsIn(amountOut_, _path);\n    }\n\n    /// @inheritdoc IRoutedSwapper\n    function getAmountOut(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) public returns (uint256 _amountOut) {\n        bytes memory _defaultRouting = defaultRoutings[\n            abi.encodePacked(DataTypes.SwapType.EXACT_INPUT, tokenIn_, tokenOut_)\n        ];\n        require(_defaultRouting.length > 0, \"no-routing-found\");\n\n        (DataTypes.ExchangeType _exchangeType, bytes memory _path) = abi.decode(\n            _defaultRouting,\n            (DataTypes.ExchangeType, bytes)\n        );\n\n        _amountOut = IExchange(addressOf[_exchangeType]).getAmountsOut(amountIn_, _path);\n    }\n\n    /// @inheritdoc IRoutedSwapper\n    function getAllExchanges() external view override returns (address[] memory) {\n        return allExchanges.values();\n    }\n\n    /// @inheritdoc IRoutedSwapper\n    function swapExactInput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address receiver_\n    ) external returns (uint256 _amountOut) {\n        bytes memory _defaultRouting = defaultRoutings[\n            abi.encodePacked(DataTypes.SwapType.EXACT_INPUT, tokenIn_, tokenOut_)\n        ];\n        require(_defaultRouting.length > 0, \"no-routing-found\");\n\n        (DataTypes.ExchangeType _exchangeType, bytes memory _path) = abi.decode(\n            _defaultRouting,\n            (DataTypes.ExchangeType, bytes)\n        );\n\n        IExchange _exchange = IExchange(addressOf[_exchangeType]);\n        uint256 _balanceBefore = IERC20(tokenIn_).balanceOf(address(_exchange));\n        IERC20(tokenIn_).safeTransferFrom(msg.sender, address(_exchange), amountIn_);\n        _amountOut = _exchange.swapExactInput(\n            _path,\n            // amountIn will be balanceNow - balanceBefore for fee-on-transfer tokens\n            IERC20(tokenIn_).balanceOf(address(_exchange)) - _balanceBefore,\n            amountOutMin_,\n            receiver_\n        );\n        emit SwapExactInput(_exchange, _path, tokenIn_, tokenOut_, amountIn_, _amountOut);\n    }\n\n    /// @inheritdoc IRoutedSwapper\n    function swapExactOutput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address receiver_\n    ) external returns (uint256 _amountIn) {\n        bytes memory _defaultRouting = defaultRoutings[\n            abi.encodePacked(DataTypes.SwapType.EXACT_OUTPUT, tokenIn_, tokenOut_)\n        ];\n        require(_defaultRouting.length > 0, \"no-routing-found\");\n        (DataTypes.ExchangeType _exchangeType, bytes memory _path) = abi.decode(\n            _defaultRouting,\n            (DataTypes.ExchangeType, bytes)\n        );\n\n        IExchange _exchange = IExchange(addressOf[_exchangeType]);\n        IERC20(tokenIn_).safeTransferFrom(msg.sender, address(_exchange), amountInMax_);\n        _amountIn = _exchange.swapExactOutput(_path, amountOut_, amountInMax_, msg.sender, receiver_);\n        emit SwapExactOutput(_exchange, _path, tokenIn_, tokenOut_, amountInMax_, _amountIn, amountOut_);\n    }\n\n    /**\n     * @notice Add or update exchange\n     * @dev Use null `exchange_` for removal\n     */\n    function setExchange(DataTypes.ExchangeType type_, address exchange_) external onlyGovernor {\n        address _currentExchange = addressOf[type_];\n\n        if (_currentExchange == address(0)) {\n            // Adding\n            require(allExchanges.add(exchange_), \"exchange-exists\");\n            addressOf[type_] = exchange_;\n        } else if (exchange_ == address(0)) {\n            // Removing\n            require(allExchanges.remove(_currentExchange), \"exchange-does-not-exist\");\n            delete addressOf[type_];\n        } else {\n            // Updating\n            require(allExchanges.remove(_currentExchange), \"exchange-does-not-exist\");\n            require(allExchanges.add(exchange_), \"exchange-exists\");\n            addressOf[type_] = exchange_;\n        }\n        emit ExchangeUpdated(type_, _currentExchange, exchange_);\n    }\n\n    /**\n     * @notice Set default routing\n     * @dev Use empty `path_` for removal\n     * @param swapType_ If the routing is related to `EXACT_INPUT` or `EXACT_OUTPUT`\n     * @param tokenIn_ The swap in token\n     * @param tokenOut_ The swap out token\n     * @param exchange_ The type (i.e. protocol) of the exchange\n     * @param path_ The swap path\n     * @dev Use `abi.encodePacked(tokenA, poolFee1, tokenB, poolFee2, tokenC, ...)` for UniswapV3 exchange\n     * @dev Use `abi.encode([tokenA, tokenB, tokenC, ...])` for UniswapV2-like exchanges\n     */\n    function setDefaultRouting(\n        DataTypes.SwapType swapType_,\n        address tokenIn_,\n        address tokenOut_,\n        DataTypes.ExchangeType exchange_,\n        bytes calldata path_\n    ) external onlyGovernor {\n        bytes memory _key = abi.encodePacked(swapType_, tokenIn_, tokenOut_);\n        bytes memory _currentRouting = defaultRoutings[_key];\n        bytes memory _newRouting = abi.encode(exchange_, path_);\n        if (path_.length == 0) {\n            delete defaultRoutings[_key];\n        } else {\n            defaultRoutings[_key] = _newRouting;\n        }\n        emit DefaultRoutingUpdated(_key, _currentRouting, _newRouting);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/interfaces/swapper/IRoutedSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/**\n * @notice Routed Swapper interface\n * @dev This contract doesn't support native coins (e.g. ETH, AVAX, MATIC, etc) use wrapper tokens instead\n */\ninterface IRoutedSwapper {\n    /**\n     * @notice The list of supported DEXes\n     * @dev This function is gas intensive\n     */\n    function getAllExchanges() external view returns (address[] memory);\n\n    /**\n     * @notice Get *spot* quote\n     * It will return the swap amount based on the current reserves of the best pair/path found (i.e. spot price).\n     * @dev It shouldn't be used as oracle!!!\n     */\n    function getAmountIn(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountOut_\n    ) external returns (uint256 _amountIn);\n\n    /**\n     * @notice Get *spot* quote\n     * It will return the swap amount based on the current reserves of the best pair/path found (i.e. spot price).\n     * @dev It shouldn't be used as oracle!!!\n     */\n    function getAmountOut(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external returns (uint256 _amountOut);\n\n    /**\n     * @notice Perform an exact input swap - will revert if there is no default routing\n     */\n    function swapExactInput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address _receiver\n    ) external returns (uint256 _amountOut);\n\n    /**\n     * @notice Perform an exact output swap - will revert if there is no default routing\n     */\n    function swapExactOutput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address receiver_\n    ) external returns (uint256 _amountIn);\n}\n"
    },
    "contracts/swapper/Swapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../access/Governable.sol\";\nimport \"../interfaces/swapper/ISwapper.sol\";\nimport \"../libraries/DataTypes.sol\";\n\n/**\n * @notice Swapper contract\n * This contract encapsulates DEXes and use them to perform swaps using the best trade path as possible\n */\ncontract Swapper is ISwapper, Governable {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /**\n     * @notice List of the supported exchanges\n     */\n    EnumerableSet.AddressSet private allExchanges;\n\n    /**\n     * @notice List of the exchanges to loop over when getting best paths\n     */\n    EnumerableSet.AddressSet private mainExchanges;\n\n    /**\n     * @notice Mapping of exchanges' addresses by type\n     */\n    mapping(DataTypes.ExchangeType => address) public addressOf;\n\n    /**\n     * @notice Default swap routings\n     * @dev Used to save gas by using a preset routing instead of looking for the best\n     */\n    mapping(bytes => bytes) public defaultRoutings;\n\n    /**\n     * @notice The oracle contract\n     * @dev This is used to set acceptable slippage parameters\n     */\n    IOracle public override oracle;\n\n    /**\n     * @notice Max slippage acceptable\n     * @dev Use 18 decimals (e.g. 0.2e18 = 20%)\n     */\n    uint256 public override maxSlippage;\n\n    /// @notice Emitted when an exchange is added\n    event ExchangeUpdated(\n        DataTypes.ExchangeType indexed exchangeType,\n        address indexed oldExchange,\n        address indexed newExchange\n    );\n\n    /// @notice Emitted when an exchanges to loop over are updated\n    event ExchangeAsMainUpdated(DataTypes.ExchangeType indexed exchangeType, bool isMain);\n\n    /// @notice Emitted when the oracle is updated\n    event OracleUpdated(IOracle indexed oldOracle, IOracle indexed newOracle);\n\n    /// @notice Emitted when the max slippage is updated\n    event MaxSlippageUpdated(uint256 oldMaxSlippage, uint256 newMaxSlippage);\n\n    /// @notice Emitted when exact-input swap is executed\n    event SwapExactInput(\n        IExchange indexed exchange,\n        bytes path,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    /// @notice Emitted when exact-output swap is executed\n    event SwapExactOutput(\n        IExchange indexed exchange,\n        bytes path,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 amountInMax,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    /// @notice Emitted when default routing is updated\n    event DefaultRoutingUpdated(bytes key, bytes oldRouting, bytes newRouting);\n\n    constructor(IOracle oracle_, uint256 maxSlippage_) {\n        require(address(oracle_) != address(0), \"oracle-is-null\");\n        oracle = oracle_;\n        maxSlippage = maxSlippage_;\n    }\n\n    /// @inheritdoc ISwapper\n    function getBestAmountIn(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountOut_\n    )\n        public\n        returns (\n            uint256 _amountInMax,\n            IExchange _exchange,\n            bytes memory _path\n        )\n    {\n        _amountInMax = (oracle.quote(tokenOut_, tokenIn_, amountOut_) * (1e18 + maxSlippage)) / 1e18;\n\n        // 1. Return default routing if any\n        bytes memory _defaultRouting = defaultRoutings[\n            abi.encodePacked(DataTypes.SwapType.EXACT_OUTPUT, tokenIn_, tokenOut_)\n        ];\n        if (_defaultRouting.length > 0) {\n            DataTypes.ExchangeType _exchangeType;\n            (_exchangeType, _path) = abi.decode(_defaultRouting, (DataTypes.ExchangeType, bytes));\n            return (_amountInMax, IExchange(addressOf[_exchangeType]), _path);\n        }\n\n        // 2. Look for the best routing\n        uint256 _amountIn = type(uint256).max;\n        uint256 _len = mainExchanges.length();\n        for (uint256 i; i < _len; ++i) {\n            IExchange _iExchange = IExchange(mainExchanges.at(i));\n            (uint256 _iAmountIn, bytes memory _iPath) = _iExchange.getBestAmountIn(tokenIn_, tokenOut_, amountOut_);\n            if (_iAmountIn > 0 && _iAmountIn < _amountIn && _iAmountIn <= _amountInMax) {\n                _amountIn = _iAmountIn;\n                _exchange = _iExchange;\n                _path = _iPath;\n            }\n        }\n        require(_path.length > 0, \"no-routing-found\");\n    }\n\n    /// @inheritdoc ISwapper\n    function getBestAmountOut(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        public\n        returns (\n            uint256 _amountOutMin,\n            IExchange _exchange,\n            bytes memory _path\n        )\n    {\n        _amountOutMin = (oracle.quote(tokenIn_, tokenOut_, amountIn_) * (1e18 - maxSlippage)) / 1e18;\n\n        // 1. Return default routing if any\n        bytes memory _defaultRouting = defaultRoutings[\n            abi.encodePacked(DataTypes.SwapType.EXACT_INPUT, tokenIn_, tokenOut_)\n        ];\n        if (_defaultRouting.length > 0) {\n            DataTypes.ExchangeType _exchangeType;\n            (_exchangeType, _path) = abi.decode(_defaultRouting, (DataTypes.ExchangeType, bytes));\n            return (_amountOutMin, IExchange(addressOf[_exchangeType]), _path);\n        }\n\n        // 2. Look for the best routing\n        uint256 _amountOut;\n        uint256 _len = mainExchanges.length();\n        for (uint256 i; i < _len; ++i) {\n            IExchange _iExchange = IExchange(mainExchanges.at(i));\n            (uint256 _iAmountOut, bytes memory _iPath) = _iExchange.getBestAmountOut(tokenIn_, tokenOut_, amountIn_);\n            if (_iAmountOut > _amountOut && _iAmountOut >= _amountOutMin) {\n                _amountOut = _iAmountOut;\n                _exchange = _iExchange;\n                _path = _iPath;\n            }\n        }\n\n        require(_path.length > 0, \"no-routing-found\");\n    }\n\n    /// @inheritdoc ISwapper\n    function getAllExchanges() external view override returns (address[] memory) {\n        return allExchanges.values();\n    }\n\n    /// @inheritdoc ISwapper\n    function getMainExchanges() external view override returns (address[] memory) {\n        return mainExchanges.values();\n    }\n\n    /// @inheritdoc ISwapper\n    function swapExactInput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_,\n        address receiver_\n    ) external returns (uint256 _amountOut) {\n        (uint256 _amountOutMin, IExchange _exchange, bytes memory _path) = getBestAmountOut(\n            tokenIn_,\n            tokenOut_,\n            amountIn_\n        );\n        return _swapExactInput(tokenIn_, tokenOut_, amountIn_, receiver_, _amountOutMin, _exchange, _path);\n    }\n\n    /// @inheritdoc ISwapper\n    function swapExactOutput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountOut_,\n        address receiver_\n    ) external returns (uint256 _amountIn) {\n        (uint256 _amountInMax, IExchange _exchange, bytes memory _path) = getBestAmountIn(\n            tokenIn_,\n            tokenOut_,\n            amountOut_\n        );\n        return _swapExactOutput(tokenIn_, tokenOut_, amountOut_, receiver_, _amountInMax, _exchange, _path);\n    }\n\n    /**\n     * @notice Add or update exchange\n     * @dev Use null `exchange_` for removal\n     */\n    function setExchange(DataTypes.ExchangeType type_, address exchange_) external onlyGovernor {\n        address _currentExchange = addressOf[type_];\n\n        if (_currentExchange == address(0)) {\n            // Adding\n            require(allExchanges.add(exchange_), \"exchange-exists\");\n            require(mainExchanges.add(exchange_), \"main-exchange-exists\");\n            addressOf[type_] = exchange_;\n        } else if (exchange_ == address(0)) {\n            // Removing\n            require(allExchanges.remove(_currentExchange), \"exchange-does-not-exist\");\n            if (mainExchanges.contains(_currentExchange)) {\n                mainExchanges.remove(_currentExchange);\n            }\n            delete addressOf[type_];\n        } else {\n            // Updating\n            if (mainExchanges.contains(_currentExchange)) {\n                mainExchanges.remove(_currentExchange);\n            }\n            require(allExchanges.remove(_currentExchange), \"exchange-does-not-exist\");\n            require(allExchanges.add(exchange_), \"exchange-exists\");\n            require(mainExchanges.add(exchange_), \"main-exchange-exists\");\n            addressOf[type_] = exchange_;\n        }\n        emit ExchangeUpdated(type_, _currentExchange, exchange_);\n    }\n\n    /**\n     * @notice Toggle exchange as main\n     */\n    function toggleExchangeAsMain(DataTypes.ExchangeType type_) public onlyGovernor {\n        address _address = addressOf[type_];\n        require(_address != address(0), \"exchange-does-not-exist\");\n        if (mainExchanges.contains(_address)) {\n            mainExchanges.remove(_address);\n            emit ExchangeAsMainUpdated(type_, false);\n        } else {\n            mainExchanges.add(_address);\n            emit ExchangeAsMainUpdated(type_, true);\n        }\n    }\n\n    /**\n     * @notice Update max slippage\n     */\n    function updateMaxSlippage(uint256 maxSlippage_) external onlyGovernor {\n        require(maxSlippage_ <= 1e18, \"max-slippage-gt-100%\");\n        emit MaxSlippageUpdated(maxSlippage, maxSlippage_);\n        maxSlippage = maxSlippage_;\n    }\n\n    /**\n     * @notice Update oracle contract\n     */\n    function updateOracle(IOracle oracle_) external onlyGovernor {\n        require(address(oracle_) != address(0), \"address-is-null\");\n        emit OracleUpdated(oracle, oracle_);\n        oracle = oracle_;\n    }\n\n    /**\n     * @notice Set default routing\n     * @dev Use empty `path_` for removal\n     * @param swapType_ If the routing is related to `EXACT_INPUT` or `EXACT_OUTPUT`\n     * @param tokenIn_ The swap in token\n     * @param tokenOut_ The swap out token\n     * @param exchange_ The type (i.e. protocol) of the exchange\n     * @param path_ The swap path\n     * @dev Use `abi.encodePacked(tokenA, poolFee1, tokenB, poolFee2, tokenC, ...)` for UniswapV3 exchange\n     * @dev Use `abi.encode([tokenA, tokenB, tokenC, ...])` for UniswapV2-like exchanges\n     */\n    function setDefaultRouting(\n        DataTypes.SwapType swapType_,\n        address tokenIn_,\n        address tokenOut_,\n        DataTypes.ExchangeType exchange_,\n        bytes calldata path_\n    ) external onlyGovernor {\n        bytes memory _key = abi.encodePacked(swapType_, tokenIn_, tokenOut_);\n        bytes memory _currentRouting = defaultRoutings[_key];\n        bytes memory _newRouting = abi.encode(exchange_, path_);\n        if (path_.length == 0) {\n            delete defaultRoutings[_key];\n        } else {\n            defaultRoutings[_key] = _newRouting;\n        }\n        emit DefaultRoutingUpdated(_key, _currentRouting, _newRouting);\n    }\n\n    /**\n     * @notice Perform an exact input swap\n     * @dev This code is reused by public/external functions\n     */\n    function _swapExactInput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_,\n        address receiver_,\n        uint256 _amountOutMin,\n        IExchange _exchange,\n        bytes memory _path\n    ) private returns (uint256 _amountOut) {\n        uint256 _balanceBefore = IERC20(tokenIn_).balanceOf(address(_exchange));\n        IERC20(tokenIn_).safeTransferFrom(msg.sender, address(_exchange), amountIn_);\n        _amountOut = _exchange.swapExactInput(\n            _path,\n            // amountIn will be balanceNow - balanceBefore for fee-on-transfer tokens\n            IERC20(tokenIn_).balanceOf(address(_exchange)) - _balanceBefore,\n            _amountOutMin,\n            receiver_\n        );\n        emit SwapExactInput(_exchange, _path, tokenIn_, tokenOut_, amountIn_, _amountOut);\n    }\n\n    /**\n     * @notice Perform an exact output swap\n     * @dev This code is reused by public/external functions\n     */\n    function _swapExactOutput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountOut_,\n        address receiver_,\n        uint256 _amountInMax,\n        IExchange _exchange,\n        bytes memory _path\n    ) private returns (uint256 _amountIn) {\n        IERC20(tokenIn_).safeTransferFrom(msg.sender, address(_exchange), _amountInMax);\n        _amountIn = _exchange.swapExactOutput(_path, amountOut_, _amountInMax, msg.sender, receiver_);\n        emit SwapExactOutput(_exchange, _path, tokenIn_, tokenOut_, _amountInMax, _amountIn, amountOut_);\n    }\n}\n"
    },
    "contracts/interfaces/swapper/ISwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../periphery/IOracle.sol\";\nimport \"./IExchange.sol\";\n\n/**\n * @notice Swapper interface\n * @dev This contract doesn't support native coins (e.g. ETH, AVAX, MATIC, etc) use wrapper tokens instead\n */\ninterface ISwapper {\n    /**\n     * @notice The list of supported DEXes\n     * @dev This function is gas intensive\n     */\n    function getAllExchanges() external view returns (address[] memory);\n\n    /**\n     * @notice The list of main DEXes\n     * @dev This function is gas intensive\n     */\n    function getMainExchanges() external view returns (address[] memory);\n\n    /**\n     * @notice Oracle to get prices from\n     * @dev Is used combined with `slippage` in order to check swaps outcomes and reject if aren't acceptable\n     */\n    function oracle() external view returns (IOracle);\n\n    /**\n     * @notice Get max acceptable slippage\n     * @dev Swaps will revert if actual output from swap is too far from oracle price\n     */\n    function maxSlippage() external view returns (uint256);\n\n    /**\n     * @notice Get *spot* quote\n     * It will return the swap amount based on the current reserves of the best pair/path found (i.e. spot price).\n     * @dev It shouldn't be used as oracle!!!\n     */\n    function getBestAmountIn(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountOut_\n    )\n        external\n        returns (\n            uint256 _amountInMax,\n            IExchange _exchange,\n            bytes memory _path\n        );\n\n    /**\n     * @notice Get *spot* quote\n     * It will return the swap amount based on the current reserves of the best pair/path found (i.e. spot price).\n     * @dev It shouldn't be used as oracle!!!\n     */\n    function getBestAmountOut(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        returns (\n            uint256 _amountOutMin,\n            IExchange _exchange,\n            bytes memory _path\n        );\n\n    /**\n     * @notice Perform an exact input swap\n     */\n    function swapExactInput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_,\n        address _receiver\n    ) external returns (uint256 _amountOut);\n\n    /**\n     * @notice Perform an exact output swap\n     */\n    function swapExactOutput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountOut_,\n        address _receiver\n    ) external returns (uint256 _amountIn);\n}\n"
    },
    "contracts/interfaces/periphery/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IOracle {\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of asset\n     * @return _priceInUsd The USD price\n     */\n    function getPriceInUsd(address token_) external view returns (uint256 _priceInUsd);\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external view returns (uint256 _amountOut);\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     */\n    function quoteTokenToUsd(address token_, uint256 amountIn_) external view returns (uint256 amountOut_);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetOut\n     * @param amountIn_ Input amount in USD\n     * @return _amountOut Output amount of token\n     */\n    function quoteUsdToToken(address token_, uint256 amountIn_) external view returns (uint256 _amountOut);\n}\n"
    },
    "contracts/periphery/tokens/YEarnTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\nimport \"../../interfaces/periphery/IOracle.sol\";\nimport \"../../interfaces/external/yearn/IYearn.sol\";\n\n/**\n * @title Oracle for Yearn tokens\n */\ncontract YEarnTokenOracle is ITokenOracle {\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address token_) external view returns (uint256 _priceInUsd) {\n        IYearn _yToken = IYearn(token_);\n        uint256 _underlyingPrice = IOracle(msg.sender).getPriceInUsd(_yToken.token());\n        return (_yToken.getPricePerFullShare() * _underlyingPrice) / 1e18; // getPricePerFullShare is scaled by 1e18\n    }\n}\n"
    },
    "contracts/interfaces/periphery/ITokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ITokenOracle {\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of asset\n     * @return _priceInUsd The USD price\n     */\n    function getPriceInUsd(address token_) external view returns (uint256 _priceInUsd);\n}\n"
    },
    "contracts/interfaces/external/yearn/IYearn.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IYearn {\n    function decimals() external view returns (uint8);\n\n    function getPricePerFullShare() external view returns (uint256);\n\n    function token() external view returns (address);\n}\n"
    },
    "contracts/periphery/tokens/UniswapV2LikeLpTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@prb/math/contracts/PRBMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"../../interfaces/periphery/IOracle.sol\";\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\nimport \"../../libraries/OracleHelpers.sol\";\n\n/**\n * @title Oracle for UniswapV2-Like liquidity pair tokens\n * @dev See more: https://blog.alphaventuredao.io/fair-lp-token-pricing/\n */\ncontract UniswapV2LikeLpTokenOracle is ITokenOracle {\n    using OracleHelpers for uint256;\n    using PRBMath for uint256;\n\n    /**\n     * @notice The oracle that resolves the price of underlying token\n     */\n    IOracle public immutable underlyingOracle;\n\n    constructor(IOracle _underlyingOracle) {\n        require(address(_underlyingOracle) != address(0), \"underlying-oracle-null\");\n        underlyingOracle = _underlyingOracle;\n    }\n\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address _asset) external view returns (uint256 _priceInUsd) {\n        IUniswapV2Pair _pair = IUniswapV2Pair(address(_asset));\n        (uint256 _reserve0, uint256 _reserve1, ) = _pair.getReserves();\n\n        address _token0 = _pair.token0();\n        address _token1 = _pair.token1();\n\n        _reserve0 = OracleHelpers.scaleDecimal(_reserve0, IERC20Metadata(_token0).decimals(), 18);\n        _reserve1 = OracleHelpers.scaleDecimal(_reserve1, IERC20Metadata(_token1).decimals(), 18);\n\n        uint256 _token0Price = underlyingOracle.getPriceInUsd(_token0);\n        uint256 _token1Price = underlyingOracle.getPriceInUsd(_token1);\n\n        uint256 _sqrtK = (_reserve0 * _reserve1).sqrt();\n        uint256 _sqrtP0xP1 = (_token0Price * _token1Price).sqrt();\n\n        _priceInUsd = (2 * (_sqrtK * _sqrtP0xP1)) / _pair.totalSupply();\n    }\n}\n"
    },
    "@prb/math/contracts/PRBMath.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\n\n/// @notice Emitted when one of the inputs is type(int256).min.\nerror PRBMath__MulDivSignedInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows int256.\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is MIN_SD59x18.\nerror PRBMathSD59x18__AbsInputTooSmall();\n\n/// @notice Emitted when ceiling a number overflows SD59x18.\nerror PRBMathSD59x18__CeilOverflow(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__DivInputTooSmall();\n\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\n\n/// @notice Emitted when flooring a number underflows SD59x18.\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\n\n/// @notice Emitted when the product of the inputs is negative.\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\n\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\n\n/// @notice Emitted when the input is less than or equal to zero.\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__MulInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is negative.\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\n\n/// @notice Emitted when the calculating the square root overflows SD59x18.\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\n\n/// @notice Emitted when addition overflows UD60x18.\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when ceiling a number overflows UD60x18.\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\n\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when the input is less than 1.\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\n\n/// @notice Emitted when the calculating the square root overflows UD60x18.\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\n\n/// @notice Emitted when subtraction underflows UD60x18.\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\n\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\nlibrary PRBMath {\n    /// STRUCTS ///\n\n    struct SD59x18 {\n        int256 value;\n    }\n\n    struct UD60x18 {\n        uint256 value;\n    }\n\n    /// STORAGE ///\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @dev Largest power of two divisor of SCALE.\n    uint256 internal constant SCALE_LPOTD = 262144;\n\n    /// @dev SCALE inverted mod 2^256.\n    uint256 internal constant SCALE_INVERSE =\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n    /// FUNCTIONS ///\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    /// @dev Has to use 192.64-bit fixed-point numbers.\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // Start from 0.5 in the 192.64-bit fixed-point format.\n            result = 0x800000000000000000000000000000000000000000000000;\n\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n\n            // We're doing two things at the same time:\n            //\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\n            //      rather than 192.\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\n            //\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\n            result *= SCALE;\n            result >>= (191 - (x >> 64));\n        }\n    }\n\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n    /// @param x The uint256 number for which to find the index of the most significant bit.\n    /// @return msb The index of the most significant bit as an uint256.\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\n        if (x >= 2**128) {\n            x >>= 128;\n            msb += 128;\n        }\n        if (x >= 2**64) {\n            x >>= 64;\n            msb += 64;\n        }\n        if (x >= 2**32) {\n            x >>= 32;\n            msb += 32;\n        }\n        if (x >= 2**16) {\n            x >>= 16;\n            msb += 16;\n        }\n        if (x >= 2**8) {\n            x >>= 8;\n            msb += 8;\n        }\n        if (x >= 2**4) {\n            x >>= 4;\n            msb += 4;\n        }\n        if (x >= 2**2) {\n            x >>= 2;\n            msb += 2;\n        }\n        if (x >= 2**1) {\n            // No need to shift x any more.\n            msb += 1;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The multiplicand as an uint256.\n    /// @param y The multiplier as an uint256.\n    /// @param denominator The divisor as an uint256.\n    /// @return result The result as an uint256.\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        if (prod1 >= denominator) {\n            revert PRBMath__MulDivOverflow(prod1, denominator);\n        }\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        unchecked {\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by lpotdod.\n                denominator := div(denominator, lpotdod)\n\n                // Divide [prod1 prod0] by lpotdod.\n                prod0 := div(prod0, lpotdod)\n\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * lpotdod;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷1e18) with full precision.\n    ///\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\n    ///\n    /// Requirements:\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\n    ///     1. x * y = type(uint256).max * SCALE\n    ///     2. (x * y) % SCALE >= SCALE / 2\n    ///\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= SCALE) {\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\n        }\n\n        uint256 remainder;\n        uint256 roundUpUnit;\n        assembly {\n            remainder := mulmod(x, y, SCALE)\n            roundUpUnit := gt(remainder, 499999999999999999)\n        }\n\n        if (prod1 == 0) {\n            unchecked {\n                result = (prod0 / SCALE) + roundUpUnit;\n                return result;\n            }\n        }\n\n        assembly {\n            result := add(\n                mul(\n                    or(\n                        div(sub(prod0, remainder), SCALE_LPOTD),\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\n                    ),\n                    SCALE_INVERSE\n                ),\n                roundUpUnit\n            )\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - None of the inputs can be type(int256).min.\n    /// - The result must fit within int256.\n    ///\n    /// @param x The multiplicand as an int256.\n    /// @param y The multiplier as an int256.\n    /// @param denominator The divisor as an int256.\n    /// @return result The result as an int256.\n    function mulDivSigned(\n        int256 x,\n        int256 y,\n        int256 denominator\n    ) internal pure returns (int256 result) {\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n            revert PRBMath__MulDivSignedInputTooSmall();\n        }\n\n        // Get hold of the absolute values of x, y and the denominator.\n        uint256 ax;\n        uint256 ay;\n        uint256 ad;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n        }\n\n        // Compute the absolute value of (x*y)÷denominator. The result must fit within int256.\n        uint256 rAbs = mulDiv(ax, ay, ad);\n        if (rAbs > uint256(type(int256).max)) {\n            revert PRBMath__MulDivSignedOverflow(rAbs);\n        }\n\n        // Get the signs of x, y and the denominator.\n        uint256 sx;\n        uint256 sy;\n        uint256 sd;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n            sd := sgt(denominator, sub(0, 1))\n        }\n\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\n        // If yes, the result should be negative.\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The uint256 number for which to calculate the square root.\n    /// @return result The result as an uint256.\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        // Set the initial guess to the least power of two that is greater than or equal to sqrt(x).\n        uint256 xAux = uint256(x);\n        result = 1;\n        if (xAux >= 0x100000000000000000000000000000000) {\n            xAux >>= 128;\n            result <<= 64;\n        }\n        if (xAux >= 0x10000000000000000) {\n            xAux >>= 64;\n            result <<= 32;\n        }\n        if (xAux >= 0x100000000) {\n            xAux >>= 32;\n            result <<= 16;\n        }\n        if (xAux >= 0x10000) {\n            xAux >>= 16;\n            result <<= 8;\n        }\n        if (xAux >= 0x100) {\n            xAux >>= 8;\n            result <<= 4;\n        }\n        if (xAux >= 0x10) {\n            xAux >>= 4;\n            result <<= 2;\n        }\n        if (xAux >= 0x8) {\n            result <<= 1;\n        }\n\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\n        unchecked {\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1; // Seven iterations should be enough\n            uint256 roundedDownResult = x / result;\n            return result >= roundedDownResult ? roundedDownResult : result;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/libraries/OracleHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2;\n\nlibrary OracleHelpers {\n    function scaleDecimal(\n        uint256 amount,\n        uint256 _fromDecimal,\n        uint256 _toDecimal\n    ) internal pure returns (uint256) {\n        if (_fromDecimal > _toDecimal) {\n            return amount / (10**(_fromDecimal - _toDecimal));\n        } else if (_fromDecimal < _toDecimal) {\n            return amount * (10**(_toDecimal - _fromDecimal));\n        }\n        return amount;\n    }\n}\n"
    },
    "contracts/core/StableCoinProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../libraries/OracleHelpers.sol\";\nimport \"../interfaces/core/IStableCoinProvider.sol\";\nimport \"../features/UsingStalePeriod.sol\";\nimport \"../features/UsingMaxDeviation.sol\";\n\n/**\n * @title Provide pegged stable coin, useful for getting USD prices reference from DEXes\n * @dev This contract mitigates a de-peg scenario by checking price against two stable coins that should be around 1\n */\ncontract StableCoinProvider is IStableCoinProvider, UsingStalePeriod, UsingMaxDeviation {\n    using OracleHelpers for uint256;\n\n    uint256 public constant USD_DECIMALS = 18;\n    uint256 public constant ONE_USD = 10**USD_DECIMALS;\n\n    /**\n     * @notice A stable coin to use as USD price reference\n     * @dev Should not be called directly from other contracts, must use `getStableCoinIfPegged`\n     */\n    address public primaryStableCoin;\n    uint8 private __primaryStableCoinDecimals;\n\n    /**\n     * @notice A secondary stable coin used to check USD-peg against primary\n     * @dev Should not be called directly from other contracts, must use `getStableCoinIfPegged`\n     */\n    address public secondaryStableCoin;\n    uint8 private __secondaryStableCoinDecimals;\n\n    /// @notice Emitted when stable coin is updated\n    event StableCoinsUpdated(\n        address oldPrimaryStableCoin,\n        address oldSecondaryStableCoin,\n        address newPrimaryStableCoin,\n        address newSecondaryStableCoin\n    );\n\n    constructor(\n        address primaryStableCoin_,\n        address secondaryStableCoin_,\n        uint256 stalePeriod_,\n        uint256 maxDeviation_\n    ) UsingStalePeriod(stalePeriod_) UsingMaxDeviation(maxDeviation_) {\n        _updateStableCoins(primaryStableCoin_, secondaryStableCoin_);\n    }\n\n    /// @inheritdoc IStableCoinProvider\n    function getStableCoinIfPegged() external view returns (address _stableCoin) {\n        // Note: Chainlink supports DAI/USDC/USDT on all chains that we're using\n        IPriceProvider _chainlink = addressProvider.providersAggregator().priceProviders(DataTypes.Provider.CHAINLINK);\n\n        (uint256 _priceInUsd, uint256 _lastUpdatedAt) = _chainlink.getPriceInUsd(primaryStableCoin);\n\n        if (!_priceIsStale(_lastUpdatedAt) && _isDeviationOK(_priceInUsd, ONE_USD)) {\n            return primaryStableCoin;\n        }\n\n        (_priceInUsd, _lastUpdatedAt) = _chainlink.getPriceInUsd(secondaryStableCoin);\n\n        require(!_priceIsStale(_lastUpdatedAt) && _isDeviationOK(_priceInUsd, ONE_USD), \"stable-prices-invalid\");\n\n        return secondaryStableCoin;\n    }\n\n    /// @inheritdoc IStableCoinProvider\n    function toUsdRepresentation(uint256 stableCoinAmount_) external view returns (uint256 _usdAmount) {\n        uint256 _stableCoinDecimals = __primaryStableCoinDecimals;\n        if (_stableCoinDecimals == USD_DECIMALS) {\n            return stableCoinAmount_;\n        }\n        _usdAmount = stableCoinAmount_.scaleDecimal(_stableCoinDecimals, USD_DECIMALS);\n    }\n\n    /**\n     * @notice Update the stable coin keeping correct decimals value\n     * @dev Must have both as set or null\n     */\n    function _updateStableCoins(address primaryStableCoin_, address secondaryStableCoin_) private {\n        require(primaryStableCoin_ != address(0) && secondaryStableCoin_ != address(0), \"stable-coins-are-null\");\n        require(primaryStableCoin_ != secondaryStableCoin_, \"stable-coins-are-the-same\");\n\n        // Update both\n        primaryStableCoin = primaryStableCoin_;\n        secondaryStableCoin = secondaryStableCoin_;\n        __primaryStableCoinDecimals = IERC20Metadata(primaryStableCoin_).decimals();\n        __secondaryStableCoinDecimals = IERC20Metadata(secondaryStableCoin_).decimals();\n    }\n\n    /**\n     * @notice Update stable coin\n     * @dev Used externally by the governor\n     */\n    function updateStableCoins(address primaryStableCoin_, address secondaryStableCoin_) external onlyGovernor {\n        emit StableCoinsUpdated(primaryStableCoin, secondaryStableCoin, primaryStableCoin_, secondaryStableCoin_);\n        _updateStableCoins(primaryStableCoin_, secondaryStableCoin_);\n    }\n}\n"
    },
    "contracts/features/UsingStalePeriod.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../access/Governable.sol\";\n\n/**\n * @title Stale price check feature, useful when checking if prices are fresh enough\n */\nabstract contract UsingStalePeriod is Governable {\n    /// @notice The stale period. It's used to determine if a price is invalid (i.e. outdated)\n    uint256 public stalePeriod;\n\n    /// @notice Emitted when stale period is updated\n    event StalePeriodUpdated(uint256 oldStalePeriod, uint256 newStalePeriod);\n\n    constructor(uint256 stalePeriod_) {\n        stalePeriod = stalePeriod_;\n    }\n\n    /**\n     * @notice Update stale period\n     */\n    function updateStalePeriod(uint256 stalePeriod_) external onlyGovernor {\n        emit StalePeriodUpdated(stalePeriod, stalePeriod_);\n        stalePeriod = stalePeriod_;\n    }\n\n    /**\n     * @notice Check if a price timestamp is outdated\n     * @dev Uses default stale period\n     * @param timeOfLastUpdate_ The price timestamp\n     * @return true if price is stale (outdated)\n     */\n    function _priceIsStale(uint256 timeOfLastUpdate_) internal view returns (bool) {\n        return _priceIsStale(timeOfLastUpdate_, stalePeriod);\n    }\n\n    /**\n     * @notice Check if a price timestamp is outdated\n     * @param timeOfLastUpdate_ The price timestamp\n     * @param stalePeriod_ The maximum acceptable outdated period\n     * @return true if price is stale (outdated)\n     */\n    function _priceIsStale(uint256 timeOfLastUpdate_, uint256 stalePeriod_) internal view returns (bool) {\n        return block.timestamp - timeOfLastUpdate_ > stalePeriod_;\n    }\n}\n"
    },
    "contracts/features/UsingMaxDeviation.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../access/Governable.sol\";\n\n/**\n * @title Deviation check feature, useful when checking prices from different providers for the same asset\n */\nabstract contract UsingMaxDeviation is Governable {\n    /**\n     * @notice The max acceptable deviation\n     * @dev 18-decimals scale (e.g 1e17 = 10%)\n     */\n    uint256 public maxDeviation;\n\n    /// @notice Emitted when max deviation is updated\n    event MaxDeviationUpdated(uint256 oldMaxDeviation, uint256 newMaxDeviation);\n\n    constructor(uint256 maxDeviation_) {\n        maxDeviation = maxDeviation_;\n    }\n\n    /**\n     * @notice Update max deviation\n     */\n    function updateMaxDeviation(uint256 maxDeviation_) external onlyGovernor {\n        emit MaxDeviationUpdated(maxDeviation, maxDeviation_);\n        maxDeviation = maxDeviation_;\n    }\n\n    /**\n     * @notice Check if two numbers deviation is acceptable\n     */\n    function _isDeviationOK(uint256 a_, uint256 b_) internal view returns (bool) {\n        uint256 _deviation = a_ > b_ ? ((a_ - b_) * 1e18) / a_ : ((b_ - a_) * 1e18) / b_;\n        return _deviation <= maxDeviation;\n    }\n}\n"
    },
    "contracts/periphery/tokens/VspMainnetOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../../features/UsingMaxDeviation.sol\";\nimport \"../../features/UsingStalePeriod.sol\";\nimport \"../../interfaces/periphery/IUpdatableOracle.sol\";\nimport \"../../interfaces/core/IUniswapV2LikePriceProvider.sol\";\n\n/**\n * @title VSP oracle (mainnet)\n */\ncontract VspMainnetOracle is IUpdatableOracle, UsingMaxDeviation, UsingStalePeriod {\n    uint256 public constant ONE_VSP = 1e18;\n    address public constant VSP_ADDRESS = 0x1b40183EFB4Dd766f11bDa7A7c3AD8982e998421;\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    constructor(uint256 maxDeviation_, uint256 stalePeriod_)\n        UsingMaxDeviation(maxDeviation_)\n        UsingStalePeriod(stalePeriod_)\n    {}\n\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address _asset) external view returns (uint256 _priceInUsd) {\n        require(address(_asset) == VSP_ADDRESS, \"invalid-token\");\n        uint256 _lastUpdatedAt;\n        IPriceProvidersAggregator _aggregator = addressProvider.providersAggregator();\n\n        (_priceInUsd, _lastUpdatedAt) = _aggregator.quoteTokenToUsd(\n            DataTypes.Provider.UNISWAP_V2,\n            VSP_ADDRESS,\n            ONE_VSP\n        );\n        (uint256 _priceInUsd1, uint256 _lastUpdatedAt1) = _aggregator.quoteTokenToUsd(\n            DataTypes.Provider.SUSHISWAP,\n            VSP_ADDRESS,\n            ONE_VSP\n        );\n\n        require(\n            _priceInUsd > 0 && _priceInUsd1 > 0 && !_priceIsStale(Math.min(_lastUpdatedAt, _lastUpdatedAt1)),\n            \"one-or-both-prices-invalid\"\n        );\n        require(_isDeviationOK(_priceInUsd, _priceInUsd1), \"prices-deviation-too-high\");\n    }\n\n    /// @inheritdoc IUpdatableOracle\n    function update() external override {\n        IAddressProvider _addressProvider = addressProvider;\n        IPriceProvidersAggregator _aggregator = _addressProvider.providersAggregator();\n        address _stableCoin = _addressProvider.stableCoinProvider().getStableCoinIfPegged();\n\n        IUniswapV2LikePriceProvider _uniswapV2PriceProvider = IUniswapV2LikePriceProvider(\n            address(_aggregator.priceProviders(DataTypes.Provider.UNISWAP_V2))\n        );\n        IUniswapV2LikePriceProvider _sushiswapPriceProvider = IUniswapV2LikePriceProvider(\n            address(_aggregator.priceProviders(DataTypes.Provider.SUSHISWAP))\n        );\n\n        _uniswapV2PriceProvider.updateOrAdd(VSP_ADDRESS, WETH_ADDRESS);\n        _uniswapV2PriceProvider.updateOrAdd(WETH_ADDRESS, _stableCoin);\n        _sushiswapPriceProvider.updateOrAdd(VSP_ADDRESS, WETH_ADDRESS);\n        _sushiswapPriceProvider.updateOrAdd(WETH_ADDRESS, _stableCoin);\n    }\n}\n"
    },
    "contracts/interfaces/periphery/IUpdatableOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./ITokenOracle.sol\";\n\ninterface IUpdatableOracle is ITokenOracle {\n    /**\n     * @notice Update underlying price providers (i.e. UniswapV2-Like)\n     */\n    function update() external;\n}\n"
    },
    "contracts/interfaces/core/IUniswapV2LikePriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"./IPriceProvider.sol\";\n\ninterface IUniswapV2LikePriceProvider is IPriceProvider {\n    /**\n     * @notice The default time-weighted average price (TWAP) period\n     * Used when a period isn't specified\n     * @dev See more: https://docs.uniswap.org/protocol/concepts/V3-overview/oracle\n     */\n    function defaultTwapPeriod() external view returns (uint256);\n\n    /**\n     * @notice Check if there is an oracle for the PAIR-TWAP key\n     * @param pair_ The pair\n     * @param twapPeriod_ The TWAP period\n     * @return True if exists\n     */\n    function hasOracle(IUniswapV2Pair pair_, uint256 twapPeriod_) external view returns (bool);\n\n    /**\n     * @notice Check if there is an oracle for the PAIR-TWAP key\n     * @dev Uses `defaultTwapPeriod`\n     * @param pair_ The pair\n     * @return True if exists\n     */\n    function hasOracle(IUniswapV2Pair pair_) external view returns (bool);\n\n    /**\n     * @notice Returns the pair's contract\n     */\n    function pairFor(address token0_, address token1_) external view returns (IUniswapV2Pair _pair);\n\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of assetIn\n     * @param twapPeriod_ The TWAP period\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(address token_, uint256 twapPeriod_)\n        external\n        view\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param twapPeriod_ The TWAP period\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_,\n        uint256 amountIn_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @param twapPeriod_ The TWAP period\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint256 twapPeriod_\n    ) external view returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetIn\n     * @param amountIn_ Input amount in USD\n     * @param twapPeriod_ The TWAP period\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint256 twapPeriod_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @dev Will update the oracle if needed before getting quote\n     * @dev Uses `defaultTwapPeriod`\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function updateAndQuote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @dev Will update the oracle if needed before getting quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param twapPeriod_ The TWAP period\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function updateAndQuote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_,\n        uint256 amountIn_\n    ) external returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Update the default TWAP period\n     * @dev Administrative function\n     * @param newDefaultTwapPeriod_ The new default period\n     */\n    function updateDefaultTwapPeriod(uint256 newDefaultTwapPeriod_) external;\n\n    /**\n     * @notice Update cumulative and average price of pair\n     * @dev Will create the pair if it doesn't exist\n     * @dev Uses `defaultTwapPeriod`\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     */\n    function updateOrAdd(address tokenIn_, address tokenOut_) external;\n\n    /**\n     * @notice Update cumulative and average price of pair\n     * @dev Will create the pair if it doesn't exist\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param twapPeriod_ The TWAP period\n     */\n    function updateOrAdd(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_\n    ) external;\n}\n"
    },
    "contracts/periphery/tokens/AlusdTokenMainnetOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../../features/UsingMaxDeviation.sol\";\nimport \"../../features/UsingStalePeriod.sol\";\nimport \"../../interfaces/periphery/IUpdatableOracle.sol\";\nimport \"../../interfaces/core/IUniswapV2LikePriceProvider.sol\";\n\n/**\n * @title alUSD Oracle (mainnet-only)\n */\ncontract AlusdTokenMainnetOracle is IUpdatableOracle, UsingStalePeriod {\n    uint256 public constant ONE_ALUSD = 1e18;\n    address public constant ALUSD_ADDRESS = 0xBC6DA0FE9aD5f3b0d58160288917AA56653660E9;\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    constructor(uint256 stalePeriod_) UsingStalePeriod(stalePeriod_) {}\n\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address _asset) external view returns (uint256 _priceInUsd) {\n        require(address(_asset) == ALUSD_ADDRESS, \"invalid-token\");\n\n        uint256 _lastUpdatedAt;\n        (_priceInUsd, _lastUpdatedAt) = addressProvider.providersAggregator().quoteTokenToUsd(\n            DataTypes.Provider.SUSHISWAP,\n            ALUSD_ADDRESS,\n            ONE_ALUSD\n        );\n\n        require(_priceInUsd > 0 && !_priceIsStale(_lastUpdatedAt), \"price-invalid\");\n    }\n\n    /// @inheritdoc IUpdatableOracle\n    function update() external override {\n        IAddressProvider _addressProvider = addressProvider;\n        IUniswapV2LikePriceProvider _sushiswap = IUniswapV2LikePriceProvider(\n            address(_addressProvider.providersAggregator().priceProviders(DataTypes.Provider.SUSHISWAP))\n        );\n        _sushiswap.updateOrAdd(ALUSD_ADDRESS, WETH_ADDRESS);\n        _sushiswap.updateOrAdd(WETH_ADDRESS, _addressProvider.stableCoinProvider().getStableCoinIfPegged());\n    }\n}\n"
    },
    "contracts/periphery/tokens/BTCPeggedTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\nimport \"../../features/UsingStalePeriod.sol\";\n\n/**\n * @title Oracle for BTC-pegged tokens that uses Chainlink's BTC/USD feed\n */\ncontract BTCPeggedTokenOracle is ITokenOracle, UsingStalePeriod {\n    using SafeCast for int256;\n\n    /// @notice Chainlink BTC/USD aggregator\n    AggregatorV3Interface public immutable btcAggregator;\n\n    constructor(AggregatorV3Interface btcAggregator_, uint256 stalePeriod_) UsingStalePeriod(stalePeriod_) {\n        btcAggregator = btcAggregator_;\n    }\n\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address) external view override returns (uint256 _priceInUsd) {\n        (, int256 _price, , uint256 _lastUpdatedAt, ) = btcAggregator.latestRoundData();\n        require(!_priceIsStale(_lastUpdatedAt), \"stale-price\");\n        return _price.toUint256() * 1e10; // To 18 decimals\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/core/UniswapV3PriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../access/Governable.sol\";\nimport \"../interfaces/utils/IUniswapV3CrossPoolOracle.sol\";\nimport \"../interfaces/core/IUniswapV3PriceProvider.sol\";\nimport \"./PriceProvider.sol\";\n\ncontract UniswapV3PriceProvider is IUniswapV3PriceProvider, Governable, PriceProvider {\n    /**\n     * @notice The UniswapV3CrossPoolOracle contract\n     * @dev This contract encapsulates UniswapV3 oracle logic\n     */\n    IUniswapV3CrossPoolOracle public immutable crossPoolOracle;\n\n    /**\n     * @notice The time-weighted average price (TWAP) period\n     * @dev See more: https://docs.uniswap.org/protocol/concepts/V3-overview/oracle\n     */\n    uint32 public override defaultTwapPeriod;\n\n    /**\n     * @notice The default pool fee to use\n     * @dev Use 1e6 for 100% (e.g 3000 is 0.3%)\n     */\n    uint24 public defaultPoolFee;\n\n    /// @notice Emitted when the default TWAP period is updated\n    event DefaultTwapPeriodUpdated(uint32 oldDefaultTwapPeriod, uint32 newDefaultTwapPeriod);\n\n    /// @notice Emitted when the default pool fee updated\n    event DefaultPoolFeeUpdated(uint24 oldDefaultPoolFee, uint24 newDefaultPoolFee);\n\n    constructor(\n        IUniswapV3CrossPoolOracle crossPoolOracle_,\n        uint32 defaultTwapPeriod_,\n        uint24 defaultFee_\n    ) {\n        require(address(crossPoolOracle_) != address(0), \"cross-pool-is-null\");\n        crossPoolOracle = crossPoolOracle_;\n        defaultTwapPeriod = defaultTwapPeriod_;\n        defaultPoolFee = defaultFee_;\n    }\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(address token_)\n        public\n        view\n        override(IPriceProvider, PriceProvider)\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        return getPriceInUsd(token_, defaultPoolFee, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function getPriceInUsd(address token_, uint32 twapPeriod_)\n        public\n        view\n        override\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        return getPriceInUsd(token_, defaultPoolFee, twapPeriod_);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function getPriceInUsd(address token_, uint24 poolFee_)\n        public\n        view\n        override\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        return getPriceInUsd(token_, poolFee_, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function getPriceInUsd(\n        address token_,\n        uint24 poolFee_,\n        uint32 twapPeriod_\n    ) public view override returns (uint256 _priceInUsd, uint256 _lastUpdatedAt) {\n        IStableCoinProvider _stableCoinProvider = addressProvider.stableCoinProvider();\n        require(address(_stableCoinProvider) != address(0), \"stable-coin-not-supported\");\n\n        uint256 _stableCoinAmount;\n        (_stableCoinAmount, _lastUpdatedAt) = quote(\n            token_,\n            _stableCoinProvider.getStableCoinIfPegged(),\n            poolFee_,\n            twapPeriod_,\n            10**IERC20Metadata(token_).decimals() // ONE\n        );\n\n        _priceInUsd = _stableCoinProvider.toUsdRepresentation(_stableCoinAmount);\n    }\n\n    /// @inheritdoc IPriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external view override(IPriceProvider, PriceProvider) returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        return quote(tokenIn_, tokenOut_, defaultPoolFee, defaultTwapPeriod, amountIn_);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint32 twapPeriod_,\n        uint256 amountIn_\n    ) external view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        return quote(tokenIn_, tokenOut_, defaultPoolFee, twapPeriod_, amountIn_);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint24 poolFee_,\n        uint256 amountIn_\n    ) external view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        return quote(tokenIn_, tokenOut_, poolFee_, defaultTwapPeriod, amountIn_);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint24 poolFee_,\n        uint32 twapPeriod_,\n        uint256 amountIn_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        if (tokenIn_ == tokenOut_) {\n            return (amountIn_, block.timestamp);\n        }\n\n        if (tokenIn_ == crossPoolOracle.nativeToken()) {\n            _amountOut = crossPoolOracle.ethToAsset(amountIn_, tokenOut_, poolFee_, twapPeriod_);\n        } else if (tokenOut_ == crossPoolOracle.nativeToken()) {\n            _amountOut = crossPoolOracle.assetToEth(tokenIn_, amountIn_, poolFee_, twapPeriod_);\n        } else {\n            _amountOut = crossPoolOracle.assetToAsset(tokenIn_, amountIn_, tokenOut_, poolFee_, twapPeriod_);\n        }\n        _lastUpdatedAt = block.timestamp;\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        return quoteTokenToUsd(token_, amountIn_, poolFee_, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint32 twapPeriod_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        return quoteTokenToUsd(token_, amountIn_, defaultPoolFee, twapPeriod_);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_,\n        uint32 twapPeriod_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        uint256 _price;\n        (_price, _lastUpdatedAt) = getPriceInUsd(token_, poolFee_, twapPeriod_);\n        _amountOut = (amountIn_ * _price) / 10**IERC20Metadata(token_).decimals();\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        return quoteUsdToToken(token_, amountIn_, poolFee_, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint32 twapPeriod_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        return quoteUsdToToken(token_, amountIn_, defaultPoolFee, twapPeriod_);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_,\n        uint32 twapPeriod_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        uint256 _price;\n        (_price, _lastUpdatedAt) = getPriceInUsd(token_, poolFee_, twapPeriod_);\n        _amountOut = (amountIn_ * 10**IERC20Metadata(token_).decimals()) / _price;\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function updateDefaultTwapPeriod(uint32 newDefaultTwapPeriod_) external onlyGovernor {\n        emit DefaultTwapPeriodUpdated(defaultTwapPeriod, newDefaultTwapPeriod_);\n        defaultTwapPeriod = newDefaultTwapPeriod_;\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function updateDefaultPoolFee(uint24 newDefaultPoolFee_) external onlyGovernor {\n        emit DefaultPoolFeeUpdated(defaultPoolFee, newDefaultPoolFee_);\n        defaultPoolFee = newDefaultPoolFee_;\n    }\n}\n"
    },
    "contracts/interfaces/utils/IUniswapV3CrossPoolOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/**\n * @title UniswapV3 oracle with ability to query across an intermediate liquidity pool\n */\ninterface IUniswapV3CrossPoolOracle {\n    function nativeToken() external view returns (address);\n\n    function assetToEth(\n        address _tokenIn,\n        uint256 _amountIn,\n        uint24 _fee,\n        uint32 _twapPeriod\n    ) external view returns (uint256 ethAmountOut);\n\n    function ethToAsset(\n        uint256 _ethAmountIn,\n        address _tokenOut,\n        uint24 _fee,\n        uint32 _twapPeriod\n    ) external view returns (uint256 amountOut);\n\n    function assetToAsset(\n        address _tokenIn,\n        uint256 _amountIn,\n        address _tokenOut,\n        uint24 _fee,\n        uint32 _twapPeriod\n    ) external view returns (uint256 amountOut);\n\n    function assetToAssetThruRoute(\n        address _tokenIn,\n        uint256 _amountIn,\n        address _tokenOut,\n        uint32 _twapPeriod,\n        address _routeThruToken,\n        uint24[2] memory _poolFees\n    ) external view returns (uint256 amountOut);\n}\n"
    },
    "contracts/interfaces/core/IUniswapV3PriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./IPriceProvider.sol\";\n\ninterface IUniswapV3PriceProvider is IPriceProvider {\n    /**\n     * @notice The default time-weighted average price (TWAP) period\n     * Used when a period isn't specified\n     * @dev See more: https://docs.uniswap.org/protocol/concepts/V3-overview/oracle\n     */\n    function defaultTwapPeriod() external view returns (uint32);\n\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of assetIn\n     * @param poolFee_ The pools' fees\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(address token_, uint24 poolFee_)\n        external\n        view\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of assetIn\n     * @param twapPeriod_ The TWAP period\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(address token_, uint32 twapPeriod_)\n        external\n        view\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of assetIn\n     * @param poolFee_ The pools' fees\n     * @param twapPeriod_ The TWAP period\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(\n        address token_,\n        uint24 poolFee_,\n        uint32 twapPeriod_\n    ) external view returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param twapPeriod_ The TWAP period\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint32 twapPeriod_,\n        uint256 amountIn_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param poolFee_ The pools' fees\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint24 poolFee_,\n        uint256 amountIn_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param poolFee_ The pools' fees\n     * @param twapPeriod_ The TWAP period\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint24 poolFee_,\n        uint32 twapPeriod_,\n        uint256 amountIn_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @param poolFee_ The pools' fees\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_\n    ) external view returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @param twapPeriod_ The TWAP period\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint32 twapPeriod_\n    ) external view returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @param poolFee_ The pools' fees\n     * @param twapPeriod_ The TWAP period\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_,\n        uint32 twapPeriod_\n    ) external view returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetIn\n     * @param amountIn_ Input amount in USD\n     * @param poolFee_ The TWAP period\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetIn\n     * @param amountIn_ Input amount in USD\n     * @param twapPeriod_ The TWAP period\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint32 twapPeriod_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetIn\n     * @param amountIn_ Input amount in USD\n     * @param poolFee_ The TWAP period\n     * @param twapPeriod_ The TWAP period\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_,\n        uint32 twapPeriod_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Update the default TWAP period\n     * @dev Administrative function\n     * @param newDefaultTwapPeriod_ The new default period\n     */\n    function updateDefaultTwapPeriod(uint32 newDefaultTwapPeriod_) external;\n\n    /**\n     * @notice Update the default pool fee\n     * @dev Administrative function\n     * @param newDefaultPoolFee_ The new default period\n     */\n    function updateDefaultPoolFee(uint24 newDefaultPoolFee_) external;\n}\n"
    },
    "contracts/core/PriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../interfaces/core/IPriceProvider.sol\";\n\n/**\n * @title Price providers' super class that implements common functions\n */\nabstract contract PriceProvider is IPriceProvider {\n    uint256 public constant USD_DECIMALS = 18;\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(address token_) public view virtual returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /// @inheritdoc IPriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external view virtual override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        (uint256 _amountInUsd, uint256 _lastUpdatedAt0) = quoteTokenToUsd(tokenIn_, amountIn_);\n        (_amountOut, _lastUpdatedAt) = quoteUsdToToken(tokenOut_, _amountInUsd);\n        _lastUpdatedAt = Math.min(_lastUpdatedAt0, _lastUpdatedAt);\n    }\n\n    /// @inheritdoc IPriceProvider\n    function quoteTokenToUsd(address token_, uint256 amountIn_)\n        public\n        view\n        override\n        returns (uint256 _amountOut, uint256 _lastUpdatedAt)\n    {\n        uint256 _price;\n        (_price, _lastUpdatedAt) = getPriceInUsd(token_);\n        _amountOut = (amountIn_ * _price) / 10**IERC20Metadata(token_).decimals();\n    }\n\n    /// @inheritdoc IPriceProvider\n    function quoteUsdToToken(address token_, uint256 amountIn_)\n        public\n        view\n        override\n        returns (uint256 _amountOut, uint256 _lastUpdatedAt)\n    {\n        uint256 _price;\n        (_price, _lastUpdatedAt) = getPriceInUsd(token_);\n        _amountOut = (amountIn_ * 10**IERC20Metadata(token_).decimals()) / _price;\n    }\n}\n"
    },
    "contracts/mock/PriceProviderMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../core/PriceProvider.sol\";\n\ncontract PriceProviderMock is PriceProvider {\n    mapping(address => uint256) public priceInUsd;\n\n    function setPriceInUsd(address token_, uint256 priceInUsd_) public {\n        priceInUsd[token_] = priceInUsd_;\n    }\n\n    function getPriceInUsd(address token_) public view override returns (uint256 _priceInUsd, uint256 _lastUpdatedAt) {\n        _priceInUsd = priceInUsd[token_];\n        _lastUpdatedAt = block.timestamp;\n    }\n\n    function checkGasOfQuote(\n        IPriceProvider _pp,\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) public returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        return _pp.quote(tokenIn_, tokenOut_, amountIn_);\n    }\n}\n"
    },
    "contracts/core/UniswapV2LikePriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@uniswap/lib/contracts/libraries/FixedPoint.sol\";\nimport \"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"../access/Governable.sol\";\nimport \"../interfaces/core/IUniswapV2LikePriceProvider.sol\";\nimport \"./PriceProvider.sol\";\n\n/**\n * @title UniswapV2 (and forks) TWAP Oracle implementation\n * Based on https://github.com/Uniswap/v2-periphery/blob/master/contracts/examples/ExampleOracleSimple.sol\n */\ncontract UniswapV2LikePriceProvider is IUniswapV2LikePriceProvider, Governable, PriceProvider {\n    using FixedPoint for *;\n\n    /**\n     * @notice The UniswapV2-like factory's address\n     */\n    address public immutable factory;\n\n    /**\n     * @notice The native wrapped token (e.g. WETH, WAVAX, WMATIC, etc)\n     */\n    address public immutable nativeToken;\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    uint256 public override defaultTwapPeriod;\n\n    struct Oracle {\n        address token0;\n        address token1;\n        uint256 price0CumulativeLast;\n        uint256 price1CumulativeLast;\n        uint32 blockTimestampLast;\n        FixedPoint.uq112x112 price0Average;\n        FixedPoint.uq112x112 price1Average;\n    }\n\n    /**\n     * @notice Oracles'\n     * @dev pair => twapPeriod => oracle\n     */\n    mapping(IUniswapV2Pair => mapping(uint256 => Oracle)) public oracles;\n\n    /// @notice Emitted when default TWAP period is updated\n    event DefaultTwapPeriodUpdated(uint256 oldTwapPeriod, uint256 newTwapPeriod);\n\n    constructor(\n        address factory_,\n        uint256 defaultTwapPeriod_,\n        address nativeToken_\n    ) {\n        require(factory_ != address(0), \"factory-is-null\");\n        defaultTwapPeriod = defaultTwapPeriod_;\n        factory = factory_;\n        nativeToken = nativeToken_;\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function hasOracle(IUniswapV2Pair pair_) external view override returns (bool) {\n        return hasOracle(pair_, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function hasOracle(IUniswapV2Pair pair_, uint256 twapPeriod_) public view override returns (bool) {\n        return oracles[pair_][twapPeriod_].blockTimestampLast > 0;\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function pairFor(address token0_, address token1_) public view override returns (IUniswapV2Pair _pair) {\n        _pair = IUniswapV2Pair(IUniswapV2Factory(factory).getPair(token0_, token1_));\n    }\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(address token_)\n        public\n        view\n        override(IPriceProvider, PriceProvider)\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        return getPriceInUsd(token_, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function getPriceInUsd(address token_, uint256 twapPeriod_)\n        public\n        view\n        override\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        IStableCoinProvider _stableCoinProvider = addressProvider.stableCoinProvider();\n        require(address(_stableCoinProvider) != address(0), \"stable-coin-not-supported\");\n\n        uint256 _stableCoinAmount;\n        (_stableCoinAmount, _lastUpdatedAt) = quote(\n            token_,\n            _stableCoinProvider.getStableCoinIfPegged(),\n            twapPeriod_,\n            10**IERC20Metadata(token_).decimals() // ONE\n        );\n        _priceInUsd = _stableCoinProvider.toUsdRepresentation(_stableCoinAmount);\n    }\n\n    /// @inheritdoc IPriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external view override(IPriceProvider, PriceProvider) returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        return quote(tokenIn_, tokenOut_, defaultTwapPeriod, amountIn_);\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_,\n        uint256 amountIn_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        if (tokenIn_ == tokenOut_) {\n            return (amountIn_, block.timestamp);\n        }\n\n        if (hasOracle(pairFor(tokenIn_, tokenOut_), twapPeriod_)) {\n            (_amountOut, _lastUpdatedAt) = _getAmountOut(tokenIn_, tokenOut_, twapPeriod_, amountIn_);\n        } else {\n            (_amountOut, _lastUpdatedAt) = _getAmountOut(tokenIn_, nativeToken, twapPeriod_, amountIn_);\n            uint256 __lastUpdatedAt;\n            (_amountOut, __lastUpdatedAt) = _getAmountOut(nativeToken, tokenOut_, twapPeriod_, _amountOut);\n            _lastUpdatedAt = Math.min(__lastUpdatedAt, _lastUpdatedAt);\n        }\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint256 twapPeriod_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        uint256 _price;\n        (_price, _lastUpdatedAt) = getPriceInUsd(token_, twapPeriod_);\n        _amountOut = (amountIn_ * _price) / 10**IERC20Metadata(token_).decimals();\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint256 twapPeriod_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        uint256 _price;\n        (_price, _lastUpdatedAt) = getPriceInUsd(token_, twapPeriod_);\n        _amountOut = (amountIn_ * 10**IERC20Metadata(token_).decimals()) / _price;\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function updateAndQuote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        return updateAndQuote(tokenIn_, tokenOut_, defaultTwapPeriod, amountIn_);\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function updateAndQuote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_,\n        uint256 amountIn_\n    ) public override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        updateOrAdd(tokenIn_, tokenOut_, twapPeriod_);\n        return quote(tokenIn_, tokenOut_, twapPeriod_, amountIn_);\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function updateOrAdd(address tokenIn_, address tokenOut_) external override {\n        updateOrAdd(tokenIn_, tokenOut_, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function updateOrAdd(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_\n    ) public override {\n        IUniswapV2Pair _pair = pairFor(tokenIn_, tokenOut_);\n        if (!hasOracle(_pair, twapPeriod_)) {\n            _addOracleFor(_pair, twapPeriod_);\n        }\n        _updateIfNeeded(_pair, twapPeriod_);\n    }\n\n    /**\n     * @notice Create new oracle\n     * @param pair_ The pair to get prices from\n     * @param twapPeriod_ The TWAP period\n     */\n    function _addOracleFor(IUniswapV2Pair pair_, uint256 twapPeriod_) private {\n        require(address(pair_) != address(0), \"invalid-pair\");\n\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = pair_.getReserves();\n\n        require(_reserve0 != 0 && _reserve1 != 0, \"no-reserves\");\n\n        oracles[pair_][twapPeriod_] = Oracle({\n            token0: pair_.token0(),\n            token1: pair_.token1(),\n            price0CumulativeLast: pair_.price0CumulativeLast(),\n            price1CumulativeLast: pair_.price1CumulativeLast(),\n            blockTimestampLast: _blockTimestampLast,\n            price0Average: uint112(0).encode(),\n            price1Average: uint112(0).encode()\n        });\n    }\n\n    /**\n     * @notice Get the output amount for a given oracle\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param twapPeriod_ The TWAP period\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function _getAmountOut(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_,\n        uint256 amountIn_\n    ) private view returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        Oracle memory _oracle = oracles[pairFor(tokenIn_, tokenOut_)][twapPeriod_];\n        if (tokenIn_ == _oracle.token0) {\n            _amountOut = _oracle.price0Average.mul(amountIn_).decode144();\n        } else {\n            _amountOut = _oracle.price1Average.mul(amountIn_).decode144();\n        }\n        _lastUpdatedAt = _oracle.blockTimestampLast;\n    }\n\n    /**\n     * @notice Update an oracle\n     * @param pair_ The pair to update\n     * @param twapPeriod_ The TWAP period\n     * @return True if updated was performed\n     */\n    function _updateIfNeeded(IUniswapV2Pair pair_, uint256 twapPeriod_) private returns (bool) {\n        Oracle storage _oracle = oracles[pair_][twapPeriod_];\n\n        (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) = UniswapV2OracleLibrary\n            .currentCumulativePrices(address(pair_));\n        uint32 timeElapsed;\n        unchecked {\n            timeElapsed = blockTimestamp - _oracle.blockTimestampLast; // overflow is desired\n        }\n        // ensure that at least one full period has passed since the last update\n        if (timeElapsed < twapPeriod_) return false;\n\n        uint256 price0new;\n        uint256 price1new;\n\n        unchecked {\n            price0new = price0Cumulative - _oracle.price0CumulativeLast;\n            price1new = price1Cumulative - _oracle.price1CumulativeLast;\n        }\n\n        // overflow is desired, casting never truncates\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\n        _oracle.price0Average = FixedPoint.uq112x112(uint224(price0new / timeElapsed));\n        _oracle.price1Average = FixedPoint.uq112x112(uint224(price1new / timeElapsed));\n        _oracle.price0CumulativeLast = price0Cumulative;\n        _oracle.price1CumulativeLast = price1Cumulative;\n        _oracle.blockTimestampLast = blockTimestamp;\n        return true;\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function updateDefaultTwapPeriod(uint256 newDefaultTwapPeriod_) external override onlyGovernor {\n        emit DefaultTwapPeriodUpdated(defaultTwapPeriod, newDefaultTwapPeriod_);\n        defaultTwapPeriod = newDefaultTwapPeriod_;\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\nimport './Babylonian.sol';\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n    uint private constant Q112 = uint(1) << RESOLUTION;\n    uint private constant Q224 = Q112 << RESOLUTION;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\n        return uq112x112(self._x / uint224(x));\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\n        uint z;\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\n        return uq144x112(z);\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // equivalent to encode(numerator).div(denominator)\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n\n    // take the reciprocal of a UQ112x112\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        require(self._x != 0, 'FixedPoint: ZERO_RECIPROCAL');\n        return uq112x112(uint224(Q224 / self._x));\n    }\n\n    // square root of a UQ112x112\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x)) << 56));\n    }\n}\n"
    },
    "@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol": {
      "content": "pragma solidity >=0.5.0;\n\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport '@uniswap/lib/contracts/libraries/FixedPoint.sol';\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n    using FixedPoint for *;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2 ** 32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(\n        address pair\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n            // counterfactual\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n        }\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n        // else z = 0\n    }\n}\n"
    },
    "contracts/periphery/MasterOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../interfaces/periphery/IOracle.sol\";\nimport \"../access/Governable.sol\";\n\n/**\n * @title MasterOracle\n */\ncontract MasterOracle is IOracle, Governable {\n    /**\n     * @notice Default oracle to use when token hasn't custom oracle\n     */\n    IOracle public defaultOracle;\n\n    /**\n     * @notice Custom tokens' oracles\n     * @dev Useful when dealing with special tokens (e.g. LP, IB, etc)\n     */\n    mapping(address => IOracle) public oracles;\n\n    /// @notice Emitted when a token's oracle is set\n    event TokenOracleUpdated(address indexed token, IOracle indexed oracle);\n\n    /// @notice Emitted when the default oracle is updated\n    event DefaultOracleUpdated(IOracle indexed defaultOracle);\n\n    constructor(IOracle defaultOracle_) {\n        defaultOracle = defaultOracle_;\n    }\n\n    /// @inheritdoc IOracle\n    function getPriceInUsd(address token_) public view override returns (uint256 _priceInUsd) {\n        IOracle _oracle = oracles[token_];\n\n        if (address(_oracle) != address(0)) {\n            _priceInUsd = _oracle.getPriceInUsd(token_);\n        } else if (address(defaultOracle) != address(0)) {\n            _priceInUsd = defaultOracle.getPriceInUsd(token_);\n        } else {\n            revert(\"token-without-oracle\");\n        }\n\n        require(_priceInUsd > 0, \"invalid-token-price\");\n    }\n\n    /// @inheritdoc IOracle\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external view virtual override returns (uint256 _amountOut) {\n        _amountOut = quoteUsdToToken(tokenOut_, quoteTokenToUsd(tokenIn_, amountIn_));\n    }\n\n    /// @inheritdoc IOracle\n    function quoteTokenToUsd(address token_, uint256 amountIn_) public view override returns (uint256 _amountOut) {\n        _amountOut = (amountIn_ * getPriceInUsd(token_)) / 10**IERC20Metadata(token_).decimals();\n    }\n\n    /// @inheritdoc IOracle\n    function quoteUsdToToken(address token_, uint256 amountIn_) public view override returns (uint256 _amountOut) {\n        _amountOut = (amountIn_ * 10**IERC20Metadata(token_).decimals()) / getPriceInUsd(token_);\n    }\n\n    /// @notice Set custom oracle for a token\n    function _updateTokenOracle(address token_, IOracle oracle_) private {\n        oracles[token_] = oracle_;\n        emit TokenOracleUpdated(token_, oracle_);\n    }\n\n    /// @notice Update the default oracle\n    function updateDefaultOracle(IOracle defaultOracle_) external onlyGovernor {\n        defaultOracle = defaultOracle_;\n        emit DefaultOracleUpdated(defaultOracle_);\n    }\n\n    /// @notice Set custom oracle for a token\n    function updateTokenOracle(address token_, IOracle oracle_) external onlyGovernor {\n        _updateTokenOracle(token_, oracle_);\n    }\n\n    /**\n     * @notice Set custom oracles for a set of tokens\n     * @dev We allow null address inside of the `oracles_` array in order to turn off oracle for a given asset\n     */\n    function updateTokenOracles(address[] calldata tokens_, IOracle[] calldata oracles_) external onlyGovernor {\n        uint256 _tokensLength = tokens_.length;\n        require(_tokensLength > 0 && _tokensLength == oracles_.length, \"invalid-arrays-length\");\n\n        for (uint256 i; i < _tokensLength; ++i) {\n            address _token = tokens_[i];\n            require(_token != address(0), \"a-token-has-null-address\");\n            _updateTokenOracle(_token, oracles_[i]);\n        }\n    }\n}\n"
    },
    "contracts/periphery/tokens/MStableTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../interfaces/external/mstable/IMasset.sol\";\nimport \"../../interfaces/external/mstable/ISavingsContractV2.sol\";\nimport \"../../interfaces/periphery/IOracle.sol\";\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\n\n/**\n * @title mStable's tokens oracle\n */\ncontract MStableTokenOracle is ITokenOracle {\n    uint256 private constant RATIO_DENOMINATOR = 1e8;\n\n    IMasset public constant MUSD = IMasset(0xe2f2a5C287993345a840Db3B0845fbC70f5935a5);\n    ISavingsContractV2 public constant IMUSD = ISavingsContractV2(0x30647a72Dc82d7Fbb1123EA74716aB8A317Eac19);\n    IMasset public constant MBTC = IMasset(0x945Facb997494CC2570096c74b5F66A3507330a1);\n    ISavingsContractV2 public constant IMBTC = ISavingsContractV2(0x17d8CBB6Bce8cEE970a4027d1198F6700A7a6c24);\n\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address mAsset_) external view returns (uint256) {\n        if (mAsset_ == address(MUSD)) return _mAssetUsdPrice(MUSD);\n        if (mAsset_ == address(IMUSD)) return (IMUSD.exchangeRate() * _mAssetUsdPrice(MUSD)) / 1e18;\n        if (mAsset_ == address(MBTC)) return _mAssetUsdPrice(MBTC);\n        if (mAsset_ == address(IMBTC)) return (IMBTC.exchangeRate() * _mAssetUsdPrice(MBTC)) / 1e18;\n\n        revert(\"invalid-token\");\n    }\n\n    /// @notice Return mAsset price\n    /// @dev Uses the `MasterOracle` (msg.sender) to get underlying assets' prices\n    function _mAssetUsdPrice(IMasset mAsset_) private view returns (uint256) {\n        (IMasset.BassetPersonal[] memory bAssetPersonal, IMasset.BassetData[] memory bAssetData) = mAsset_.getBassets();\n        uint256 _totalValue;\n        uint256 _len = bAssetData.length;\n        for (uint256 i; i < _len; i++) {\n            _totalValue +=\n                ((uint256(bAssetData[i].vaultBalance * bAssetData[i].ratio)) / RATIO_DENOMINATOR) *\n                // Note: `msg.sender` is the `MasterOracle` contract\n                IOracle(msg.sender).getPriceInUsd(bAssetPersonal[i].addr);\n        }\n\n        return _totalValue / mAsset_.totalSupply();\n    }\n}\n"
    },
    "contracts/interfaces/external/mstable/IMasset.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./MassetStructs.sol\";\n\ninterface IMasset is IERC20, MassetStructs {\n    // Mint\n    function mint(\n        address _input,\n        uint256 _inputQuantity,\n        uint256 _minOutputQuantity,\n        address _recipient\n    ) external returns (uint256 mintOutput);\n\n    function mintMulti(\n        address[] calldata _inputs,\n        uint256[] calldata _inputQuantities,\n        uint256 _minOutputQuantity,\n        address _recipient\n    ) external returns (uint256 mintOutput);\n\n    function getMintOutput(address _input, uint256 _inputQuantity) external view returns (uint256 mintOutput);\n\n    function getMintMultiOutput(address[] calldata _inputs, uint256[] calldata _inputQuantities)\n        external\n        view\n        returns (uint256 mintOutput);\n\n    // Swaps\n    function swap(\n        address _input,\n        address _output,\n        uint256 _inputQuantity,\n        uint256 _minOutputQuantity,\n        address _recipient\n    ) external returns (uint256 swapOutput);\n\n    function getSwapOutput(\n        address _input,\n        address _output,\n        uint256 _inputQuantity\n    ) external view returns (uint256 swapOutput);\n\n    // Redemption\n    function redeem(\n        address _output,\n        uint256 _mAssetQuantity,\n        uint256 _minOutputQuantity,\n        address _recipient\n    ) external returns (uint256 outputQuantity);\n\n    function redeemMasset(\n        uint256 _mAssetQuantity,\n        uint256[] calldata _minOutputQuantities,\n        address _recipient\n    ) external returns (uint256[] memory outputQuantities);\n\n    function redeemExactBassets(\n        address[] calldata _outputs,\n        uint256[] calldata _outputQuantities,\n        uint256 _maxMassetQuantity,\n        address _recipient\n    ) external returns (uint256 mAssetRedeemed);\n\n    function getRedeemOutput(address _output, uint256 _mAssetQuantity) external view returns (uint256 bAssetOutput);\n\n    function getRedeemExactBassetsOutput(address[] calldata _outputs, uint256[] calldata _outputQuantities)\n        external\n        view\n        returns (uint256 mAssetAmount);\n\n    // Views\n    function getBasket() external view returns (bool, bool);\n\n    function getBasset(address _token) external view returns (BassetPersonal memory personal, BassetData memory data);\n\n    function getBassets() external view returns (BassetPersonal[] memory personal, BassetData[] memory data);\n\n    function bAssetIndexes(address) external view returns (uint8);\n\n    // SavingsManager\n    function collectInterest() external returns (uint256 swapFeesGained, uint256 newSupply);\n\n    function collectPlatformInterest() external returns (uint256 mintAmount, uint256 newSupply);\n\n    // Admin\n    function setCacheSize(uint256 _cacheSize) external;\n\n    function upgradeForgeValidator(address _newForgeValidator) external;\n\n    function setFees(uint256 _swapFee, uint256 _redemptionFee) external;\n\n    function setTransferFeesFlag(address _bAsset, bool _flag) external;\n\n    function migrateBassets(address[] calldata _bAssets, address _newIntegration) external;\n}\n"
    },
    "contracts/interfaces/external/mstable/ISavingsContractV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ISavingsContractV2 {\n    function redeemCredits(uint256 _amount) external returns (uint256 underlyingReturned); // V2\n\n    function exchangeRate() external view returns (uint256); // V1 & V2\n}\n"
    },
    "contracts/interfaces/external/mstable/MassetStructs.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface MassetStructs {\n    struct BassetPersonal {\n        // Address of the bAsset\n        address addr;\n        // Address of the bAsset\n        address integrator;\n        // An ERC20 can charge transfer fee, for example USDT, DGX tokens.\n        bool hasTxFee; // takes a byte in storage\n        // Status of the bAsset\n        BassetStatus status;\n    }\n\n    struct BassetData {\n        // 1 Basset * ratio / ratioScale == x Masset (relative value)\n        // If ratio == 10e8 then 1 bAsset = 10 mAssets\n        // A ratio is divised as 10^(18-tokenDecimals) * measurementMultiple(relative value of 1 base unit)\n        uint128 ratio;\n        // Amount of the Basset that is held in Collateral\n        uint128 vaultBalance;\n    }\n\n    // Status of the Basset - has it broken its peg?\n    enum BassetStatus {\n        Default,\n        Normal,\n        BrokenBelowPeg,\n        BrokenAbovePeg,\n        Blacklisted,\n        Liquidating,\n        Liquidated,\n        Failed\n    }\n\n    struct BasketState {\n        bool undergoingRecol;\n        bool failed;\n    }\n\n    struct InvariantConfig {\n        uint256 a;\n        WeightLimits limits;\n    }\n\n    struct WeightLimits {\n        uint128 min;\n        uint128 max;\n    }\n\n    struct AmpData {\n        uint64 initialA;\n        uint64 targetA;\n        uint64 rampStartTime;\n        uint64 rampEndTime;\n    }\n}\n"
    },
    "contracts/periphery/ChainlinkAndFallbacksOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/core/IPriceProvidersAggregator.sol\";\nimport \"../interfaces/periphery/IOracle.sol\";\nimport \"../features/UsingMaxDeviation.sol\";\nimport \"../features/UsingStalePeriod.sol\";\n\n/**\n * @title Chainlink and Fallbacks oracle\n * @dev Uses chainlink as primary oracle, if it doesn't support the asset(s), get price from fallback providers\n */\ncontract ChainlinkAndFallbacksOracle is IOracle, UsingMaxDeviation, UsingStalePeriod {\n    /// @notice The fallback provider A. It's used when Chainlink isn't available\n    DataTypes.Provider public fallbackProviderA;\n\n    /// @notice The fallback provider B. It's used when Chainlink isn't available\n    /// @dev This is optional\n    DataTypes.Provider public fallbackProviderB;\n\n    /// @notice Emitted when fallback providers are updated\n    event FallbackProvidersUpdated(\n        DataTypes.Provider oldFallbackProviderA,\n        DataTypes.Provider newFallbackProviderA,\n        DataTypes.Provider oldFallbackProviderB,\n        DataTypes.Provider newFallbackProviderB\n    );\n\n    constructor(\n        uint256 maxDeviation_,\n        uint256 stalePeriod_,\n        DataTypes.Provider fallbackProviderA_,\n        DataTypes.Provider fallbackProviderB_\n    ) UsingMaxDeviation(maxDeviation_) UsingStalePeriod(stalePeriod_) {\n        require(fallbackProviderA_ != DataTypes.Provider.NONE, \"fallback-provider-not-set\");\n        fallbackProviderA = fallbackProviderA_;\n        fallbackProviderB = fallbackProviderB_;\n    }\n\n    /// @inheritdoc IOracle\n    function getPriceInUsd(address _asset) public view virtual returns (uint256 _priceInUsd) {\n        // 1. Get price from chainlink\n        uint256 _lastUpdatedAt;\n        (_priceInUsd, _lastUpdatedAt) = _getPriceInUsd(DataTypes.Provider.CHAINLINK, _asset);\n\n        // 2. If price from chainlink is OK return it\n        if (_priceInUsd > 0 && !_priceIsStale(_lastUpdatedAt)) {\n            return _priceInUsd;\n        }\n\n        // 3. Get price from fallback A\n        (uint256 _amountOutA, uint256 _lastUpdatedAtA) = _getPriceInUsd(fallbackProviderA, _asset);\n\n        // 4. If price from fallback A is OK and there isn't a fallback B, return price from fallback A\n        bool _aPriceOK = _amountOutA > 0 && !_priceIsStale(_lastUpdatedAtA);\n        if (fallbackProviderB == DataTypes.Provider.NONE) {\n            require(_aPriceOK, \"fallback-a-failed\");\n            return _amountOutA;\n        }\n\n        // 5. Get price from fallback B\n        (uint256 _amountOutB, uint256 _lastUpdatedAtB) = _getPriceInUsd(fallbackProviderB, _asset);\n\n        // 6. If only one price from fallbacks is valid, return it\n        bool _bPriceOK = _amountOutB > 0 && !_priceIsStale(_lastUpdatedAtB);\n        if (!_bPriceOK && _aPriceOK) {\n            return _amountOutA;\n        } else if (_bPriceOK && !_aPriceOK) {\n            return _amountOutB;\n        }\n\n        // 7. Check fallback prices deviation\n        require(_aPriceOK && _bPriceOK, \"fallbacks-failed\");\n        require(_isDeviationOK(_amountOutA, _amountOutB), \"prices-deviation-too-high\");\n\n        // 8. If deviation is OK, return price from fallback A\n        return _amountOutA;\n    }\n\n    /// @inheritdoc IOracle\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) public view virtual returns (uint256 _amountOut) {\n        // 1. Get price from chainlink\n        uint256 _lastUpdatedAt;\n        (_amountOut, _lastUpdatedAt) = _quote(DataTypes.Provider.CHAINLINK, tokenIn_, tokenOut_, amountIn_);\n\n        // 2. If price from chainlink is OK return it\n        if (_amountOut > 0 && !_priceIsStale(_lastUpdatedAt)) {\n            return _amountOut;\n        }\n\n        // 3. Get price from fallback A\n        (uint256 _amountOutA, uint256 _lastUpdatedAtA) = _quote(fallbackProviderA, tokenIn_, tokenOut_, amountIn_);\n\n        // 4. If price from fallback A is OK and there isn't a fallback B, return price from fallback A\n        bool _aPriceOK = _amountOutA > 0 && !_priceIsStale(_lastUpdatedAtA);\n        if (fallbackProviderB == DataTypes.Provider.NONE) {\n            require(_aPriceOK, \"fallback-a-failed\");\n            return _amountOutA;\n        }\n\n        // 5. Get price from fallback B\n        (uint256 _amountOutB, uint256 _lastUpdatedAtB) = _quote(fallbackProviderB, tokenIn_, tokenOut_, amountIn_);\n\n        // 6. If only one price from fallbacks is valid, return it\n        bool _bPriceOK = _amountOutB > 0 && !_priceIsStale(_lastUpdatedAtB);\n        if (!_bPriceOK && _aPriceOK) {\n            return _amountOutA;\n        } else if (_bPriceOK && !_aPriceOK) {\n            return _amountOutB;\n        }\n\n        // 7. Check fallback prices deviation\n        require(_aPriceOK && _bPriceOK, \"fallbacks-failed\");\n        require(_isDeviationOK(_amountOutA, _amountOutB), \"prices-deviation-too-high\");\n\n        // 8. If deviation is OK, return price from fallback A\n        return _amountOutA;\n    }\n\n    /// @inheritdoc IOracle\n    function quoteTokenToUsd(address token_, uint256 amountIn_) public view virtual returns (uint256 _amountOut) {\n        // 1. Get price from chainlink\n        uint256 _lastUpdatedAt;\n        (_amountOut, _lastUpdatedAt) = _quoteTokenToUsd(DataTypes.Provider.CHAINLINK, token_, amountIn_);\n\n        // 2. If price from chainlink is OK return it\n        if (_amountOut > 0 && !_priceIsStale(_lastUpdatedAt)) {\n            return _amountOut;\n        }\n\n        // 3. Get price from fallback A\n        (uint256 _amountOutA, uint256 _lastUpdatedAtA) = _quoteTokenToUsd(fallbackProviderA, token_, amountIn_);\n\n        // 4. If price from fallback A is OK and there isn't a fallback B, return price from fallback A\n        bool _aPriceOK = _amountOutA > 0 && !_priceIsStale(_lastUpdatedAtA);\n        if (fallbackProviderB == DataTypes.Provider.NONE) {\n            require(_aPriceOK, \"fallback-a-failed\");\n            return _amountOutA;\n        }\n\n        // 5. Get price from fallback B\n        (uint256 _amountOutB, uint256 _lastUpdatedAtB) = _quoteTokenToUsd(fallbackProviderB, token_, amountIn_);\n\n        // 6. If only one price from fallbacks is valid, return it\n        bool _bPriceOK = _amountOutB > 0 && !_priceIsStale(_lastUpdatedAtB);\n        if (!_bPriceOK && _aPriceOK) {\n            return _amountOutA;\n        } else if (_bPriceOK && !_aPriceOK) {\n            return _amountOutB;\n        }\n\n        // 7. Check fallback prices deviation\n        require(_aPriceOK && _bPriceOK, \"fallbacks-failed\");\n        require(_isDeviationOK(_amountOutA, _amountOutB), \"prices-deviation-too-high\");\n\n        // 8. If deviation is OK, return price from fallback A\n        return _amountOutA;\n    }\n\n    /// @inheritdoc IOracle\n    function quoteUsdToToken(address token_, uint256 amountIn_) public view virtual returns (uint256 _amountOut) {\n        // 1. Get price from chainlink\n        uint256 _lastUpdatedAt;\n        (_amountOut, _lastUpdatedAt) = _quoteUsdToToken(DataTypes.Provider.CHAINLINK, token_, amountIn_);\n\n        // 2. If price from chainlink is OK return it\n        if (_amountOut > 0 && !_priceIsStale(_lastUpdatedAt)) {\n            return _amountOut;\n        }\n\n        // 3. Get price from fallback A\n        (uint256 _amountOutA, uint256 _lastUpdatedAtA) = _quoteUsdToToken(fallbackProviderA, token_, amountIn_);\n\n        // 4. If price from fallback A is OK and there isn't a fallback B, return price from fallback A\n        bool _aPriceOK = _amountOutA > 0 && !_priceIsStale(_lastUpdatedAtA);\n        if (fallbackProviderB == DataTypes.Provider.NONE) {\n            require(_aPriceOK, \"fallback-a-failed\");\n            return _amountOutA;\n        }\n\n        // 5. Get price from fallback B\n        (uint256 _amountOutB, uint256 _lastUpdatedAtB) = _quoteUsdToToken(fallbackProviderB, token_, amountIn_);\n\n        // 6. If only one price from fallbacks is valid, return it\n        bool _bPriceOK = _amountOutB > 0 && !_priceIsStale(_lastUpdatedAtB);\n        if (!_bPriceOK && _aPriceOK) {\n            return _amountOutA;\n        } else if (_bPriceOK && !_aPriceOK) {\n            return _amountOutB;\n        }\n\n        // 7. Check fallback prices deviation\n        require(_aPriceOK && _bPriceOK, \"fallbacks-failed\");\n        require(_isDeviationOK(_amountOutA, _amountOutB), \"prices-deviation-too-high\");\n\n        // 8. If deviation is OK, return price from fallback A\n        return _amountOutA;\n    }\n\n    /**\n     * @notice Wrapped `getPriceInUsd` function\n     * @dev Return [0,0] (i.e. invalid quote) if the call reverts\n     */\n    function _getPriceInUsd(DataTypes.Provider provider_, address token_)\n        private\n        view\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        try addressProvider.providersAggregator().getPriceInUsd(provider_, token_) returns (\n            uint256 __priceInUsd,\n            uint256 __lastUpdatedAt\n        ) {\n            _priceInUsd = __priceInUsd;\n            _lastUpdatedAt = __lastUpdatedAt;\n        } catch {}\n    }\n\n    /**\n     * @notice Wrapped providers aggregator's `quote` function\n     * @dev Return [0,0] (i.e. invalid quote) if the call reverts\n     */\n    function _quote(\n        DataTypes.Provider provider_,\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) private view returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        try addressProvider.providersAggregator().quote(provider_, tokenIn_, tokenOut_, amountIn_) returns (\n            uint256 __amountOut,\n            uint256 __lastUpdatedAt\n        ) {\n            _amountOut = __amountOut;\n            _lastUpdatedAt = __lastUpdatedAt;\n        } catch {}\n    }\n\n    /**\n     * @notice Wrapped providers aggregator's `quoteTokenToUsd` function\n     * @dev Return [0,0] (i.e. invalid quote) if the call reverts\n     */\n    function _quoteTokenToUsd(\n        DataTypes.Provider provider_,\n        address token_,\n        uint256 amountIn_\n    ) private view returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        try addressProvider.providersAggregator().quoteTokenToUsd(provider_, token_, amountIn_) returns (\n            uint256 __amountOut,\n            uint256 __lastUpdatedAt\n        ) {\n            _amountOut = __amountOut;\n            _lastUpdatedAt = __lastUpdatedAt;\n        } catch {}\n    }\n\n    /**\n     * @notice Wrapped providers aggregator's `quoteUsdToToken` function\n     * @dev Return [0,0] (i.e. invalid quote) if the call reverts\n     */\n    function _quoteUsdToToken(\n        DataTypes.Provider provider_,\n        address token_,\n        uint256 amountIn_\n    ) private view returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        try addressProvider.providersAggregator().quoteUsdToToken(provider_, token_, amountIn_) returns (\n            uint256 __amountOut,\n            uint256 __lastUpdatedAt\n        ) {\n            _amountOut = __amountOut;\n            _lastUpdatedAt = __lastUpdatedAt;\n        } catch {}\n    }\n\n    /**\n     * @notice Update fallback providers\n     * @dev The fallback provider B is optional\n     */\n    function updateFallbackProviders(DataTypes.Provider fallbackProviderA_, DataTypes.Provider fallbackProviderB_)\n        external\n        onlyGovernor\n    {\n        require(fallbackProviderA_ != DataTypes.Provider.NONE, \"fallback-a-is-null\");\n        emit FallbackProvidersUpdated(fallbackProviderA, fallbackProviderA_, fallbackProviderB, fallbackProviderB_);\n        fallbackProviderA = fallbackProviderA_;\n        fallbackProviderB = fallbackProviderB_;\n    }\n}\n"
    },
    "contracts/core/PriceProvidersAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../interfaces/core/IPriceProvidersAggregator.sol\";\nimport \"../access/Governable.sol\";\n\n/**\n * @title Price Providers Aggregator\n */\ncontract PriceProvidersAggregator is IPriceProvidersAggregator, Governable {\n    /**\n     * The native token (usually the most liquid asset in the chain)\n     * @dev Is used when getting quote from two price providers\n     */\n    address public immutable nativeToken;\n\n    /**\n     * @notice Price providers map\n     */\n    mapping(DataTypes.Provider => IPriceProvider) public override priceProviders;\n\n    /// Emitted when an price provider is updated\n    event PriceProviderUpdated(\n        DataTypes.Provider provider,\n        IPriceProvider oldPriceProvider,\n        IPriceProvider newPriceProvider\n    );\n\n    constructor(address nativeToken_) {\n        require(nativeToken_ != address(0), \"native-token-is-null\");\n        nativeToken = nativeToken_;\n    }\n\n    /// @inheritdoc IPriceProvidersAggregator\n    function getPriceInUsd(DataTypes.Provider provider_, address token_)\n        external\n        view\n        override\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        IPriceProvider _provider = priceProviders[provider_];\n        require(address(_provider) != address(0), \"provider-not-set\");\n        return _provider.getPriceInUsd(token_);\n    }\n\n    /// @inheritdoc IPriceProvidersAggregator\n    function quote(\n        DataTypes.Provider provider_,\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        IPriceProvider _provider = priceProviders[provider_];\n        require(address(_provider) != address(0), \"provider-not-set\");\n        return _provider.quote(tokenIn_, tokenOut_, amountIn_);\n    }\n\n    /// @inheritdoc IPriceProvidersAggregator\n    function quote(\n        DataTypes.Provider providerIn_,\n        address tokenIn_,\n        DataTypes.Provider providerOut_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        IPriceProvider _providerIn = priceProviders[providerIn_];\n        require(address(_providerIn) != address(0), \"provider-in-not-set\");\n\n        if (providerIn_ == providerOut_) {\n            return _providerIn.quote(tokenIn_, tokenOut_, amountIn_);\n        }\n\n        IPriceProvider _providerOut = priceProviders[providerOut_];\n        require(address(_providerOut) != address(0), \"provider-out-not-set\");\n\n        (_amountOut, _lastUpdatedAt) = _providerIn.quote(tokenIn_, nativeToken, amountIn_);\n        uint256 __lastUpdatedAt;\n        (_amountOut, __lastUpdatedAt) = _providerOut.quote(nativeToken, tokenOut_, _amountOut);\n        _lastUpdatedAt = Math.min(__lastUpdatedAt, _lastUpdatedAt);\n    }\n\n    /// @inheritdoc IPriceProvidersAggregator\n    function quoteTokenToUsd(\n        DataTypes.Provider provider_,\n        address token_,\n        uint256 amountIn_\n    ) external view override returns (uint256 amountOut_, uint256 _lastUpdatedAt) {\n        IPriceProvider _provider = priceProviders[provider_];\n        require(address(_provider) != address(0), \"provider-not-set\");\n        return _provider.quoteTokenToUsd(token_, amountIn_);\n    }\n\n    /// @inheritdoc IPriceProvidersAggregator\n    function quoteUsdToToken(\n        DataTypes.Provider provider_,\n        address token_,\n        uint256 amountIn_\n    ) external view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        IPriceProvider _provider = priceProviders[provider_];\n        require(address(_provider) != address(0), \"provider-not-set\");\n        return _provider.quoteUsdToToken(token_, amountIn_);\n    }\n\n    /// @inheritdoc IPriceProvidersAggregator\n    function setPriceProvider(DataTypes.Provider provider_, IPriceProvider priceProvider_)\n        external\n        override\n        onlyGovernor\n    {\n        require(provider_ != DataTypes.Provider.NONE, \"invalid-provider\");\n        IPriceProvider _current = priceProviders[provider_];\n        require(priceProvider_ != _current, \"same-as-current\");\n\n        emit PriceProviderUpdated(provider_, _current, priceProvider_);\n\n        priceProviders[provider_] = priceProvider_;\n    }\n}\n"
    },
    "contracts/interfaces/core/IUmbrellaPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./IPriceProvider.sol\";\n\ninterface IUmbrellaPriceProvider is IPriceProvider {}\n"
    },
    "contracts/interfaces/core/IUmbrellaPassportPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../dependencies/@umb-network/interfaces/IDatumReceiver.sol\";\nimport \"./IUmbrellaPriceProvider.sol\";\n\ninterface IUmbrellaPassportPriceProvider is IUmbrellaPriceProvider, IDatumReceiver {\n    /**\n     * @notice Updates heartbeat\n     */\n    function updateHeartbeatTimestamp(uint128 heartbeatTimestamp_) external;\n\n    /**\n     * @notice Updates deviation threshold\n     */\n    function updateDeviationThreshold(uint128 deviationThreshold_) external;\n}\n"
    },
    "contracts/dependencies/@umb-network/interfaces/IDatumReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../lib/PassportStructs.sol\";\n\ninterface IDatumReceiver {\n  /// @notice This function will hold the parameters or business rules that consumer\n  /// wants to do with the received data structure, here called Pallet.\n  /// @param _pallet the structure sent by DatumRegistry, containing proof, key and value\n  function receivePallet(Pallet calldata _pallet) external;\n\n  /// @notice This function holds rules that consumer may need to check before accepting\n  /// the Pallet. Rules like how old is the block, or how many blocks have passed since\n  /// last storage. Deliverer will check if approvePallet reverted this call or returned true.\n  /// @param _pallet The exact same Pallet that will arrive at the receivePallet endpoint.\n  /// @return true if wants pallet or should REVERT if Contract does not want the pallet.\n  /// @dev DO NOT RETURN false.\n  function approvePallet(Pallet calldata _pallet) external view returns (bool);\n}\n"
    },
    "contracts/dependencies/@umb-network/lib/PassportStructs.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nstruct Datum {\n  address receiver;\n  bytes32[] keys;\n  address funder;\n  uint128 balance;\n  bool enabled;\n}\n\nstruct Pallet {\n  uint32 blockId;\n  bytes32 key;\n  bytes32 value;\n  bytes32[] proof;\n}\n\nstruct Delivery {\n  bytes32 datumId;\n  uint256[] indexes;\n}\n"
    },
    "contracts/core/UmbrellaPassportPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../dependencies/@umb-network/lib/ValueDecoder.sol\";\nimport \"./UmbrellaPriceProvider.sol\";\nimport \"../interfaces/core/IUmbrellaPassportPriceProvider.sol\";\n\n/**\n * @title Umbrella Passport's Datum receiver & Price provider\n * @dev Based on https://bscscan.com/address/0xd3e5Bf479BF8A2252D89D2990dDE2173869166D0#code\n * Important: This contract assumes that all pallets are USD prices (i.e. `XYZ-USD` quotes).\n */\ncontract UmbrellaPassportPriceProvider is IUmbrellaPassportPriceProvider, UmbrellaPriceProvider {\n    using ValueDecoder for bytes32;\n    using SafeCast for uint256;\n\n    bytes32 private constant DATUM_REGISTRY = bytes32(\"DatumRegistry\");\n\n    struct PriceData {\n        uint224 priceInUsd;\n        uint32 lastUpdatedAt;\n    }\n\n    struct UpdatePolicy {\n        uint128 heartbeatTimestamp; // must update at least once on every heartbeat\n        uint128 deviationThreshold; // must update if deviation reaches threshold (% in 18-decimals)\n    }\n\n    /// @notice Parameters used to accept new prices\n    UpdatePolicy public updatePolicy;\n\n    /// @notice Mapping of latest price of key\n    mapping(bytes32 => PriceData) public latestPriceOf;\n\n    /// @notice Emitted when heartbeat is updated\n    event HeartbeatTimestampUpdated(uint128 oldHeartbeatTimestamp, uint128 newHeartbeatTimestamp);\n\n    /// @notice Emitted when deviation threshold is updated\n    event DeviationThresholdUpdated(uint128 oldDeviationThreshold, uint128 newDeviationThreshold);\n\n    constructor(\n        IRegistry registry_,\n        uint128 heartbeatTimestamp_,\n        uint128 deviationThreshold_\n    ) UmbrellaPriceProvider(registry_) {\n        updatePolicy = UpdatePolicy({heartbeatTimestamp: heartbeatTimestamp_, deviationThreshold: deviationThreshold_});\n    }\n\n    /// @inheritdoc IDatumReceiver\n    function approvePallet(Pallet calldata pallet_) external view virtual override returns (bool) {\n        IChain.Block memory _block = _chain().blocks(pallet_.blockId);\n\n        UpdatePolicy memory _updatePolicy = updatePolicy;\n        PriceData memory _priceData = latestPriceOf[pallet_.key];\n\n        if (_block.dataTimestamp > _priceData.lastUpdatedAt + _updatePolicy.heartbeatTimestamp) {\n            return true;\n        }\n\n        uint224 _latestPrice = _priceData.priceInUsd;\n        uint224 _newPrice = pallet_.value.toUint().toUint224();\n        uint256 _deviation = _latestPrice > _newPrice\n            ? ((_latestPrice - _newPrice) * 1e18) / _latestPrice\n            : ((_newPrice - _latestPrice) * 1e18) / _newPrice;\n\n        require(_deviation > _updatePolicy.deviationThreshold, \"did-not-match-conditions\");\n\n        return true;\n    }\n\n    /// @inheritdoc IDatumReceiver\n    function receivePallet(Pallet calldata pallet_) external virtual override {\n        require(msg.sender == registry.getAddress(DATUM_REGISTRY), \"not-datum-registry\");\n\n        uint32 _palletTimestamp = _chain().blocks(pallet_.blockId).dataTimestamp;\n\n        require(latestPriceOf[pallet_.key].lastUpdatedAt < _palletTimestamp, \"update-already-received\");\n\n        latestPriceOf[pallet_.key] = PriceData({\n            lastUpdatedAt: _palletTimestamp,\n            priceInUsd: pallet_.value.toUint().toUint224()\n        });\n    }\n\n    /// @inheritdoc IUmbrellaPassportPriceProvider\n    function updateHeartbeatTimestamp(uint128 heartbeatTimestamp_) external onlyGovernor {\n        emit HeartbeatTimestampUpdated(updatePolicy.heartbeatTimestamp, heartbeatTimestamp_);\n        updatePolicy.heartbeatTimestamp = heartbeatTimestamp_;\n    }\n\n    /// @inheritdoc IUmbrellaPassportPriceProvider\n    function updateDeviationThreshold(uint128 deviationThreshold_) external onlyGovernor {\n        emit DeviationThresholdUpdated(updatePolicy.deviationThreshold, deviationThreshold_);\n        updatePolicy.deviationThreshold = deviationThreshold_;\n    }\n\n    /**\n     * @inheritdoc IPriceProvider\n     * @dev Get the latest price between Chain (Firs Class Data) and Passport data\n     */\n    function getPriceInUsd(address token_)\n        public\n        view\n        override(IPriceProvider, UmbrellaPriceProvider)\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        bytes32 _key = keyOfToken[token_];\n\n        (_priceInUsd, _lastUpdatedAt) = _chain().getCurrentValue(_key);\n        PriceData memory _priceData = latestPriceOf[_key];\n\n        if (_priceData.lastUpdatedAt >= _lastUpdatedAt) {\n            _priceInUsd = _priceData.priceInUsd;\n            _lastUpdatedAt = _priceData.lastUpdatedAt;\n        }\n\n        require(_lastUpdatedAt > 0, \"invalid-quote\");\n    }\n}\n"
    },
    "contracts/dependencies/@umb-network/lib/ValueDecoder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nlibrary ValueDecoder {\n  function toUint(bytes memory _bytes) internal pure returns (uint256 value) {\n    assembly {\n      value := mload(add(_bytes, 32))\n    }\n  }\n\n  function toUint(bytes32 _bytes) internal pure returns (uint256 value) {\n    assembly {\n      value := _bytes\n    }\n  }\n\n  function toInt(uint224 u) internal pure returns (int256) {\n    int224 i;\n    uint224 max = type(uint224).max;\n\n    if (u <= (max - 1) / 2) { // positive values\n      assembly {\n        i := add(u, 0)\n      }\n\n      return i;\n    } else { // negative values\n      assembly {\n        i := sub(sub(u, max), 1)\n      }\n    }\n\n    return i;\n  }\n}\n\n"
    },
    "contracts/core/UmbrellaPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@umb-network/toolbox/dist/contracts/IChain.sol\";\nimport \"@umb-network/toolbox/dist/contracts/IRegistry.sol\";\nimport \"../access/Governable.sol\";\nimport \"../interfaces/core/IUmbrellaPriceProvider.sol\";\nimport \"./PriceProvider.sol\";\n\n/**\n * @notice Umbrella's price provider\n */\ncontract UmbrellaPriceProvider is IUmbrellaPriceProvider, PriceProvider, Governable {\n    bytes32 private constant CHAIN = bytes32(\"Chain\");\n\n    /**\n     * @notice token => Umbrella's key mapping (e.g. WBTC => \"BTC-USD\")\n     */\n    mapping(address => bytes32) public keyOfToken;\n\n    /**\n     * @notice Umbrella's Registry\n     * @dev Stores the other Umbrella's contracts' addresses\n     */\n    IRegistry public immutable registry;\n\n    event KeyOfTokenUpdated(address indexed token, bytes32 oldKey, bytes32 newKey);\n\n    constructor(IRegistry registry_) {\n        require(address(registry_) != address(0), \"registry-is-null\");\n        registry = registry_;\n    }\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(address token_)\n        public\n        view\n        virtual\n        override(IPriceProvider, PriceProvider)\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        (_priceInUsd, _lastUpdatedAt) = _chain().getCurrentValue(keyOfToken[token_]);\n        require(_lastUpdatedAt > 0, \"invalid-quote\");\n    }\n\n    /**\n     * @notice Get Umbrella's main contract\n     */\n    function _chain() internal view returns (IChain umbChain) {\n        umbChain = IChain(registry.getAddress(CHAIN));\n    }\n\n    /**\n     * @notice Build key from quote/base string in bytes format\n     * @dev The standard parser `bytes32(bytes)` will right pad with zeros\n     * but Umbrella expects left padded bytes as key\n     * @dev See if there is a simpler way to do the same as this function\n     */\n    function _toKey(bytes memory quotePairAsBytes_) private pure returns (bytes32) {\n        bytes memory _aux = new bytes(32);\n        uint256 _len = quotePairAsBytes_.length;\n        for (uint256 i; i < _len; ++i) {\n            uint256 _idx = 32 - _len + i;\n            _aux[_idx] = quotePairAsBytes_[i];\n        }\n        return bytes32(_aux);\n    }\n\n    /**\n     * @notice Update Umbrella's key of a token\n     * Use `BASE-QUOTE` format (e.g. BTC-USD, ETH-USD, etc)\n     */\n    function updateKeyOfToken(address token_, string memory quotePair_) external onlyGovernor {\n        require(token_ != address(0), \"address-is-null\");\n        bytes32 _currentKey = keyOfToken[token_];\n        bytes32 _newKey = _toKey(bytes(quotePair_));\n        keyOfToken[token_] = _newKey;\n        emit KeyOfTokenUpdated(token_, _currentKey, _newKey);\n    }\n}\n"
    },
    "@umb-network/toolbox/dist/contracts/IChain.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.8;\npragma abicoder v2;\n\ninterface IChain {\n  struct Block {\n    bytes32 root;\n    uint32 dataTimestamp;\n  }\n\n  struct FirstClassData {\n    uint224 value;\n    uint32 dataTimestamp;\n  }\n\n  function isForeign() external pure returns (bool);\n\n  function blocks(uint256) external view returns (Block memory);\n\n  function fcds(bytes32) external view returns (FirstClassData memory);\n\n  function blocksCount() external view returns (uint32);\n\n  function blocksCountOffset() external view returns (uint32);\n\n  function padding() external view returns (uint16);\n\n  function getName() external pure returns (bytes32);\n\n  function recoverSigner(bytes32 affidavit, uint8 _v, bytes32 _r, bytes32 _s) external pure returns (address);\n\n  function getStatus() external view returns(\n    uint256 blockNumber,\n    uint16 timePadding,\n    uint32 lastDataTimestamp,\n    uint32 lastBlockId,\n    address nextLeader,\n    uint32 nextBlockId,\n    address[] memory validators,\n    uint256[] memory powers,\n    string[] memory locations,\n    uint256 staked\n  );\n\n  function getBlockId() external view returns (uint32);\n\n  // this function does not works for past timestamps\n  function getBlockIdAtTimestamp(uint256 _timestamp) external view returns (uint32);\n\n  function getLatestBlockId() external view returns (uint32);\n\n  function getLeaderIndex(uint256 _numberOfValidators, uint256 _timestamp) external view returns (uint256);\n\n  function getNextLeaderAddress() external view returns (address);\n\n  function getLeaderAddress() external view returns (address);\n\n  function getLeaderAddressAtTime(uint232 _timestamp) external view returns (address);\n\n  function hashLeaf(bytes calldata _key, bytes calldata _value) external pure returns (bytes32);\n\n  function verifyProof(bytes32[] calldata _proof, bytes32 _root, bytes32 _leaf) external pure returns (bool);\n\n  function verifyProofForBlock(\n    uint256 _blockId,\n    bytes32[] calldata _proof,\n    bytes calldata _key,\n    bytes calldata _value\n  ) external view returns (bool);\n\n  function bytesToBytes32Array(\n    bytes calldata _data,\n    uint256 _offset,\n    uint256 _items\n  ) external pure returns (bytes32[] memory);\n\n  function verifyProofs(\n    uint32[] memory _blockIds,\n    bytes memory _proofs,\n    uint256[] memory _proofItemsCounter,\n    bytes32[] memory _leaves\n  ) external view returns (bool[] memory results);\n  \n  function getBlockRoot(uint256 _blockId) external view returns (bytes32);\n\n  function getBlockTimestamp(uint32 _blockId) external view returns (uint32);\n\n  function getCurrentValues(bytes32[] calldata _keys)\n  external view returns (uint256[] memory values, uint32[] memory timestamps);\n\n  function getCurrentValue(bytes32 _key) external view returns (uint256 value, uint256 timestamp);\n}\n"
    },
    "@umb-network/toolbox/dist/contracts/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.8;\n\ninterface IRegistry {\n  function registry(bytes32 _name) external view returns (address);\n\n  function requireAndGetAddress(bytes32 _name) external view returns (address);\n\n  function getAddress(bytes32 _bytes) external view returns (address);\n\n  function getAddressByString(string memory _name) external view returns (address);\n\n  function stringToBytes32(string memory _string) external pure returns (bytes32);\n}\n"
    },
    "contracts/interfaces/core/IFluxPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./IPriceProvider.sol\";\n\ninterface IFluxPriceProvider is IPriceProvider {\n    /**\n     * @notice Add an aggregator to the token\n     */\n    function addAggregator(address token_, address aggregator_) external;\n\n    /**\n     * @notice Remove an aggregator from the token\n     */\n    function removeAggregator(address token_, address aggregator_) external;\n}\n"
    },
    "contracts/core/FluxPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../interfaces/core/IFluxPriceProvider.sol\";\nimport \"../features/UsingMaxDeviation.sol\";\nimport \"./PriceProvider.sol\";\n\n/**\n * @title Flux's price provider\n * @dev The Flux uses the same aggregator's interface as Chainlink\n */\ncontract FluxPriceProvider is IFluxPriceProvider, PriceProvider, UsingMaxDeviation {\n    using SafeCast for int256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 public constant FLUX_DECIMALS = 8;\n    uint256 public constant TO_SCALE = 10**(USD_DECIMALS - FLUX_DECIMALS);\n\n    /**\n     * @notice Aggregators map (token => aggregator[])\n     */\n    mapping(address => EnumerableSet.AddressSet) internal aggregatorsOf;\n\n    /// Emitted when an aggregator is added\n    event AggregatorAdded(address token, address aggregator);\n\n    /// Emitted when an aggregator is removed\n    event AggregatorRemoved(address token, address aggregator);\n\n    constructor(uint256 maxDeviation_) UsingMaxDeviation(maxDeviation_) {}\n\n    /**\n     * @notice Get all aggregators of token\n     * @dev WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees.\n     */\n    function getAggregatorsOf(address token_) external view returns (address[] memory) {\n        return aggregatorsOf[token_].values();\n    }\n\n    /**\n     * @inheritdoc IPriceProvider\n     * @dev Sweep all aggregators and get the most recent price, revert if deviation among prices are too high.\n     */\n    function getPriceInUsd(address token_)\n        public\n        view\n        override(IPriceProvider, PriceProvider)\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        EnumerableSet.AddressSet storage _aggregatorOf = aggregatorsOf[token_];\n\n        uint256 _len = aggregatorsOf[token_].length();\n        require(_len > 0, \"aggregator-not-found\");\n        int256 _price;\n        (, _price, , _lastUpdatedAt, ) = AggregatorV3Interface(_aggregatorOf.at(0)).latestRoundData();\n\n        for (uint256 i = 1; i < _len; ++i) {\n            (, int256 _iPrice, , uint256 _iLastUpdatedAt, ) = AggregatorV3Interface(_aggregatorOf.at(i))\n                .latestRoundData();\n\n            require(_isDeviationOK(_iPrice.toUint256(), _price.toUint256()), \"prices-deviation-too-high\");\n\n            if (_iLastUpdatedAt > _lastUpdatedAt) {\n                _price = _iPrice;\n                _lastUpdatedAt = _iLastUpdatedAt;\n            }\n        }\n\n        return (_price.toUint256() * TO_SCALE, _lastUpdatedAt);\n    }\n\n    /// @inheritdoc IFluxPriceProvider\n    function addAggregator(address token_, address aggregator_) external override onlyGovernor {\n        require(token_ != address(0), \"token-is-null\");\n        require(aggregator_ != address(0), \"aggregator-is-null\");\n        require(AggregatorV3Interface(aggregator_).decimals() == FLUX_DECIMALS, \"invalid-decimals\");\n        require(aggregatorsOf[token_].add(aggregator_), \"aggregator-exists\");\n\n        emit AggregatorAdded(token_, aggregator_);\n    }\n\n    /// @inheritdoc IFluxPriceProvider\n    function removeAggregator(address token_, address aggregator_) external override onlyGovernor {\n        require(token_ != address(0), \"token-is-null\");\n        require(aggregator_ != address(0), \"aggregator-is-null\");\n\n        require(aggregatorsOf[token_].remove(aggregator_), \"aggregator-doesnt-exist\");\n\n        emit AggregatorRemoved(token_, aggregator_);\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"./AggregatorV2V3Interface.sol\";\n\ninterface FeedRegistryInterface {\n  struct Phase {\n    uint16 phaseId;\n    uint80 startingAggregatorRoundId;\n    uint80 endingAggregatorRoundId;\n  }\n\n  event FeedProposed(\n    address indexed asset,\n    address indexed denomination,\n    address indexed proposedAggregator,\n    address currentAggregator,\n    address sender\n  );\n  event FeedConfirmed(\n    address indexed asset,\n    address indexed denomination,\n    address indexed latestAggregator,\n    address previousAggregator,\n    uint16 nextPhaseId,\n    address sender\n  );\n\n  // V3 AggregatorV3Interface\n\n  function decimals(address base, address quote) external view returns (uint8);\n\n  function description(address base, address quote) external view returns (string memory);\n\n  function version(address base, address quote) external view returns (uint256);\n\n  function latestRoundData(address base, address quote)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function getRoundData(\n    address base,\n    address quote,\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  // V2 AggregatorInterface\n\n  function latestAnswer(address base, address quote) external view returns (int256 answer);\n\n  function latestTimestamp(address base, address quote) external view returns (uint256 timestamp);\n\n  function latestRound(address base, address quote) external view returns (uint256 roundId);\n\n  function getAnswer(\n    address base,\n    address quote,\n    uint256 roundId\n  ) external view returns (int256 answer);\n\n  function getTimestamp(\n    address base,\n    address quote,\n    uint256 roundId\n  ) external view returns (uint256 timestamp);\n\n  // Registry getters\n\n  function getFeed(address base, address quote) external view returns (AggregatorV2V3Interface aggregator);\n\n  function getPhaseFeed(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (AggregatorV2V3Interface aggregator);\n\n  function isFeedEnabled(address aggregator) external view returns (bool);\n\n  function getPhase(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (Phase memory phase);\n\n  // Round helpers\n\n  function getRoundFeed(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (AggregatorV2V3Interface aggregator);\n\n  function getPhaseRange(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (uint80 startingRoundId, uint80 endingRoundId);\n\n  function getPreviousRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (uint80 previousRoundId);\n\n  function getNextRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (uint80 nextRoundId);\n\n  // Feed management\n\n  function proposeFeed(\n    address base,\n    address quote,\n    address aggregator\n  ) external;\n\n  function confirmFeed(\n    address base,\n    address quote,\n    address aggregator\n  ) external;\n\n  // Proposed aggregator\n\n  function getProposedFeed(address base, address quote)\n    external\n    view\n    returns (AggregatorV2V3Interface proposedAggregator);\n\n  function proposedGetRoundData(\n    address base,\n    address quote,\n    uint80 roundId\n  )\n    external\n    view\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function proposedLatestRoundData(address base, address quote)\n    external\n    view\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  // Phases\n  function getCurrentPhaseId(address base, address quote) external view returns (uint16 currentPhaseId);\n}\n"
    },
    "contracts/core/ChainlinkMainnetPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol\";\nimport \"./ChainlinkPriceProvider.sol\";\nimport \"../libraries/OracleHelpers.sol\";\n\n/**\n * @title Chainlink's price provider for Mainnet network\n * @dev Not uses price feed in order to save gas\n */\ncontract ChainlinkMainnetPriceProvider is ChainlinkPriceProvider {\n    constructor() {\n        // Mainnet's aggregators: https://docs.chain.link/docs/ethereum-addresses/\n        // Note: These are NOT all available aggregators, not adding them all to avoid too expensive deployment cost\n        _setAggregator(0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9, AggregatorV3Interface(0x547a514d5e3769680Ce22B2361c10Ea13619e8a9)); // AAVE\n        _setAggregator(0x85f138bfEE4ef8e540890CFb48F620571d67Eda3, AggregatorV3Interface(0xFF3EEb22B5E3dE6e705b44749C2559d704923FD7)); // WAVAX\n        _setAggregator(0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C, AggregatorV3Interface(0x1E6cF0D433de4FE882A437ABC654F58E1e78548c)); // BNT\n        _setAggregator(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599, AggregatorV3Interface(0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c)); // WBTC\n        _setAggregator(0xc00e94Cb662C3520282E6f5717214004A7f26888, AggregatorV3Interface(0xdbd020CAeF83eFd542f4De03e3cF0C28A4428bd5)); // COMP\n        _setAggregator(0xD533a949740bb3306d119CC777fa900bA034cd52, AggregatorV3Interface(0xCd627aA160A6fA45Eb793D19Ef54f5062F20f33f)); // CRV\n        _setAggregator(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B, AggregatorV3Interface(0xd962fC30A72A84cE50161031391756Bf2876Af5D)); // CVX\n        _setAggregator(0x6B175474E89094C44Da98b954EedeAC495271d0F, AggregatorV3Interface(0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9)); // DAI\n        _setAggregator(0x1494CA1F11D487c2bBe4543E90080AeBa4BA3C2b, AggregatorV3Interface(0xD2A593BF7594aCE1faD597adb697b5645d5edDB2)); // DPI\n        _setAggregator(0x92D6C1e31e14520e676a687F0a93788B716BEff5, AggregatorV3Interface(0x478909D4D798f3a1F11fFB25E4920C959B4aDe0b)); // DYDX\n        _setAggregator(0xC18360217D8F7Ab5e7c516566761Ea12Ce7F9D72, AggregatorV3Interface(0x5C00128d4d1c2F4f652C267d7bcdD7aC99C16E16)); // ENS\n        _setAggregator(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419)); // WETH\n        _setAggregator(0x956F47F50A910163D8BF957Cf5846D573E7f87CA, AggregatorV3Interface(0x31e0a88fecB6eC0a411DBe0e9E76391498296EE9)); // FEI\n        _setAggregator(0x853d955aCEf822Db058eb8505911ED77F175b99e, AggregatorV3Interface(0xB9E1E3A9feFf48998E45Fa90847ed4D467E8BcfD)); // FRAX\n        _setAggregator(0xc944E90C64B2c07662A292be6244BDf05Cda44a7, AggregatorV3Interface(0x86cF33a451dE9dc61a2862FD94FF4ad4Bd65A5d2)); // GRT\n        _setAggregator(0x056Fd409E1d7A124BD7017459dFEa2F387b6d5Cd, AggregatorV3Interface(0xa89f5d2365ce98B3cD68012b6f503ab1416245Fc)); // GUSD\n        _setAggregator(0x514910771AF9Ca656af840dff83E8264EcF986CA, AggregatorV3Interface(0x2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c)); // LINK\n        _setAggregator(0x0F5D2fB29fb7d3CFeE444a200298f468908cC942, AggregatorV3Interface(0x56a4857acbcfe3a66965c251628B1c9f1c408C19)); // MANA\n        _setAggregator(0x7c9f4C87d911613Fe9ca58b579f737911AAD2D43, AggregatorV3Interface(0x7bAC85A8a13A4BcD8abb3eB7d6b4d632c5a57676)); // WMATIC\n        _setAggregator(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3, AggregatorV3Interface(0x7A364e8770418566e3eb2001A96116E6138Eb32F)); // MIM\n        _setAggregator(0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2, AggregatorV3Interface(0xec1D1B3b0443256cc3860e24a46F108e699484Aa)); // MKR\n        _setAggregator(0xd26114cd6EE289AccF82350c8d8487fedB8A0C07, AggregatorV3Interface(0x7D476f061F8212A8C9317D5784e72B4212436E93)); // OMG\n        _setAggregator(0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F, AggregatorV3Interface(0xDC3EA94CD0AC27d9A86C180091e7f78C683d3699)); // SNX\n        _setAggregator(0x090185f2135308BaD17527004364eBcC2D37e5F6, AggregatorV3Interface(0x8c110B94C5f1d347fAcF5E1E938AB2db60E3c9a8)); // SPELL\n        _setAggregator(0x57Ab1ec28D129707052df4dF418D58a2D46d5f51, AggregatorV3Interface(0xad35Bd71b9aFE6e4bDc266B345c198eaDEf9Ad94)); // sUSD\n        _setAggregator(0x6B3595068778DD592e39A122f4f5a5cF09C90fE2, AggregatorV3Interface(0xCc70F09A6CC17553b2E31954cD36E4A2d89501f7)); // SUSHI\n        _setAggregator(0x0000000000085d4780B73119b644AE5ecd22b376, AggregatorV3Interface(0xec746eCF986E2927Abd291a2A1716c940100f8Ba)); // TUSD\n        _setAggregator(0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984, AggregatorV3Interface(0x553303d460EE0afB37EdFf9bE42922D8FF63220e)); // UNI\n        _setAggregator(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, AggregatorV3Interface(0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6)); // USDC\n        _setAggregator(0xdAC17F958D2ee523a2206206994597C13D831ec7, AggregatorV3Interface(0x3E7d1eAB13ad0104d2750B8863b489D65364e32D)); // USDT\n        _setAggregator(0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e, AggregatorV3Interface(0xA027702dbb89fbd58938e4324ac03B58d812b0E1)); // YFI\n    }\n}\n"
    },
    "contracts/core/ChainlinkPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../interfaces/core/IChainlinkPriceProvider.sol\";\nimport \"./PriceProvider.sol\";\nimport \"../access/Governable.sol\";\n\n/**\n * @title ChainLink's price provider\n * @dev This contract wraps chainlink aggregators\n */\ncontract ChainlinkPriceProvider is IChainlinkPriceProvider, PriceProvider, Governable {\n    using SafeCast for int256;\n\n    uint256 public constant CHAINLINK_DECIMALS = 8;\n    uint256 public constant TO_SCALE = 10**(USD_DECIMALS - CHAINLINK_DECIMALS);\n\n    /**\n     * @notice Aggregators map (token => aggregator)\n     */\n    mapping(address => AggregatorV3Interface) public aggregators;\n\n    /// Emitted when an aggregator is updated\n    event AggregatorUpdated(address token, AggregatorV3Interface oldAggregator, AggregatorV3Interface newAggregator);\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(address token_)\n        public\n        view\n        virtual\n        override(IPriceProvider, PriceProvider)\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        AggregatorV3Interface _aggregator = aggregators[token_];\n        require(address(_aggregator) != address(0), \"token-without-aggregator\");\n        int256 _price;\n        (, _price, , _lastUpdatedAt, ) = _aggregator.latestRoundData();\n        return (_price.toUint256() * TO_SCALE, _lastUpdatedAt);\n    }\n\n    /// @inheritdoc IChainlinkPriceProvider\n    function updateAggregator(address token_, AggregatorV3Interface aggregator_) external override onlyGovernor {\n        require(token_ != address(0), \"token-is-null\");\n        AggregatorV3Interface _current = aggregators[token_];\n        require(aggregator_ != _current, \"same-as-current\");\n        _setAggregator(token_, aggregator_);\n        emit AggregatorUpdated(token_, _current, aggregator_);\n    }\n\n    function _setAggregator(address token_, AggregatorV3Interface aggregator_) internal {\n        require(address(aggregator_) == address(0) || aggregator_.decimals() == CHAINLINK_DECIMALS, \"invalid-decimals\");\n        aggregators[token_] = aggregator_;\n    }\n}\n"
    },
    "contracts/interfaces/core/IChainlinkPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./IPriceProvider.sol\";\n\ninterface IChainlinkPriceProvider is IPriceProvider {\n    /**\n     * @notice Update token's aggregator\n     */\n    function updateAggregator(address token_, AggregatorV3Interface aggregator_) external;\n}\n"
    },
    "contracts/core/ChainlinkPolygonPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./ChainlinkPriceProvider.sol\";\n\n/**\n * @title Chainlink's price provider for Polygon network\n */\ncontract ChainlinkPolygonPriceProvider is ChainlinkPriceProvider {\n    constructor() {\n        // Polygon's aggregators: https://docs.chain.link/docs/matic-addresses/\n        _setAggregator(0x9c2C5fd7b07E95EE044DDeba0E97a665F142394f, AggregatorV3Interface(0x443C5116CdF663Eb387e72C688D276e702135C87)); // 1INCH\n        _setAggregator(0xD6DF932A45C0f255f85145f286eA0b292B21C90B, AggregatorV3Interface(0x72484B12719E23115761D5DA1646945632979bB6)); // AAVE\n        _setAggregator(0x3Cef98bb43d732E2F285eE605a8158cDE967D219, AggregatorV3Interface(0x2346Ce62bd732c62618944E51cbFa09D985d86D2)); // BAT\n        _setAggregator(0x3BA4c387f786bFEE076A58914F5Bd38d668B42c3, AggregatorV3Interface(0x82a6c4AF830caa6c97bb504425f6A66165C2c26e)); // BNB\n        _setAggregator(0xc26D47d5c33aC71AC5CF9F776D63Ba292a4F7842, AggregatorV3Interface(0xF5724884b6E99257cC003375e6b844bC776183f9)); // BNT\n        _setAggregator(0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6, AggregatorV3Interface(0xc907E116054Ad103354f2D350FD2514433D57F6f)); // WBTC\n        _setAggregator(0xD85d1e945766Fea5Eda9103F918Bd915FbCa63E6, AggregatorV3Interface(0xc9ECF45956f576681bDc01F79602A79bC2667B0c)); // CEL\n        _setAggregator(0xf1938Ce12400f9a761084E7A80d37e732a4dA056, AggregatorV3Interface(0x2409987e514Ad8B0973C2b90ee1D95051DF0ECB9)); // CHZ\n        _setAggregator(0x8505b9d2254A7Ae468c0E9dd10Ccea3A837aef5c, AggregatorV3Interface(0x2A8758b7257102461BC958279054e372C2b1bDE6)); // COMP\n        _setAggregator(0x172370d5Cd63279eFa6d502DAB29171933a610AF, AggregatorV3Interface(0x336584C8E6Dc19637A5b36206B1c79923111b405)); // CRV\n        _setAggregator(0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063, AggregatorV3Interface(0x4746DeC9e833A82EC7C2C1356372CcF2cfcD2F3D)); // DAI\n        _setAggregator(0x7eC26842F195c852Fa843bB9f6D8B583a274a157, AggregatorV3Interface(0x440A341bbC9FA86aA60A195e2409a547e48d4C0C)); // ENJ\n        _setAggregator(0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619, AggregatorV3Interface(0xF9680D99D6C9589e2a93a78A04A279e509205945)); // WETH\n        _setAggregator(0x45c32fA6DF82ead1e2EF74d17b76547EDdFaFF89, AggregatorV3Interface(0x00DBeB1e45485d53DF7C2F0dF1Aa0b6Dc30311d3)); // FRAX\n        _setAggregator(0xC9c1c1c20B3658F8787CC2FD702267791f224Ce1, AggregatorV3Interface(0x58326c0F831b2Dbf7234A4204F28Bba79AA06d5f)); // FTM\n        _setAggregator(0x1a3acf6D19267E2d3e7f898f42803e90C9219062, AggregatorV3Interface(0x6C0fe985D3cAcbCdE428b84fc9431792694d0f51)); // FXS\n        _setAggregator(0x385Eeac5cB85A38A9a07A70c73e0a3271CfB54A7, AggregatorV3Interface(0xDD229Ce42f11D8Ee7fFf29bDB71C7b81352e11be)); // GHST\n        _setAggregator(0x5FFD62D3C3eE2E81C00A7b9079FB248e7dF024A8, AggregatorV3Interface(0x432fa0899cF1BcDb98592D7eAA23C372b8b8ddf2)); // GNO\n        _setAggregator(0x5fe2B58c013d7601147DcdD68C143A77499f5531, AggregatorV3Interface(0x3FabBfb300B1e2D7c9B84512fe9D30aeDF24C410)); // GRT\n        _setAggregator(0xFAD65Eb62a97fF5Ed91B23aFD039956aaCa6e93b, AggregatorV3Interface(0x6F8F9e75C0285AecE30ADFe1BCc1955f145d971A)); // HT\n        _setAggregator(0x42f37A1296b2981F7C3cAcEd84c5096b2Eb0C72C, AggregatorV3Interface(0x5438E60A06C7447432512264Fa57e2FeD3224b33)); // KEEP\n        _setAggregator(0x1C954E8fe737F99f68Fa1CCda3e51ebDB291948C, AggregatorV3Interface(0x10e5f3DFc81B3e5Ef4e648C4454D04e79E1E41E2)); // KNC\n        _setAggregator(0x53E0bca35eC356BD5ddDFebbD1Fc0fD03FaBad39, AggregatorV3Interface(0xd9FFdb71EbE7496cC440152d43986Aae0AB76665)); // LINK\n        _setAggregator(0x3962F4A0A0051DccE0be73A7e09cEf5756736712, AggregatorV3Interface(0xBAaF11CeDA1d1Ca9Cf01748F8196653c9656a400)); // LPT\n        _setAggregator(0xA1c57f48F0Deb89f569dFbE6E2B7f46D33606fD4, AggregatorV3Interface(0xA1CbF3Fe43BC3501e3Fc4b573e822c70e76A7512)); // MANA\n        _setAggregator(0x6f7C932e7684666C9fd1d44527765433e01fF61d, AggregatorV3Interface(0xa070427bF5bA5709f70e98b94Cb2F435a242C46C)); // MKR\n        _setAggregator(0x41b3966B4FF7b427969ddf5da3627d6AEAE9a48E, AggregatorV3Interface(0x666bb13b3ED3816504E8c30D0F9B9C16b371774b)); // NEXO\n        _setAggregator(0x282d8efCe846A88B159800bd4130ad77443Fa1A1, AggregatorV3Interface(0xdcda79097C44353Dee65684328793695bd34A629)); // OCEAN\n        _setAggregator(0x62414D03084EeB269E18C970a21f45D2967F0170, AggregatorV3Interface(0x93FfEE768F74208a7b9f2a4426f0F6BCbb1D09de)); // OMG\n        _setAggregator(0x6F3B3286fd86d8b47EC737CEB3D0D354cc657B3e, AggregatorV3Interface(0x56D55D34EcC616e71ae998aCcba79F236ff2ff46)); // PAX\n        _setAggregator(0x553d3D295e0f695B9228246232eDF400ed3560B5, AggregatorV3Interface(0x0f6914d8e7e1214CDb3A4C6fbf729b75C69DF608)); // PAXG\n        _setAggregator(0xcB059C5573646047D6d88dDdb87B745C18161d3b, AggregatorV3Interface(0xC741F7752BAe936fCE97933b755884AF66fB69C1)); // POLY\n        _setAggregator(0xBbba073C31bF03b8ACf7c28EF0738DeCF3695683, AggregatorV3Interface(0x3D49406EDd4D52Fb7FFd25485f32E073b529C924)); // SAND\n        _setAggregator(0x50B728D8D964fd00C2d0AAD81718b71311feF68a, AggregatorV3Interface(0xbF90A5D9B6EE9019028dbFc2a9E50056d5252894)); // SNX\n        _setAggregator(0x6Bf2eb299E51Fc5DF30Dec81D9445dDe70e3F185, AggregatorV3Interface(0xd8F8a7a38A1ac326312000d0a0218BF3216BfAbB)); // SRM\n        _setAggregator(0x0b3F868E0BE5597D5DB7fEB59E1CADBb0fdDa50a, AggregatorV3Interface(0x49B0c695039243BBfEb8EcD054EB70061fd54aa0)); // SUSHI\n        _setAggregator(0xB46E0ae620EFd98516f49bb00263317096C114b2, AggregatorV3Interface(0x38611b09F8f2D520c14eA973765C225Bf57B9Eac)); // THETA\n        _setAggregator(0x2e1AD108fF1D8C782fcBbB89AAd783aC49586756, AggregatorV3Interface(0x7C5D415B64312D38c56B54358449d0a4058339d2)); // TUSD\n        _setAggregator(0x3066818837c5e6eD6601bd5a91B0762877A6B731, AggregatorV3Interface(0x33D9B1BAaDcF4b26ab6F8E83e9cb8a611B2B3956)); // UMA\n        _setAggregator(0xb33EaAd8d922B1083446DC23f610c2567fB5180f, AggregatorV3Interface(0xdf0Fb4e4F928d2dCB76f438575fDD8682386e13C)); // UNI\n        _setAggregator(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174, AggregatorV3Interface(0xfE4A8cc5b5B2366C1B58Bea3858e81843581b2F7)); // USDC\n        _setAggregator(0xc2132D05D31c914a87C6611C10748AEb04B58e8F, AggregatorV3Interface(0x0A6513e40db6EB1b165753AD52E80663aeA50545)); // USDT\n        _setAggregator(0x692597b009d13C4049a947CAB2239b7d6517875F, AggregatorV3Interface(0x2D455E55e8Ad3BA965E3e95e7AaB7dF1C671af19)); // UST\n        _setAggregator(0xDA537104D6A5edd53c6fBba9A898708E465260b6, AggregatorV3Interface(0x9d3A43c111E7b2C6601705D9fcF7a70c95b1dc55)); // YFI\n        _setAggregator(0x5559Edb74751A0edE9DeA4DC23aeE72cCA6bE3D5, AggregatorV3Interface(0x6EA4d89474d9410939d429B786208c74853A5B47)); // ZRX\n    }\n}\n"
    },
    "contracts/core/ChainlinkFeedPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol\";\nimport \"./ChainlinkPriceProvider.sol\";\nimport \"../libraries/OracleHelpers.sol\";\n\n/**\n * @title ChainLink's price provider that uses price feed (only available on Mainnet currently)\n * @dev This contract is more expensive (+ ~1.3k) than others contracts (that don't use feed)\n * because they get decimals during aggregator addition\n */\ncontract ChainlinkFeedPriceProvider is ChainlinkPriceProvider {\n    using SafeCast for int256;\n    using OracleHelpers for uint256;\n\n    address public constant USD = address(840); // Chainlink follows https://en.wikipedia.org/wiki/ISO_4217\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant BTC = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\n    FeedRegistryInterface public constant PRICE_FEED =\n        FeedRegistryInterface(0x47Fb2585D2C56Fe188D0E6ec628a38b74fCeeeDf);\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(address token_) public view override returns (uint256, uint256) {\n        // Chainlink price feed use ETH and BTC as token address\n        if (token_ == WETH) {\n            token_ = ETH;\n        } else if (token_ == WBTC) {\n            token_ = BTC;\n        }\n\n        (, int256 _price, , uint256 _lastUpdatedAt, ) = PRICE_FEED.latestRoundData(token_, USD);\n        return (_price.toUint256().scaleDecimal(PRICE_FEED.decimals(token_, USD), USD_DECIMALS), _lastUpdatedAt);\n    }\n}\n"
    },
    "contracts/core/ChainlinkAvalanchePriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./ChainlinkPriceProvider.sol\";\n\n/**\n * @title ChainLink's price provider for Avalanche network\n */\ncontract ChainlinkAvalanchePriceProvider is ChainlinkPriceProvider {\n    constructor() {\n        // Avalanche's aggregators: https://docs.chain.link/docs/avalanche-price-feeds/\n        _setAggregator(0x63a72806098Bd3D9520cC43356dD78afe5D386D9, AggregatorV3Interface(0x3CA13391E9fb38a75330fb28f8cc2eB3D9ceceED)); // AAVE.e\n        _setAggregator(0x2147EFFF675e4A4eE1C2f918d181cDBd7a8E208f, AggregatorV3Interface(0x7B0ca9A6D03FE0467A31Ca850f5bcA51e027B3aF)); // ALPHA.e\n        _setAggregator(0x027dbcA046ca156De9622cD1e2D907d375e53aa7, AggregatorV3Interface(0xcf667FB6Bd30c520A435391c50caDcDe15e5e12f)); // AMPL\n        _setAggregator(0x19860CCB0A68fd4213aB9D8266F7bBf05A8dDe98, AggregatorV3Interface(0x827f8a0dC5c943F7524Dda178E2e7F275AAd743f)); // BUSD.e\n        _setAggregator(0x249848BeCA43aC405b8102Ec90Dd5F22CA513c06, AggregatorV3Interface(0x7CF8A6090A9053B01F3DF4D4e6CfEdd8c90d9027)); // CRV.e\n        _setAggregator(0xd586E7F844cEa2F87f50152665BCbc2C279D8d70, AggregatorV3Interface(0x51D7180edA2260cc4F6e4EebB82FEF5c3c2B8300)); // DAI.e\n        _setAggregator(0x6e84a6216eA6dACC71eE8E6b0a5B7322EEbC0fDd, AggregatorV3Interface(0x02D35d3a8aC3e1626d3eE09A78Dd87286F5E8e3a)); // JOE\n        _setAggregator(0x5947BB275c521040051D82396192181b413227A3, AggregatorV3Interface(0x49ccd9ca821EfEab2b98c60dC60F518E765EDe9a)); // LINK.e\n        _setAggregator(0x130966628846BFd36ff31a822705796e8cb8C18D, AggregatorV3Interface(0x54EdAB30a7134A16a54218AE64C73e1DAf48a8Fb)); // MIM\n        _setAggregator(0x8729438EB15e2C8B576fCc6AeCdA6A148776C0F5, AggregatorV3Interface(0x36E039e6391A5E7A7267650979fdf613f659be5D)); // QI\n        _setAggregator(0xCE1bFFBD5374Dac86a2893119683F4911a2F7814, AggregatorV3Interface(0x4F3ddF9378a4865cf4f28BE51E10AECb83B7daeE)); // SPELL\n        _setAggregator(0x37B608519F91f70F2EeB0e5Ed9AF4061722e4F76, AggregatorV3Interface(0x449A373A090d8A1e5F74c63Ef831Ceff39E94563)); // SUSHI.e\n        _setAggregator(0x1C20E891Bab6b1727d14Da358FAe2984Ed9B59EB, AggregatorV3Interface(0x9Cf3Ef104A973b351B2c032AA6793c3A6F76b448)); // TUSD\n        _setAggregator(0x8eBAf22B6F053dFFeaf46f4Dd9eFA95D89ba8580, AggregatorV3Interface(0x9a1372f9b1B71B3A5a72E092AE67E172dBd7Daaa)); // UNI.e\n        _setAggregator(0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664, AggregatorV3Interface(0xF096872672F44d6EBA71458D74fe67F9a77a23B9)); // USDC.e\n        _setAggregator(0xc7198437980c041c805A1EDcbA50c1Ce5db95118, AggregatorV3Interface(0xEBE676ee90Fe1112671f19b6B7459bC678B67e8a)); // USDT.e\n        _setAggregator(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7, AggregatorV3Interface(0x0A77230d17318075983913bC2145DB16C7366156)); // WAVAX\n        _setAggregator(0x50b7545627a5162F82A992c33b87aDc75187B218, AggregatorV3Interface(0x2779D32d5166BAaa2B2b658333bA7e6Ec0C65743)); // WBTC.e\n        _setAggregator(0x49D5c2BdFfac6CE2BFdB6640F4F80f226bc10bAB, AggregatorV3Interface(0x976B3D034E162d8bD72D6b9C989d545b839003b0)); // WETH.e\n        _setAggregator(0xd1c3f94DE7e5B45fa4eDBBA472491a9f4B166FC4, AggregatorV3Interface(0x4Cf57DC9028187b9DAaF773c8ecA941036989238)); // XAVA\n        _setAggregator(0x9eAaC1B23d935365bD7b542Fe22cEEe2922f52dc, AggregatorV3Interface(0x28043B1Ebd41860B93EC1F1eC19560760B6dB556)); // YFI.e\n    }\n}\n"
    },
    "contracts/mock/ChainlinkOracleMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../interfaces/core/IChainlinkPriceProvider.sol\";\nimport \"../interfaces/periphery/IOracle.sol\";\n\ncontract ChainlinkOracleMock is IOracle {\n    IChainlinkPriceProvider public immutable chainlink;\n\n    constructor(IChainlinkPriceProvider chainlink_) {\n        chainlink = chainlink_;\n    }\n\n    function getPriceInUsd(address asset_) public view override returns (uint256 _priceInUsd) {\n        (_priceInUsd, ) = chainlink.getPriceInUsd(asset_);\n    }\n\n    function quote(\n        address, /*tokenIn_*/\n        address, /*tokenOut_*/\n        uint256 /*amountIn_*/\n    )\n        external\n        pure\n        returns (\n            uint256 /*_amountOut*/\n        )\n    {\n        revert(\"not-implemented\");\n    }\n\n    function quoteTokenToUsd(\n        address, /*token_*/\n        uint256 /*amountIn_*/\n    )\n        external\n        pure\n        returns (\n            uint256 /*amountOut_*/\n        )\n    {\n        revert(\"not-implemented\");\n    }\n\n    function quoteUsdToToken(\n        address, /*token_*/\n        uint256 /*amountIn_*/\n    )\n        external\n        pure\n        returns (\n            uint256 /*_amountOut*/\n        )\n    {\n        revert(\"not-implemented\");\n    }\n}\n"
    },
    "contracts/core/ChainlinkArbitrumPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./ChainlinkPriceProvider.sol\";\n\n/**\n * @title ChainLink's price provider for Arbitrum network\n */\ncontract ChainlinkArbitrumPriceProvider is ChainlinkPriceProvider {\n    constructor() {\n        // Arbitrum's aggregators: https://docs.chain.link/docs/arbitrum-price-feeds/\n        _setAggregator(0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f, AggregatorV3Interface(0x6ce185860a4963106506C203335A2910413708e9)); // WBTC\n        _setAggregator(0x11cDb42B0EB46D95f990BeDD4695A6e3fA034978, AggregatorV3Interface(0xaebDA2c976cfd1eE1977Eac079B4382acb849325)); // CRV\n        _setAggregator(0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1, AggregatorV3Interface(0xc5C8E77B397E531B8EC06BFb0048328B30E9eCfB)); // DAI\n        _setAggregator(0x69Eb4FA4a2fbd498C257C57Ea8b7655a2559A581, AggregatorV3Interface(0xA33a06c119EC08F92735F9ccA37e07Af08C4f281)); // DODO\n        _setAggregator(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1, AggregatorV3Interface(0x639Fe6ab55C921f74e7fac1ee960C0B6293ba612)); // WETH\n        _setAggregator(0x17FC002b466eEc40DaE837Fc4bE5c67993ddBd6F, AggregatorV3Interface(0x0809E3d38d1B4214958faf06D8b1B1a2b73f2ab8)); // FRAX\n        _setAggregator(0x9d2F299715D94d8A7E6F5eaa8E654E8c74a988A7, AggregatorV3Interface(0x36a121448D74Fa81450c992A1a44B9b7377CD3a5)); // FXS\n        _setAggregator(0xf97f4df75117a78c1A5a0DBb814Af92458539FB4, AggregatorV3Interface(0x86E53CF1B870786351Da77A57575e79CB55812CB)); // LINK\n        _setAggregator(0x1A4dA80967373fd929961e976b4b53ceeC063a15, AggregatorV3Interface(0x81a065E74943A8B6380C23f8b440Aea1Dc3530cA)); // LUNA\n        _setAggregator(0xFEa7a6a0B346362BF88A9e4A88416B77a57D6c2A, AggregatorV3Interface(0x87121F6c9A9F6E90E59591E4Cf4804873f54A95b)); // MIM\n        _setAggregator(0x3E6648C5a70A150A88bCE65F4aD4d506Fe15d2AF, AggregatorV3Interface(0x383b3624478124697BEF675F07cA37570b73992f)); // SPELL\n        _setAggregator(0xd4d42F0b6DEF4CE0383636770eF773390d85c61A, AggregatorV3Interface(0xb2A8BA74cbca38508BA1632761b56C897060147C)); // SUSHI\n        _setAggregator(0xFa7F8980b0f1E64A2062791cc3b0871572f1F7f0, AggregatorV3Interface(0x9C917083fDb403ab5ADbEC26Ee294f6EcAda2720)); // UNI\n        _setAggregator(0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8, AggregatorV3Interface(0x50834F3163758fcC1Df9973b6e91f0F0F0434aD3)); // USDC\n        _setAggregator(0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9, AggregatorV3Interface(0x3f3f5dF88dC9F13eac63DF89EC16ef6e7E25DdE7)); // USDT\n        _setAggregator(0x82e3A8F066a6989666b031d916c43672085b1582, AggregatorV3Interface(0x745Ab5b69E01E2BE1104Ca84937Bb71f96f5fB21)); // YFI\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/mock/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ERC20Mock is ERC20 {\n    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {\n        _mint(msg.sender, 1_000_000 * 1e18);\n    }\n}\n"
    },
    "contracts/interfaces/external/aave/IAToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IAToken is IERC20 {\n    function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n}\n"
    },
    "contracts/periphery/tokens/ATokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../interfaces/external/aave/IAToken.sol\";\nimport \"../../interfaces/periphery/IOracle.sol\";\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\n\n/**\n * @title Oracle for `ATokens`\n */\ncontract ATokenOracle is ITokenOracle {\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address _asset) external view returns (uint256 _priceInUsd) {\n        // Note: `msg.sender` is the `MasterOracle` contract\n        return IOracle(msg.sender).getPriceInUsd(IAToken(_asset).UNDERLYING_ASSET_ADDRESS());\n    }\n}\n"
    },
    "contracts/periphery/tokens/CTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../interfaces/external/compound/ICToken.sol\";\nimport \"../../interfaces/periphery/IOracle.sol\";\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\n\n/**\n * @title Oracle for `CTokens`\n */\ncontract CTokenOracle is ITokenOracle {\n    uint256 public constant ONE_CTOKEN = 1e8;\n\n    /**\n     * @notice The address of the `CEther` underlying (Usually WETH)\n     */\n    address public immutable wethLike;\n\n    constructor(address _wethLike) {\n        require(_wethLike != address(0), \"weth-like-null\");\n        wethLike = _wethLike;\n    }\n\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address _asset) external view returns (uint256 _priceInUsd) {\n        address _underlyingAddress;\n        // Note: Compound's `CEther` hasn't the `underlying()` function, forks may return `address(0)` (e.g. RariFuse)\n        try ICToken(_asset).underlying() returns (address _underlying) {\n            _underlyingAddress = _underlying;\n        } catch {}\n\n        if (_underlyingAddress == address(0)) {\n            _underlyingAddress = wethLike;\n        }\n        uint256 _underlyingPriceInUsd = IOracle(msg.sender).getPriceInUsd(_underlyingAddress);\n        uint256 _underlyingAmount = (ONE_CTOKEN * ICToken(_asset).exchangeRateStored()) / 1e18;\n        _priceInUsd = (_underlyingPriceInUsd * _underlyingAmount) / 10**IERC20Metadata(_underlyingAddress).decimals();\n    }\n}\n"
    },
    "contracts/interfaces/external/compound/ICToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ICToken {\n    function exchangeRateStored() external view returns (uint256);\n\n    function underlying() external view returns (address);\n}\n"
    },
    "contracts/periphery/ChainlinkOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/periphery/IOracle.sol\";\nimport \"../features/UsingStalePeriod.sol\";\n\n/**\n * @title Chainlink oracle\n */\ncontract ChainlinkOracle is IOracle, UsingStalePeriod {\n    constructor(uint256 stalePeriod_) UsingStalePeriod(stalePeriod_) {}\n\n    /// @inheritdoc IOracle\n    function getPriceInUsd(address token_) public view virtual returns (uint256 _priceInUsd) {\n        uint256 _lastUpdatedAt;\n        (_priceInUsd, _lastUpdatedAt) = addressProvider.providersAggregator().getPriceInUsd(\n            DataTypes.Provider.CHAINLINK,\n            token_\n        );\n        require(_priceInUsd > 0 && !_priceIsStale(_lastUpdatedAt), \"price-invalid\");\n    }\n\n    /// @inheritdoc IOracle\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) public view virtual returns (uint256 _amountOut) {\n        uint256 _lastUpdatedAt;\n        (_amountOut, _lastUpdatedAt) = addressProvider.providersAggregator().quote(\n            DataTypes.Provider.CHAINLINK,\n            tokenIn_,\n            tokenOut_,\n            amountIn_\n        );\n        require(_amountOut > 0 && !_priceIsStale(_lastUpdatedAt), \"price-invalid\");\n    }\n\n    /// @inheritdoc IOracle\n    function quoteTokenToUsd(address token_, uint256 amountIn_) public view virtual returns (uint256 _amountOut) {\n        uint256 _lastUpdatedAt;\n        (_amountOut, _lastUpdatedAt) = addressProvider.providersAggregator().quoteTokenToUsd(\n            DataTypes.Provider.CHAINLINK,\n            token_,\n            amountIn_\n        );\n        require(_amountOut > 0 && !_priceIsStale(_lastUpdatedAt), \"price-invalid\");\n    }\n\n    /// @inheritdoc IOracle\n    function quoteUsdToToken(address token_, uint256 amountIn_) public view virtual returns (uint256 _amountOut) {\n        uint256 _lastUpdatedAt;\n        (_amountOut, _lastUpdatedAt) = addressProvider.providersAggregator().quoteUsdToToken(\n            DataTypes.Provider.CHAINLINK,\n            token_,\n            amountIn_\n        );\n        require(_amountOut > 0 && !_priceIsStale(_lastUpdatedAt), \"price-invalid\");\n    }\n}\n"
    },
    "contracts/mock/UsingStalePeriodMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../features/UsingStalePeriod.sol\";\n\ncontract UsingStalePeriodMock is UsingStalePeriod {\n    constructor(uint256 stalePeriod_) UsingStalePeriod(stalePeriod_) {}\n\n    function priceIsStale(uint256 timeOfLastUpdate_, uint256 stalePeriod_) external view returns (bool) {\n        return _priceIsStale(timeOfLastUpdate_, stalePeriod_);\n    }\n}\n"
    },
    "contracts/mock/UsingMaxDeviationMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../features/UsingMaxDeviation.sol\";\n\ncontract UsingMaxDeviationMock is UsingMaxDeviation {\n    constructor(uint256 maxDeviation_) UsingMaxDeviation(maxDeviation_) {}\n\n    function isDeviationOK(uint256 a_, uint256 b_) external view returns (bool) {\n        return _isDeviationOK(a_, b_);\n    }\n}\n"
    },
    "contracts/periphery/tokens/SynthUsdTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\n\n/**\n * @title Oracle for USD hard pegged token\n * @dev This oracle shouldn't be used for stable coins! Its purpose is for a specific use case that's the Synth USD token.\n */\ncontract SynthUsdTokenOracle is ITokenOracle {\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address) external pure override returns (uint256 _priceInUsd) {\n        return 1e18;\n    }\n}\n"
    },
    "contracts/periphery/tokens/IbBtcTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../interfaces/periphery/IOracle.sol\";\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\nimport \"../../interfaces/external/badger/IXToken.sol\";\n\n/**\n * @title Oracle for ibBTC token\n */\ncontract IbBtcTokenOracle is ITokenOracle {\n    IXToken public constant IBBTC = IXToken(0xc4E15973E6fF2A35cC804c2CF9D2a1b817a8b40F);\n    IXToken public constant WIBBTC = IXToken(0x8751D4196027d4e6DA63716fA7786B5174F04C15);\n\n    /// @notice BTC/USD oracle\n    ITokenOracle public immutable btcOracle;\n\n    constructor(ITokenOracle btcOracle_) {\n        btcOracle = btcOracle_;\n    }\n\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address token_) external view override returns (uint256 _priceInUsd) {\n        if (token_ == address(IBBTC)) {\n            return (btcOracle.getPriceInUsd(address(0)) * IBBTC.pricePerShare()) / 1e18;\n        }\n        if (token_ == address(WIBBTC)) {\n            return (btcOracle.getPriceInUsd(address(0)) * IBBTC.pricePerShare()) / WIBBTC.pricePerShare();\n        }\n\n        revert(\"invalid-ibbtc-related-token\");\n    }\n}\n"
    },
    "contracts/interfaces/external/badger/IXToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IXToken {\n    function pricePerShare() external view returns (uint256);\n}\n"
    },
    "contracts/periphery/tokens/CurveLpTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\nimport \"../../interfaces/external/curve/ICurveAddressProvider.sol\";\nimport \"../../interfaces/external/curve/ICurveRegistry.sol\";\nimport \"../../interfaces/external/curve/ICurvePool.sol\";\nimport \"../../interfaces/periphery/IOracle.sol\";\nimport \"../../access/Governable.sol\";\n\n/**\n * @title Oracle for Curve LP tokens\n */\ncontract CurveLpTokenOracle is ITokenOracle, Governable {\n    address private constant SBTC_POOL = 0x7fC77b5c7614E1533320Ea6DDc2Eb61fa00A9714;\n\n    /// @dev Same address for all chains\n    ICurveAddressProvider public constant curveAddressProvider =\n        ICurveAddressProvider(0x0000000022D53366457F9d5E68Ec105046FC4383);\n\n    /// @notice Registry contract\n    ICurveRegistry public immutable registry;\n\n    /// @notice LP token => coins mapping\n    mapping(address => address[]) public underlyingTokens;\n\n    /// @notice LP token => pool\n    mapping(address => address) public poolOf;\n\n    /// @notice Emitted when a token is registered\n    event LpRegistered(address indexed lpToken, bool isLending);\n\n    constructor() {\n        registry = ICurveRegistry(curveAddressProvider.get_registry());\n    }\n\n    /// @inheritdoc ITokenOracle\n    /// @dev This function is supposed to be called from `MasterOracle` only\n    function getPriceInUsd(address lpToken_) public view override returns (uint256 _priceInUsd) {\n        address _pool = poolOf[lpToken_];\n        require(_pool != address(0), \"lp-is-not-registered\");\n        address[] memory _tokens = underlyingTokens[lpToken_];\n        uint256 _min = type(uint256).max;\n        uint256 _n = _tokens.length;\n\n        for (uint256 i; i < _n; i++) {\n            // Note: `msg.sender` is the `MasterOracle` contract\n            uint256 _price = IOracle(msg.sender).getPriceInUsd(_tokens[i]);\n            if (_price < _min) _min = _price;\n        }\n\n        require(_min < type(uint256).max, \"no-min-underlying-price-found\");\n        require(_min > 0, \"invalid-min-price\");\n\n        return (_min * ICurvePool(_pool).get_virtual_price()) / 1e18;\n    }\n\n    /// @notice Register LP token data\n    function registerLp(address lpToken_) external onlyGovernor {\n        _registerLp(lpToken_, false);\n    }\n\n    /// @notice Register LP token data\n    function registerLendingLp(address lpToken_) external onlyGovernor {\n        _registerLp(lpToken_, true);\n    }\n\n    /// @notice Register LP token data\n    function _registerLp(address lpToken_, bool isLending_) private {\n        address _pool = registry.get_pool_from_lp_token(lpToken_);\n        require(_pool != address(0), \"invalid-non-factory-lp\");\n\n        address[8] memory _tokens;\n        if (isLending_) {\n            _tokens = registry.get_underlying_coins(_pool);\n        } else {\n            _tokens = registry.get_coins(_pool);\n        }\n\n        if (poolOf[lpToken_] != address(0)) {\n            // Clean current tokens if LP exists\n            delete underlyingTokens[lpToken_];\n        }\n\n        poolOf[lpToken_] = _pool;\n\n        uint256 _n = registry.get_n_coins(_pool);\n        for (uint256 i; i < _n; i++) {\n            underlyingTokens[lpToken_].push(_tokens[i]);\n        }\n\n        emit LpRegistered(lpToken_, isLending_);\n    }\n}\n"
    },
    "contracts/interfaces/external/curve/ICurveAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./ICurveRegistry.sol\";\n\ninterface ICurveAddressProvider {\n    function get_registry() external view returns (ICurveRegistry);\n\n    function get_address(uint256 i) external view returns (address);\n}\n"
    },
    "contracts/interfaces/external/curve/ICurveRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ICurveRegistry {\n    function get_n_coins(address lp) external view returns (uint256);\n\n    function get_coins(address pool) external view returns (address[8] memory);\n\n    function get_underlying_coins(address pool) external view returns (address[8] memory);\n\n    function get_pool_from_lp_token(address lp) external view returns (address);\n\n    function is_meta(address pool) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/external/curve/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ICurvePool {\n    function get_virtual_price() external view returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 min_amount\n    ) external;\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external returns (uint256);\n}\n"
    },
    "contracts/periphery/tokens/CurveFactoryLpTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\nimport \"../../interfaces/external/curve/ICurveAddressProvider.sol\";\nimport \"../../interfaces/external/curve/ICurveFactoryRegistry.sol\";\nimport \"../../interfaces/external/curve/ICurvePool.sol\";\nimport \"../../interfaces/periphery/IOracle.sol\";\n\n/**\n * @title Oracle for Curve LP tokens (Factory Pools)\n */\ncontract CurveFactoryLpTokenOracle is ITokenOracle {\n    /// @dev Same address for all chains\n    ICurveAddressProvider public constant addressProvider =\n        ICurveAddressProvider(0x0000000022D53366457F9d5E68Ec105046FC4383);\n\n    /// @notice Factory Registry contract\n    ICurveFactoryRegistry public immutable registry;\n\n    /// @notice LP token => coins mapping\n    mapping(address => address[]) public underlyingTokens;\n\n    /// @notice Emitted when a token is registered\n    event LpRegistered(address indexed lpToken);\n\n    constructor() {\n        registry = ICurveFactoryRegistry(addressProvider.get_address(3));\n    }\n\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address lpToken_) public view override returns (uint256 _priceInUsd) {\n        address[] memory _tokens = underlyingTokens[lpToken_];\n        require(_tokens.length > 0, \"lp-is-not-registered\");\n        uint256 _min = type(uint256).max;\n        uint256 _n = _tokens.length;\n\n        for (uint256 i; i < _n; i++) {\n            uint256 _price = IOracle(msg.sender).getPriceInUsd(_tokens[i]);\n            if (_price < _min) _min = _price;\n        }\n\n        require(_min < type(uint256).max, \"no-min-underlying-price-found\");\n        require(_min > 0, \"invalid-min-price\");\n\n        return (_min * ICurvePool(lpToken_).get_virtual_price()) / 1e18;\n    }\n\n    /// @notice Register LP token data\n    /// @dev For factory pools, the LP and pool addresses are the same\n    function registerLp(address lpToken_) external {\n        require(underlyingTokens[lpToken_].length == 0, \"lp-already-registered\");\n\n        uint256 _n = registry.get_n_coins(lpToken_);\n        if (_n == 0) (_n, ) = registry.get_meta_n_coins(lpToken_);\n        require(_n > 0, \"invalid-factory-lp-token\");\n\n        address[4] memory _tokens = registry.get_coins(lpToken_);\n        for (uint256 i; i < _n; i++) {\n            underlyingTokens[lpToken_].push(_tokens[i]);\n        }\n\n        emit LpRegistered(lpToken_);\n    }\n}\n"
    },
    "contracts/interfaces/external/curve/ICurveFactoryRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ICurveFactoryRegistry {\n    function get_n_coins(address lp) external view returns (uint256);\n\n    function get_coins(address pool) external view returns (address[4] memory);\n\n    function get_meta_n_coins(address pool) external view returns (uint256, uint256);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 5000
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}