{
  "language": "Solidity",
  "sources": {
    "contracts/access/Governable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/core/IAddressProvider.sol\";\n\n/**\n * @notice Contract module which provides access control mechanism, where\n * the governor account is granted with exclusive access to specific functions.\n * @dev Uses the AddressProvider to get the governor\n */\nabstract contract Governable {\n    IAddressProvider public constant addressProvider = IAddressProvider(0xfbA0816A81bcAbBf3829bED28618177a2bf0e82A);\n\n    /// @dev Throws if called by any account other than the governor.\n    modifier onlyGovernor() {\n        require(msg.sender == addressProvider.governor(), \"not-governor\");\n        _;\n    }\n}\n"
    },
    "contracts/interfaces/core/IAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./IStableCoinProvider.sol\";\nimport \"./IPriceProvidersAggregator.sol\";\n\ninterface IAddressProvider {\n    function governor() external view returns (address);\n\n    function providersAggregator() external view returns (IPriceProvidersAggregator);\n\n    function stableCoinProvider() external view returns (IStableCoinProvider);\n}\n"
    },
    "contracts/interfaces/core/IStableCoinProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IStableCoinProvider {\n    /**\n     * @notice Return the stable coin if pegged\n     * @dev Check price relation between both stable coins and revert if peg is too loose\n     * @return _stableCoin The primary stable coin if pass all checks\n     */\n    function getStableCoinIfPegged() external view returns (address _stableCoin);\n\n    /**\n     * @notice Convert given amount of stable coin to USD representation (18 decimals)\n     */\n    function toUsdRepresentation(uint256 stableCoinAmount_) external view returns (uint256 _usdAmount);\n}\n"
    },
    "contracts/interfaces/core/IPriceProvidersAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../libraries/DataTypes.sol\";\nimport \"./IPriceProvider.sol\";\n\n/**\n * @notice PriceProvidersAggregator interface\n * @dev Worth noting that the `_lastUpdatedAt` logic depends on the underlying price provider. In summary:\n * ChainLink: returns the last updated date from the aggregator\n * UniswapV2: returns the date of the latest pair oracle update\n * UniswapV3: assumes that the price is always updated (returns block.timestamp)\n * Flux: returns the last updated date from the aggregator\n * Umbrella (FCD): returns the last updated date returned from their oracle contract\n * Umbrella (Passport): returns the date of the latest pallet submission\n * Anytime that a quote performs more than one query, it uses the oldest date as the `_lastUpdatedAt`.\n * See more: https://github.com/bloqpriv/one-oracle/issues/64\n */\ninterface IPriceProvidersAggregator {\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param provider_ The price provider to get quote from\n     * @param token_ The address of asset\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(DataTypes.Provider provider_, address token_)\n        external\n        view\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Provider Providers' mapping\n     */\n    function priceProviders(DataTypes.Provider provider_) external view returns (IPriceProvider _priceProvider);\n\n    /**\n     * @notice Get quote\n     * @param provider_ The price provider to get quote from\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        DataTypes.Provider provider_,\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote\n     * @dev If providers aren't the same, uses native token as \"bridge\"\n     * @param providerIn_ The price provider to get quote for the tokenIn\n     * @param tokenIn_ The address of assetIn\n     * @param providerOut_ The price provider to get quote for the tokenOut\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _nativeTokenLastUpdatedAt Last updated timestamp of native token (i.e. WETH) used when providers aren't the same\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        DataTypes.Provider providerIn_,\n        address tokenIn_,\n        DataTypes.Provider providerOut_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _nativeTokenLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param provider_ The price provider to get quote from\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(\n        DataTypes.Provider provider_,\n        address token_,\n        uint256 amountIn_\n    ) external view returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param provider_ The price provider to get quote from\n     * @param token_ The address of assetOut\n     * @param amountIn_ Input amount in USD\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(\n        DataTypes.Provider provider_,\n        address token_,\n        uint256 amountIn_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Set a price provider\n     * @dev Administrative function\n     * @param provider_ The provider (from enum)\n     * @param priceProvider_ The price provider contract\n     */\n    function setPriceProvider(DataTypes.Provider provider_, IPriceProvider priceProvider_) external;\n}\n"
    },
    "contracts/libraries/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nlibrary DataTypes {\n    /**\n     * @notice Price providers enumeration\n     */\n    enum Provider {\n        NONE,\n        CHAINLINK,\n        UNISWAP_V3,\n        UNISWAP_V2,\n        SUSHISWAP,\n        TRADERJOE,\n        PANGOLIN,\n        QUICKSWAP,\n        UMBRELLA_FIRST_CLASS,\n        UMBRELLA_PASSPORT,\n        FLUX\n    }\n\n    enum ExchangeType {\n        UNISWAP_V2,\n        SUSHISWAP,\n        TRADERJOE,\n        PANGOLIN,\n        QUICKSWAP,\n        UNISWAP_V3,\n        PANCAKE_SWAP,\n        CURVE\n    }\n\n    enum SwapType {\n        EXACT_INPUT,\n        EXACT_OUTPUT\n    }\n}\n"
    },
    "contracts/interfaces/core/IPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IPriceProvider {\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of asset\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(address token_) external view returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(address token_, uint256 amountIn_)\n        external\n        view\n        returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetOut\n     * @param amountIn_ Input amount in USD\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(address token_, uint256 amountIn_)\n        external\n        view\n        returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n}\n"
    },
    "contracts/swapper/UniswapV2LikeExchange.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../dependencies/uniswap/libraries/UniswapV2Library.sol\";\nimport \"../access/Governable.sol\";\nimport \"../interfaces/swapper/IExchange.sol\";\n\n/**\n * @notice UniswapV2 Like Exchange\n */\ncontract UniswapV2LikeExchange is IExchange, Governable {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice The WETH-Like token (a.k.a. Native Token)\n     * @dev I.e. should be the most liquid token that offer best routers among trade pairs\n     * @dev It's usually the wrapper token of the chain's native coin but it isn't always true\n     * For instance: On Polygon, the `WETH` is more liquid than `WMATIC` on UniV3 protocol.\n     */\n    address public wethLike;\n\n    /**\n     * @notice The UniswapV2-Like factory contract\n     */\n    address public immutable factory;\n\n    bytes32 internal immutable initCodeHash;\n    /// @notice Emitted when wethLike token is updated\n    event WethLikeTokenUpdated(address oldWethLike, address newWethLike);\n\n    /**\n     * @dev Doesn't consider router.WETH() as `wethLike` because isn't guaranteed that it's the most liquid token.\n     */\n    constructor(\n        address factory_,\n        bytes32 initCodeHash_,\n        address wethLike_\n    ) {\n        factory = factory_;\n        initCodeHash = initCodeHash_;\n        wethLike = wethLike_;\n    }\n\n    /// @inheritdoc IExchange\n    function getAmountsIn(uint256 amountOut_, bytes memory path_) external view override returns (uint256 _amountIn) {\n        _amountIn = getAmountsIn(amountOut_, _decodePath(path_));\n    }\n\n    /// @inheritdoc IExchange\n    function getAmountsOut(uint256 amountIn_, bytes memory path_) external view override returns (uint256 _amountOut) {\n        _amountOut = getAmountsOut(amountIn_, _decodePath(path_));\n    }\n\n    /**\n     * @dev getBestAmountIn require a try/catch version of getAmountsIn and try/catch do not work with internal\n     * library functions, hence wrapped library call in this function so that it can be used in try/catch\n     */\n    function getAmountsIn(uint256 amountOut_, address[] memory path_) public view returns (uint256 _amountIn) {\n        _amountIn = UniswapV2Library.getAmountsIn(factory, initCodeHash, amountOut_, path_)[0];\n    }\n\n    /**\n     * @dev getBestAmountOut require a try/catch version of getAmountsOut and try/catch do not work with internal\n     * library functions, hence wrapped library call in this function so that it can be used in try/catch\n     */\n    function getAmountsOut(uint256 amountIn_, address[] memory path_) public view returns (uint256 _amountOut) {\n        _amountOut = UniswapV2Library.getAmountsOut(factory, initCodeHash, amountIn_, path_)[path_.length - 1];\n    }\n\n    /// @inheritdoc IExchange\n    function getBestAmountIn(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountOut_\n    ) external returns (uint256 _amountIn, bytes memory _path) {\n        // 1. Check IN-OUT pair\n        address[] memory _pathA = new address[](2);\n        _pathA[0] = tokenIn_;\n        _pathA[1] = tokenOut_;\n        uint256 _amountInA = _getAmountsIn(amountOut_, _pathA);\n\n        if (tokenIn_ == wethLike || tokenOut_ == wethLike) {\n            // Returns if one of the token is WETH-Like\n            require(_amountInA > 0, \"no-path-found\");\n            return (_amountInA, _encodePath(_pathA));\n        }\n\n        // 2. Check IN-WETH-OUT path\n        address[] memory _pathB = new address[](3);\n        _pathB[0] = tokenIn_;\n        _pathB[1] = wethLike;\n        _pathB[2] = tokenOut_;\n        uint256 _amountInB = _getAmountsIn(amountOut_, _pathB);\n\n        // 3. Get best route between paths A and B\n        require(_amountInA > 0 || _amountInB > 0, \"no-path-found\");\n\n        // Returns A if it's valid and better than B or if B isn't valid\n        if ((_amountInA > 0 && _amountInA < _amountInB) || _amountInB == 0) {\n            return (_amountInA, _encodePath(_pathA));\n        }\n        return (_amountInB, _encodePath(_pathB));\n    }\n\n    /// @inheritdoc IExchange\n    function getBestAmountOut(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external returns (uint256 _amountOut, bytes memory _path) {\n        // 1. Check IN-OUT pair\n        address[] memory _pathA = new address[](2);\n        _pathA[0] = tokenIn_;\n        _pathA[1] = tokenOut_;\n        uint256 _amountOutA = _getAmountsOut(amountIn_, _pathA);\n\n        if (tokenIn_ == wethLike || tokenOut_ == wethLike) {\n            // Returns if one of the token is WETH-Like\n            require(_amountOutA > 0, \"no-path-found\");\n            return (_amountOutA, _encodePath(_pathA));\n        }\n\n        // 2. Check IN-WETH-OUT path\n        address[] memory _pathB = new address[](3);\n        _pathB[0] = tokenIn_;\n        _pathB[1] = wethLike;\n        _pathB[2] = tokenOut_;\n        uint256 _amountOutB = _getAmountsOut(amountIn_, _pathB);\n\n        // 3. Get best route between paths A and B\n        require(_amountOutA > 0 || _amountOutB > 0, \"no-path-found\");\n        if (_amountOutA > _amountOutB) return (_amountOutA, _encodePath(_pathA));\n        return (_amountOutB, _encodePath(_pathB));\n    }\n\n    /// @inheritdoc IExchange\n    function swapExactInput(\n        bytes calldata path_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address outReceiver_\n    ) external returns (uint256 _amountOut) {\n        address[] memory _path = _decodePath(path_);\n        IERC20 _tokenIn = IERC20(_path[0]);\n        IERC20 _tokenOut = IERC20(_path[_path.length - 1]);\n\n        _tokenIn.safeTransfer(UniswapV2Library.pairFor(factory, initCodeHash, _path[0], _path[1]), amountIn_);\n        uint256 balanceBefore = _tokenOut.balanceOf(outReceiver_);\n        _swap(_path, outReceiver_);\n        _amountOut = _tokenOut.balanceOf(outReceiver_) - balanceBefore;\n        require(_amountOut >= amountOutMin_, \"Too little received\");\n    }\n\n    /// @inheritdoc IExchange\n    function swapExactOutput(\n        bytes calldata path_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address inSender_,\n        address outRecipient_\n    ) external returns (uint256 _amountIn) {\n        address[] memory _path = _decodePath(path_);\n        IERC20 _tokenIn = IERC20(_path[0]);\n\n        _amountIn = UniswapV2Library.getAmountsIn(factory, initCodeHash, amountOut_, _path)[0];\n        require(_amountIn <= amountInMax_, \"Too much requested\");\n\n        _tokenIn.safeTransfer(UniswapV2Library.pairFor(factory, initCodeHash, _path[0], _path[1]), _amountIn);\n        _swap(_path, outRecipient_);\n\n        // If swap end up costly less than _amountInMax then return remaining\n        uint256 _remainingAmountIn = amountInMax_ - _amountIn;\n        if (_remainingAmountIn > 0) {\n            _tokenIn.safeTransfer(inSender_, _remainingAmountIn);\n        }\n    }\n\n    /// @dev Returns `0` if reverts\n    function _getAmountsIn(uint256 _amountOut, address[] memory _path) internal view returns (uint256 _amountIn) {\n        try this.getAmountsIn(_amountOut, _path) returns (uint256 amountIn) {\n            _amountIn = amountIn;\n        } catch {}\n    }\n\n    /// @dev Returns `0` if reverts\n    function _getAmountsOut(uint256 amountIn_, address[] memory path_) internal view returns (uint256 _amountOut) {\n        try this.getAmountsOut(amountIn_, path_) returns (uint256 amountOut) {\n            _amountOut = amountOut;\n        } catch {}\n    }\n\n    /**\n     * @notice Encode path from `address[]` to `bytes`\n     */\n    function _encodePath(address[] memory path_) private pure returns (bytes memory _path) {\n        return abi.encode(path_);\n    }\n\n    /**\n     * @notice Encode path from `bytes` to `address[]`\n     */\n    function _decodePath(bytes memory path_) private pure returns (address[] memory _path) {\n        return abi.decode(path_, (address[]));\n    }\n\n    /**\n     * NOTICE:: This function is being used as is from Uniswap's V2SwapRouter.sol deployed\n     * at 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45 and licensed under GPL-2.0-or-later.\n     * - It does supports fee-on-transfer tokens\n     * - It does requires the initial amount to have already been sent to the first pair\n     */\n    function _swap(address[] memory path, address _to) private {\n        for (uint256 i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0, ) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, initCodeHash, input, output));\n            uint256 amountInput;\n            uint256 amountOutput;\n            // scope to avoid stack too deep errors\n            {\n                (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n                (uint256 reserveInput, uint256 reserveOutput) = input == token0\n                    ? (reserve0, reserve1)\n                    : (reserve1, reserve0);\n                amountInput = IERC20(input).balanceOf(address(pair)) - reserveInput;\n                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\n                ? (uint256(0), amountOutput)\n                : (amountOutput, uint256(0));\n            address to = i < path.length - 2\n                ? UniswapV2Library.pairFor(factory, initCodeHash, output, path[i + 2])\n                : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    /**\n     * @notice Update WETH-Like token\n     */\n    function updateWethLikeToken(address wethLike_) external onlyGovernor {\n        emit WethLikeTokenUpdated(wethLike, wethLike_);\n        wethLike = wethLike_;\n    }\n}\n"
    },
    "contracts/dependencies/uniswap/libraries/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport '@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol';\n\n/**\n * This is copied from Uniswap's V2SwapRouter.sol deployed at 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45\n * and licensed under GPL-2.0-or-later.\n * Changelog:\n * - Removed hardcoded initCodeHash and taking as param so that we can support multiple UniswapV2Like exchanges\n * - Added function getAmountsOut()\n */\nlibrary UniswapV2Library {\n    using LowGasSafeMath for uint256;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB);\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0));\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint160\n        (uint256(keccak256(abi.encodePacked(\n                hex'ff',\n                factory,\n                keccak256(abi.encodePacked(token0, token1)),\n                initCodeHash\n            )))));\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address factory,\n        bytes32 initCodeHash,\n        address tokenA,\n        address tokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, initCodeHash, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(amountIn > 0, 'INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0);\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        require(amountOut > 0, 'INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0);\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n        // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address factory,\n        bytes32 initCodeHash,\n        uint amountIn,\n        address[] memory path\n    ) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2);\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; i++) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, initCodeHash, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address factory,\n        bytes32 initCodeHash,\n        uint256 amountOut,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2);\n        amounts = new uint256[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory,initCodeHash, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/swapper/IExchange.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity <=0.8.9;\n\n/**\n * @notice Exchange interface\n */\ninterface IExchange {\n    /**\n     * @notice Get *spot* quote\n     * It will return the swap amount based on the current reserves of the given path (i.e. spot price)\n     * @dev It shouldn't be used as oracle!!!\n     */\n    function getAmountsIn(uint256 _amountOut, bytes memory path_) external returns (uint256 _amountIn);\n\n    /**\n     * @notice Get *spot* quote\n     * It will return the swap amount based on the current reserves of the given path (i.e. spot price)\n     * @dev It shouldn't be used as oracle!!!\n     */\n    function getAmountsOut(uint256 amountIn_, bytes memory path_) external returns (uint256 _amountOut);\n\n    /**\n     * @notice Get *spot* quote\n     * It will return the swap amount based on the current reserves of the best pair/path found (i.e. spot price)\n     * @dev It shouldn't be used as oracle!!!\n     */\n    function getBestAmountIn(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountOut_\n    ) external returns (uint256 _amountIn, bytes memory _path);\n\n    /**\n     * @notice Get *spot* quote\n     * It will return the swap amount based on the current reserves of the best pair/path found (i.e. spot price)\n     * @dev It shouldn't be used as oracle!!!\n     */\n    function getBestAmountOut(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external returns (uint256 _amountOut, bytes memory _path);\n\n    /**\n     * @notice Perform an exact input swap\n     * @dev Should transfer `amountIn_` before performing swap\n     */\n    function swapExactInput(\n        bytes calldata path_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address outReceiver_\n    ) external returns (uint256 _amountOut);\n\n    /**\n     * @notice Perform an exact output swap\n     * @dev Should transfer `amountInMax_` before performing swap\n     * @dev Sends swap remains - if any - to the `inSender_`\n     */\n    function swapExactOutput(\n        bytes calldata path_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address inSender_,\n        address outRecipient_\n    ) external returns (uint256 _amountIn);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.0;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary LowGasSafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y);\n    }\n\n    /// @notice Returns x + y, reverts if overflows or underflows\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x + y) >= x == (y >= 0));\n    }\n\n    /// @notice Returns x - y, reverts if overflows or underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x - y) <= x == (y >= 0));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/swapper/Swapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../access/Governable.sol\";\nimport \"../libraries/DataTypes.sol\";\nimport \"./SwapperStorage.sol\";\n\n/**\n * @notice Swapper contract\n * This contract encapsulates DEXes and use them to perform swaps using the best trade path as possible\n */\ncontract Swapper is Initializable, Governable, SwapperStorage {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Emitted when an exchange is added\n    event ExchangeUpdated(\n        DataTypes.ExchangeType indexed exchangeType,\n        address indexed oldExchange,\n        address indexed newExchange\n    );\n\n    /// @notice Emitted when an exchanges to loop over are updated\n    event ExchangeAsMainUpdated(DataTypes.ExchangeType indexed exchangeType, bool isMain);\n\n    /// @notice Emitted when the oracle is updated\n    event OracleUpdated(IOracle indexed oldOracle, IOracle indexed newOracle);\n\n    /// @notice Emitted when the max slippage is updated\n    event MaxSlippageUpdated(uint256 oldMaxSlippage, uint256 newMaxSlippage);\n\n    /// @notice Emitted when exact-input swap is executed\n    event SwapExactInput(\n        IExchange indexed exchange,\n        bytes path,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    /// @notice Emitted when exact-output swap is executed\n    event SwapExactOutput(\n        IExchange indexed exchange,\n        bytes path,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 amountInMax,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    /// @notice Emitted when default routing is updated\n    event DefaultRoutingUpdated(bytes key, bytes oldRouting, bytes newRouting);\n\n    function initialize(IOracle oracle_, uint256 maxSlippage_) external initializer {\n        require(address(oracle_) != address(0), \"oracle-is-null\");\n        oracle = oracle_;\n        maxSlippage = maxSlippage_;\n    }\n\n    /// @inheritdoc ISwapper\n    function getBestAmountIn(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountOut_\n    )\n        public\n        returns (\n            uint256 _amountInMax,\n            IExchange _exchange,\n            bytes memory _path\n        )\n    {\n        _amountInMax = (oracle.quote(tokenOut_, tokenIn_, amountOut_) * (1e18 + maxSlippage)) / 1e18;\n\n        // 1. Return default routing if any\n        bytes memory _defaultRouting = defaultRoutings[\n            abi.encodePacked(DataTypes.SwapType.EXACT_OUTPUT, tokenIn_, tokenOut_)\n        ];\n        if (_defaultRouting.length > 0) {\n            DataTypes.ExchangeType _exchangeType;\n            (_exchangeType, _path) = abi.decode(_defaultRouting, (DataTypes.ExchangeType, bytes));\n            return (_amountInMax, IExchange(addressOf[_exchangeType]), _path);\n        }\n\n        // 2. Look for the best routing\n        uint256 _amountIn = type(uint256).max;\n        uint256 _len = mainExchanges.length();\n        for (uint256 i; i < _len; ++i) {\n            IExchange _iExchange = IExchange(mainExchanges.at(i));\n            (uint256 _iAmountIn, bytes memory _iPath) = _iExchange.getBestAmountIn(tokenIn_, tokenOut_, amountOut_);\n            if (_iAmountIn > 0 && _iAmountIn < _amountIn && _iAmountIn <= _amountInMax) {\n                _amountIn = _iAmountIn;\n                _exchange = _iExchange;\n                _path = _iPath;\n            }\n        }\n        require(_path.length > 0, \"no-routing-found\");\n    }\n\n    /// @inheritdoc ISwapper\n    function getBestAmountOut(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        public\n        returns (\n            uint256 _amountOutMin,\n            IExchange _exchange,\n            bytes memory _path\n        )\n    {\n        _amountOutMin = (oracle.quote(tokenIn_, tokenOut_, amountIn_) * (1e18 - maxSlippage)) / 1e18;\n\n        // 1. Return default routing if any\n        bytes memory _defaultRouting = defaultRoutings[\n            abi.encodePacked(DataTypes.SwapType.EXACT_INPUT, tokenIn_, tokenOut_)\n        ];\n        if (_defaultRouting.length > 0) {\n            DataTypes.ExchangeType _exchangeType;\n            (_exchangeType, _path) = abi.decode(_defaultRouting, (DataTypes.ExchangeType, bytes));\n            return (_amountOutMin, IExchange(addressOf[_exchangeType]), _path);\n        }\n\n        // 2. Look for the best routing\n        uint256 _amountOut;\n        uint256 _len = mainExchanges.length();\n        for (uint256 i; i < _len; ++i) {\n            IExchange _iExchange = IExchange(mainExchanges.at(i));\n            (uint256 _iAmountOut, bytes memory _iPath) = _iExchange.getBestAmountOut(tokenIn_, tokenOut_, amountIn_);\n            if (_iAmountOut > _amountOut && _iAmountOut >= _amountOutMin) {\n                _amountOut = _iAmountOut;\n                _exchange = _iExchange;\n                _path = _iPath;\n            }\n        }\n\n        require(_path.length > 0, \"no-routing-found\");\n    }\n\n    /// @inheritdoc ISwapper\n    function getAllExchanges() external view override returns (address[] memory) {\n        return allExchanges.values();\n    }\n\n    /// @inheritdoc ISwapper\n    function getMainExchanges() external view override returns (address[] memory) {\n        return mainExchanges.values();\n    }\n\n    /// @inheritdoc ISwapper\n    function swapExactInput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_,\n        address receiver_\n    ) external returns (uint256 _amountOut) {\n        (uint256 _amountOutMin, IExchange _exchange, bytes memory _path) = getBestAmountOut(\n            tokenIn_,\n            tokenOut_,\n            amountIn_\n        );\n        return _swapExactInput(tokenIn_, tokenOut_, amountIn_, receiver_, _amountOutMin, _exchange, _path);\n    }\n\n    /// @inheritdoc ISwapper\n    function swapExactOutput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountOut_,\n        address receiver_\n    ) external returns (uint256 _amountIn) {\n        (uint256 _amountInMax, IExchange _exchange, bytes memory _path) = getBestAmountIn(\n            tokenIn_,\n            tokenOut_,\n            amountOut_\n        );\n        return _swapExactOutput(tokenIn_, tokenOut_, amountOut_, receiver_, _amountInMax, _exchange, _path);\n    }\n\n    /**\n     * @notice Add or update exchange\n     * @dev Use null `exchange_` for removal\n     */\n    function setExchange(DataTypes.ExchangeType type_, address exchange_) external onlyGovernor {\n        address _currentExchange = addressOf[type_];\n\n        if (_currentExchange == address(0)) {\n            // Adding\n            require(allExchanges.add(exchange_), \"exchange-exists\");\n            require(mainExchanges.add(exchange_), \"main-exchange-exists\");\n            addressOf[type_] = exchange_;\n        } else if (exchange_ == address(0)) {\n            // Removing\n            require(allExchanges.remove(_currentExchange), \"exchange-does-not-exist\");\n            if (mainExchanges.contains(_currentExchange)) {\n                mainExchanges.remove(_currentExchange);\n            }\n            delete addressOf[type_];\n        } else {\n            // Updating\n            if (mainExchanges.contains(_currentExchange)) {\n                mainExchanges.remove(_currentExchange);\n            }\n            require(allExchanges.remove(_currentExchange), \"exchange-does-not-exist\");\n            require(allExchanges.add(exchange_), \"exchange-exists\");\n            require(mainExchanges.add(exchange_), \"main-exchange-exists\");\n            addressOf[type_] = exchange_;\n        }\n        emit ExchangeUpdated(type_, _currentExchange, exchange_);\n    }\n\n    /**\n     * @notice Toggle exchange as main\n     */\n    function toggleExchangeAsMain(DataTypes.ExchangeType type_) public onlyGovernor {\n        address _address = addressOf[type_];\n        require(_address != address(0), \"exchange-does-not-exist\");\n        if (mainExchanges.contains(_address)) {\n            mainExchanges.remove(_address);\n            emit ExchangeAsMainUpdated(type_, false);\n        } else {\n            mainExchanges.add(_address);\n            emit ExchangeAsMainUpdated(type_, true);\n        }\n    }\n\n    /**\n     * @notice Update max slippage\n     */\n    function updateMaxSlippage(uint256 maxSlippage_) external onlyGovernor {\n        require(maxSlippage_ <= 1e18, \"max-slippage-gt-100%\");\n        emit MaxSlippageUpdated(maxSlippage, maxSlippage_);\n        maxSlippage = maxSlippage_;\n    }\n\n    /**\n     * @notice Update oracle contract\n     */\n    function updateOracle(IOracle oracle_) external onlyGovernor {\n        require(address(oracle_) != address(0), \"address-is-null\");\n        emit OracleUpdated(oracle, oracle_);\n        oracle = oracle_;\n    }\n\n    /**\n     * @notice Set default routing\n     * @dev Use empty `path_` for removal\n     * @param swapType_ If the routing is related to `EXACT_INPUT` or `EXACT_OUTPUT`\n     * @param tokenIn_ The swap in token\n     * @param tokenOut_ The swap out token\n     * @param exchange_ The type (i.e. protocol) of the exchange\n     * @param path_ The swap path\n     * @dev Use `abi.encodePacked(tokenA, poolFee1, tokenB, poolFee2, tokenC, ...)` for UniswapV3 exchange\n     * @dev Use `abi.encode([tokenA, tokenB, tokenC, ...])` for UniswapV2-like exchanges\n     */\n    function setDefaultRouting(\n        DataTypes.SwapType swapType_,\n        address tokenIn_,\n        address tokenOut_,\n        DataTypes.ExchangeType exchange_,\n        bytes calldata path_\n    ) external onlyGovernor {\n        bytes memory _key = abi.encodePacked(swapType_, tokenIn_, tokenOut_);\n        bytes memory _currentRouting = defaultRoutings[_key];\n        bytes memory _newRouting = abi.encode(exchange_, path_);\n        if (path_.length == 0) {\n            delete defaultRoutings[_key];\n        } else {\n            defaultRoutings[_key] = _newRouting;\n        }\n        emit DefaultRoutingUpdated(_key, _currentRouting, _newRouting);\n    }\n\n    /**\n     * @notice Perform an exact input swap\n     * @dev This code is reused by public/external functions\n     */\n    function _swapExactInput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_,\n        address receiver_,\n        uint256 _amountOutMin,\n        IExchange _exchange,\n        bytes memory _path\n    ) private returns (uint256 _amountOut) {\n        uint256 _balanceBefore = IERC20(tokenIn_).balanceOf(address(_exchange));\n        IERC20(tokenIn_).safeTransferFrom(msg.sender, address(_exchange), amountIn_);\n        _amountOut = _exchange.swapExactInput(\n            _path,\n            // amountIn will be balanceNow - balanceBefore for fee-on-transfer tokens\n            IERC20(tokenIn_).balanceOf(address(_exchange)) - _balanceBefore,\n            _amountOutMin,\n            receiver_\n        );\n        emit SwapExactInput(_exchange, _path, tokenIn_, tokenOut_, amountIn_, _amountOut);\n    }\n\n    /**\n     * @notice Perform an exact output swap\n     * @dev This code is reused by public/external functions\n     */\n    function _swapExactOutput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountOut_,\n        address receiver_,\n        uint256 _amountInMax,\n        IExchange _exchange,\n        bytes memory _path\n    ) private returns (uint256 _amountIn) {\n        IERC20(tokenIn_).safeTransferFrom(msg.sender, address(_exchange), _amountInMax);\n        _amountIn = _exchange.swapExactOutput(_path, amountOut_, _amountInMax, msg.sender, receiver_);\n        emit SwapExactOutput(_exchange, _path, tokenIn_, tokenOut_, _amountInMax, _amountIn, amountOut_);\n    }\n}\n"
    },
    "contracts/swapper/SwapperStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"../interfaces/swapper/ISwapper.sol\";\nimport \"../libraries/DataTypes.sol\";\n\nabstract contract SwapperStorage is ISwapper {\n    /**\n     * @notice List of the supported exchanges\n     */\n    EnumerableSet.AddressSet internal allExchanges;\n\n    /**\n     * @notice List of the exchanges to loop over when getting best paths\n     */\n    EnumerableSet.AddressSet internal mainExchanges;\n\n    /**\n     * @notice Mapping of exchanges' addresses by type\n     */\n    mapping(DataTypes.ExchangeType => address) public addressOf;\n\n    /**\n     * @notice Default swap routings\n     * @dev Used to save gas by using a preset routing instead of looking for the best\n     */\n    mapping(bytes => bytes) public defaultRoutings;\n\n    /**\n     * @notice The oracle contract\n     * @dev This is used to set acceptable slippage parameters\n     */\n    IOracle public override oracle;\n\n    /**\n     * @notice Max slippage acceptable\n     * @dev Use 18 decimals (e.g. 0.2e18 = 20%)\n     */\n    uint256 public override maxSlippage;\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = _setInitializedVersion(1);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        bool isTopLevelCall = _setInitializedVersion(version);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(version);\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        _setInitializedVersion(type(uint8).max);\n    }\n\n    function _setInitializedVersion(uint8 version) private returns (bool) {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\n        // of initializers, because in other contexts the contract may have been reentered.\n        if (_initializing) {\n            require(\n                version == 1 && !Address.isContract(address(this)),\n                \"Initializable: contract is already initialized\"\n            );\n            return false;\n        } else {\n            require(_initialized < version, \"Initializable: contract is already initialized\");\n            _initialized = version;\n            return true;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/swapper/ISwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../periphery/IOracle.sol\";\nimport \"./IExchange.sol\";\n\n/**\n * @notice Swapper interface\n * @dev This contract doesn't support native coins (e.g. ETH, AVAX, MATIC, etc) use wrapper tokens instead\n */\ninterface ISwapper {\n    /**\n     * @notice The list of supported DEXes\n     * @dev This function is gas intensive\n     */\n    function getAllExchanges() external view returns (address[] memory);\n\n    /**\n     * @notice The list of main DEXes\n     * @dev This function is gas intensive\n     */\n    function getMainExchanges() external view returns (address[] memory);\n\n    /**\n     * @notice Oracle to get prices from\n     * @dev Is used combined with `slippage` in order to check swaps outcomes and reject if aren't acceptable\n     */\n    function oracle() external view returns (IOracle);\n\n    /**\n     * @notice Get max acceptable slippage\n     * @dev Swaps will revert if actual output from swap is too far from oracle price\n     */\n    function maxSlippage() external view returns (uint256);\n\n    /**\n     * @notice Get *spot* quote\n     * It will return the swap amount based on the current reserves of the best pair/path found (i.e. spot price).\n     * @dev It shouldn't be used as oracle!!!\n     */\n    function getBestAmountIn(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountOut_\n    )\n        external\n        returns (\n            uint256 _amountInMax,\n            IExchange _exchange,\n            bytes memory _path\n        );\n\n    /**\n     * @notice Get *spot* quote\n     * It will return the swap amount based on the current reserves of the best pair/path found (i.e. spot price).\n     * @dev It shouldn't be used as oracle!!!\n     */\n    function getBestAmountOut(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        returns (\n            uint256 _amountOutMin,\n            IExchange _exchange,\n            bytes memory _path\n        );\n\n    /**\n     * @notice Perform an exact input swap\n     */\n    function swapExactInput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_,\n        address _receiver\n    ) external returns (uint256 _amountOut);\n\n    /**\n     * @notice Perform an exact output swap\n     */\n    function swapExactOutput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountOut_,\n        address _receiver\n    ) external returns (uint256 _amountIn);\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/interfaces/periphery/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IOracle {\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of asset\n     * @return _priceInUsd The USD price\n     */\n    function getPriceInUsd(address token_) external view returns (uint256 _priceInUsd);\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external view returns (uint256 _amountOut);\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     */\n    function quoteTokenToUsd(address token_, uint256 amountIn_) external view returns (uint256 amountOut_);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetOut\n     * @param amountIn_ Input amount in USD\n     * @return _amountOut Output amount of token\n     */\n    function quoteUsdToToken(address token_, uint256 amountIn_) external view returns (uint256 _amountOut);\n}\n"
    },
    "contracts/swapper/RoutedSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../access/Governable.sol\";\nimport \"../interfaces/swapper/IExchange.sol\";\nimport \"../libraries/DataTypes.sol\";\nimport \"./RoutedSwapperStorage.sol\";\n\n/**\n * @notice Routed Swapper contract\n * This contract execute swaps and quoted using pre-set swap routes\n */\ncontract RoutedSwapper is Initializable, Governable, RoutedSwapperStorage {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Emitted when an exchange is added\n    event ExchangeUpdated(\n        DataTypes.ExchangeType indexed exchangeType,\n        address indexed oldExchange,\n        address indexed newExchange\n    );\n\n    /// @notice Emitted when exact-input swap is executed\n    event SwapExactInput(\n        IExchange indexed exchange,\n        bytes path,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    /// @notice Emitted when exact-output swap is executed\n    event SwapExactOutput(\n        IExchange indexed exchange,\n        bytes path,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 amountInMax,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    /// @notice Emitted when default routing is updated\n    event DefaultRoutingUpdated(bytes key, bytes oldRouting, bytes newRouting);\n\n    /// @inheritdoc IRoutedSwapper\n    function getAmountIn(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountOut_\n    ) public returns (uint256 _amountIn) {\n        bytes memory _defaultRouting = defaultRoutings[\n            abi.encodePacked(DataTypes.SwapType.EXACT_OUTPUT, tokenIn_, tokenOut_)\n        ];\n        require(_defaultRouting.length > 0, \"no-routing-found\");\n\n        (DataTypes.ExchangeType _exchangeType, bytes memory _path) = abi.decode(\n            _defaultRouting,\n            (DataTypes.ExchangeType, bytes)\n        );\n\n        _amountIn = IExchange(addressOf[_exchangeType]).getAmountsIn(amountOut_, _path);\n    }\n\n    /// @inheritdoc IRoutedSwapper\n    function getAmountOut(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) public returns (uint256 _amountOut) {\n        bytes memory _defaultRouting = defaultRoutings[\n            abi.encodePacked(DataTypes.SwapType.EXACT_INPUT, tokenIn_, tokenOut_)\n        ];\n        require(_defaultRouting.length > 0, \"no-routing-found\");\n\n        (DataTypes.ExchangeType _exchangeType, bytes memory _path) = abi.decode(\n            _defaultRouting,\n            (DataTypes.ExchangeType, bytes)\n        );\n\n        _amountOut = IExchange(addressOf[_exchangeType]).getAmountsOut(amountIn_, _path);\n    }\n\n    /// @inheritdoc IRoutedSwapper\n    function getAllExchanges() external view override returns (address[] memory) {\n        return allExchanges.values();\n    }\n\n    /// @inheritdoc IRoutedSwapper\n    function swapExactInput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address receiver_\n    ) external returns (uint256 _amountOut) {\n        bytes memory _defaultRouting = defaultRoutings[\n            abi.encodePacked(DataTypes.SwapType.EXACT_INPUT, tokenIn_, tokenOut_)\n        ];\n        require(_defaultRouting.length > 0, \"no-routing-found\");\n\n        (DataTypes.ExchangeType _exchangeType, bytes memory _path) = abi.decode(\n            _defaultRouting,\n            (DataTypes.ExchangeType, bytes)\n        );\n\n        IExchange _exchange = IExchange(addressOf[_exchangeType]);\n        uint256 _balanceBefore = IERC20(tokenIn_).balanceOf(address(_exchange));\n        IERC20(tokenIn_).safeTransferFrom(msg.sender, address(_exchange), amountIn_);\n        _amountOut = _exchange.swapExactInput(\n            _path,\n            // amountIn will be balanceNow - balanceBefore for fee-on-transfer tokens\n            IERC20(tokenIn_).balanceOf(address(_exchange)) - _balanceBefore,\n            amountOutMin_,\n            receiver_\n        );\n        emit SwapExactInput(_exchange, _path, tokenIn_, tokenOut_, amountIn_, _amountOut);\n    }\n\n    /// @inheritdoc IRoutedSwapper\n    function swapExactOutput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address receiver_\n    ) external returns (uint256 _amountIn) {\n        bytes memory _defaultRouting = defaultRoutings[\n            abi.encodePacked(DataTypes.SwapType.EXACT_OUTPUT, tokenIn_, tokenOut_)\n        ];\n        require(_defaultRouting.length > 0, \"no-routing-found\");\n        (DataTypes.ExchangeType _exchangeType, bytes memory _path) = abi.decode(\n            _defaultRouting,\n            (DataTypes.ExchangeType, bytes)\n        );\n\n        IExchange _exchange = IExchange(addressOf[_exchangeType]);\n        IERC20(tokenIn_).safeTransferFrom(msg.sender, address(_exchange), amountInMax_);\n        _amountIn = _exchange.swapExactOutput(_path, amountOut_, amountInMax_, msg.sender, receiver_);\n        emit SwapExactOutput(_exchange, _path, tokenIn_, tokenOut_, amountInMax_, _amountIn, amountOut_);\n    }\n\n    /**\n     * @notice Add or update exchange\n     * @dev Use null `exchange_` for removal\n     */\n    function setExchange(DataTypes.ExchangeType type_, address exchange_) external onlyGovernor {\n        address _currentExchange = addressOf[type_];\n\n        if (_currentExchange == address(0)) {\n            // Adding\n            require(allExchanges.add(exchange_), \"exchange-exists\");\n            addressOf[type_] = exchange_;\n        } else if (exchange_ == address(0)) {\n            // Removing\n            require(allExchanges.remove(_currentExchange), \"exchange-does-not-exist\");\n            delete addressOf[type_];\n        } else {\n            // Updating\n            require(allExchanges.remove(_currentExchange), \"exchange-does-not-exist\");\n            require(allExchanges.add(exchange_), \"exchange-exists\");\n            addressOf[type_] = exchange_;\n        }\n        emit ExchangeUpdated(type_, _currentExchange, exchange_);\n    }\n\n    /**\n     * @notice Set default routing\n     * @dev Use empty `path_` for removal\n     * @param swapType_ If the routing is related to `EXACT_INPUT` or `EXACT_OUTPUT`\n     * @param tokenIn_ The swap in token\n     * @param tokenOut_ The swap out token\n     * @param exchange_ The type (i.e. protocol) of the exchange\n     * @param path_ The swap path\n     * @dev Use `abi.encodePacked(tokenA, poolFee1, tokenB, poolFee2, tokenC, ...)` for UniswapV3 exchange\n     * @dev Use `abi.encode([tokenA, tokenB, tokenC, ...])` for UniswapV2-like exchanges\n     */\n    function setDefaultRouting(\n        DataTypes.SwapType swapType_,\n        address tokenIn_,\n        address tokenOut_,\n        DataTypes.ExchangeType exchange_,\n        bytes calldata path_\n    ) external onlyGovernor {\n        bytes memory _key = abi.encodePacked(swapType_, tokenIn_, tokenOut_);\n        bytes memory _currentRouting = defaultRoutings[_key];\n        bytes memory _newRouting = abi.encode(exchange_, path_);\n        if (path_.length == 0) {\n            delete defaultRoutings[_key];\n        } else {\n            defaultRoutings[_key] = _newRouting;\n        }\n        emit DefaultRoutingUpdated(_key, _currentRouting, _newRouting);\n    }\n}\n"
    },
    "contracts/swapper/RoutedSwapperStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"../interfaces/swapper/IRoutedSwapper.sol\";\nimport \"../libraries/DataTypes.sol\";\n\nabstract contract RoutedSwapperStorage is IRoutedSwapper {\n    /**\n     * @notice List of the supported exchanges\n     */\n    EnumerableSet.AddressSet internal allExchanges;\n\n    /**\n     * @notice Mapping of exchanges' addresses by type\n     */\n    mapping(DataTypes.ExchangeType => address) public addressOf;\n\n    /**\n     * @notice Default swap routings\n     * @dev Used to save gas by using a preset routing instead of looking for the best\n     */\n    mapping(bytes => bytes) public defaultRoutings;\n}\n"
    },
    "contracts/interfaces/swapper/IRoutedSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/**\n * @notice Routed Swapper interface\n * @dev This contract doesn't support native coins (e.g. ETH, AVAX, MATIC, etc) use wrapper tokens instead\n */\ninterface IRoutedSwapper {\n    /**\n     * @notice The list of supported DEXes\n     * @dev This function is gas intensive\n     */\n    function getAllExchanges() external view returns (address[] memory);\n\n    /**\n     * @notice Get *spot* quote\n     * It will return the swap amount based on the current reserves of the best pair/path found (i.e. spot price).\n     * @dev It shouldn't be used as oracle!!!\n     */\n    function getAmountIn(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountOut_\n    ) external returns (uint256 _amountIn);\n\n    /**\n     * @notice Get *spot* quote\n     * It will return the swap amount based on the current reserves of the best pair/path found (i.e. spot price).\n     * @dev It shouldn't be used as oracle!!!\n     */\n    function getAmountOut(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external returns (uint256 _amountOut);\n\n    /**\n     * @notice Perform an exact input swap - will revert if there is no default routing\n     */\n    function swapExactInput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_,\n        uint256 amountOutMin_,\n        address _receiver\n    ) external returns (uint256 _amountOut);\n\n    /**\n     * @notice Perform an exact output swap - will revert if there is no default routing\n     */\n    function swapExactOutput(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountOut_,\n        uint256 amountInMax_,\n        address receiver_\n    ) external returns (uint256 _amountIn);\n}\n"
    },
    "contracts/periphery/tokens/BTCPeggedTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\nimport \"../../features/UsingStalePeriod.sol\";\n\n/**\n * @title Oracle for BTC-pegged tokens that uses Chainlink's BTC/USD feed\n */\ncontract BTCPeggedTokenOracle is ITokenOracle, UsingStalePeriod {\n    using SafeCast for int256;\n\n    /// @notice Chainlink BTC/USD aggregator\n    AggregatorV3Interface public immutable btcAggregator;\n\n    constructor(AggregatorV3Interface btcAggregator_, uint256 stalePeriod_) UsingStalePeriod(stalePeriod_) {\n        btcAggregator = btcAggregator_;\n    }\n\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address) external view override returns (uint256 _priceInUsd) {\n        (, int256 _price, , uint256 _lastUpdatedAt, ) = btcAggregator.latestRoundData();\n        require(!_priceIsStale(_lastUpdatedAt, defaultStalePeriod), \"stale-price\");\n        return _price.toUint256() * 1e10; // To 18 decimals\n    }\n}\n"
    },
    "contracts/interfaces/periphery/ITokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ITokenOracle {\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of asset\n     * @return _priceInUsd The USD price\n     */\n    function getPriceInUsd(address token_) external view returns (uint256 _priceInUsd);\n}\n"
    },
    "contracts/features/UsingStalePeriod.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../access/Governable.sol\";\n\n/**\n * @title Stale price check feature, useful when checking if prices are fresh enough\n */\nabstract contract UsingStalePeriod is Governable {\n    /// @notice The default stale period. It's used to determine if a price is invalid (i.e. outdated)\n    uint256 public defaultStalePeriod;\n\n    /// @notice Custom stale period, used for token that has different stale window (e.g. some stable coins have 24h window)\n    mapping(address => uint256) customStalePeriod;\n\n    /// @notice Emitted when custom stale period is updated\n    event CustomStalePeriodUpdated(address token, uint256 oldStalePeriod, uint256 newStalePeriod);\n\n    /// @notice Emitted when default stale period is updated\n    event DefaultStalePeriodUpdated(uint256 oldStalePeriod, uint256 newStalePeriod);\n\n    constructor(uint256 defaultStalePeriod_) {\n        defaultStalePeriod = defaultStalePeriod_;\n    }\n\n    /**\n     * @notice Get stale period of a token\n     */\n    function stalePeriodOf(address token_) public view returns (uint256 _stalePeriod) {\n        _stalePeriod = customStalePeriod[token_];\n        if (_stalePeriod == 0) {\n            _stalePeriod = defaultStalePeriod;\n        }\n    }\n\n    /**\n     * @notice Check if a price timestamp is outdated\n     * @dev Uses default stale period\n     * @param timeOfLastUpdate_ The price timestamp\n     * @return true if price is stale (outdated)\n     */\n    function _priceIsStale(address token_, uint256 timeOfLastUpdate_) internal view returns (bool) {\n        return _priceIsStale(timeOfLastUpdate_, stalePeriodOf(token_));\n    }\n\n    /**\n     * @notice Check if a price timestamp is outdated\n     * @param timeOfLastUpdate_ The price timestamp\n     * @param stalePeriod_ The maximum acceptable outdated period\n     * @return true if price is stale (outdated)\n     */\n    function _priceIsStale(uint256 timeOfLastUpdate_, uint256 stalePeriod_) internal view returns (bool) {\n        return block.timestamp - timeOfLastUpdate_ > stalePeriod_;\n    }\n\n    /**\n     * @notice Update custom stale period\n     * @dev Use `0` as `stalePeriod_` to remove custom stale period\n     */\n    function updateCustomStalePeriod(address token_, uint256 stalePeriod_) external onlyGovernor {\n        require(token_ != address(0), \"token-is-null\");\n        emit CustomStalePeriodUpdated(token_, customStalePeriod[token_], stalePeriod_);\n        if (stalePeriod_ > 0) {\n            customStalePeriod[token_] = stalePeriod_;\n        } else {\n            delete customStalePeriod[token_];\n        }\n    }\n\n    /**\n     * @notice Update default stale period\n     */\n    function updateDefaultStalePeriod(uint256 stalePeriod_) external onlyGovernor {\n        emit DefaultStalePeriodUpdated(defaultStalePeriod, stalePeriod_);\n        defaultStalePeriod = stalePeriod_;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/core/UniswapV3PriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../access/Governable.sol\";\nimport \"../interfaces/utils/IUniswapV3CrossPoolOracle.sol\";\nimport \"../interfaces/core/IUniswapV3PriceProvider.sol\";\nimport \"./PriceProvider.sol\";\n\ncontract UniswapV3PriceProvider is IUniswapV3PriceProvider, Governable, PriceProvider {\n    /**\n     * @notice The UniswapV3CrossPoolOracle contract\n     * @dev This contract encapsulates UniswapV3 oracle logic\n     */\n    IUniswapV3CrossPoolOracle public immutable crossPoolOracle;\n\n    /**\n     * @notice The time-weighted average price (TWAP) period\n     * @dev See more: https://docs.uniswap.org/protocol/concepts/V3-overview/oracle\n     */\n    uint32 public override defaultTwapPeriod;\n\n    /**\n     * @notice The default pool fee to use\n     * @dev Use 1e6 for 100% (e.g 3000 is 0.3%)\n     */\n    uint24 public defaultPoolFee;\n\n    /// @notice Emitted when the default TWAP period is updated\n    event DefaultTwapPeriodUpdated(uint32 oldDefaultTwapPeriod, uint32 newDefaultTwapPeriod);\n\n    /// @notice Emitted when the default pool fee updated\n    event DefaultPoolFeeUpdated(uint24 oldDefaultPoolFee, uint24 newDefaultPoolFee);\n\n    constructor(\n        IUniswapV3CrossPoolOracle crossPoolOracle_,\n        uint32 defaultTwapPeriod_,\n        uint24 defaultFee_\n    ) {\n        require(address(crossPoolOracle_) != address(0), \"cross-pool-is-null\");\n        crossPoolOracle = crossPoolOracle_;\n        defaultTwapPeriod = defaultTwapPeriod_;\n        defaultPoolFee = defaultFee_;\n    }\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(address token_)\n        public\n        view\n        override(IPriceProvider, PriceProvider)\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        return getPriceInUsd(token_, defaultPoolFee, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function getPriceInUsd(address token_, uint32 twapPeriod_)\n        public\n        view\n        override\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        return getPriceInUsd(token_, defaultPoolFee, twapPeriod_);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function getPriceInUsd(address token_, uint24 poolFee_)\n        public\n        view\n        override\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        return getPriceInUsd(token_, poolFee_, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function getPriceInUsd(\n        address token_,\n        uint24 poolFee_,\n        uint32 twapPeriod_\n    ) public view override returns (uint256 _priceInUsd, uint256 _lastUpdatedAt) {\n        IStableCoinProvider _stableCoinProvider = addressProvider.stableCoinProvider();\n        require(address(_stableCoinProvider) != address(0), \"stable-coin-not-supported\");\n\n        uint256 _stableCoinAmount;\n        (_stableCoinAmount, _lastUpdatedAt, ) = quote(\n            token_,\n            _stableCoinProvider.getStableCoinIfPegged(),\n            poolFee_,\n            twapPeriod_,\n            10**IERC20Metadata(token_).decimals() // ONE\n        );\n\n        _priceInUsd = _stableCoinProvider.toUsdRepresentation(_stableCoinAmount);\n    }\n\n    /// @inheritdoc IPriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        view\n        override(IPriceProvider, PriceProvider)\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        return quote(tokenIn_, tokenOut_, defaultPoolFee, defaultTwapPeriod, amountIn_);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint32 twapPeriod_,\n        uint256 amountIn_\n    )\n        external\n        view\n        override\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        return quote(tokenIn_, tokenOut_, defaultPoolFee, twapPeriod_, amountIn_);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint24 poolFee_,\n        uint256 amountIn_\n    )\n        external\n        view\n        override\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        return quote(tokenIn_, tokenOut_, poolFee_, defaultTwapPeriod, amountIn_);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint24 poolFee_,\n        uint32 twapPeriod_,\n        uint256 amountIn_\n    )\n        public\n        view\n        override\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        if (tokenIn_ == tokenOut_) {\n            return (amountIn_, block.timestamp, block.timestamp);\n        }\n\n        if (tokenIn_ == crossPoolOracle.nativeToken()) {\n            _amountOut = crossPoolOracle.ethToAsset(amountIn_, tokenOut_, poolFee_, twapPeriod_);\n        } else if (tokenOut_ == crossPoolOracle.nativeToken()) {\n            _amountOut = crossPoolOracle.assetToEth(tokenIn_, amountIn_, poolFee_, twapPeriod_);\n        } else {\n            _amountOut = crossPoolOracle.assetToAsset(tokenIn_, amountIn_, tokenOut_, poolFee_, twapPeriod_);\n        }\n        _tokenInLastUpdatedAt = block.timestamp;\n        _tokenOutLastUpdatedAt = block.timestamp;\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        return quoteTokenToUsd(token_, amountIn_, poolFee_, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint32 twapPeriod_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        return quoteTokenToUsd(token_, amountIn_, defaultPoolFee, twapPeriod_);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_,\n        uint32 twapPeriod_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        uint256 _price;\n        (_price, _lastUpdatedAt) = getPriceInUsd(token_, poolFee_, twapPeriod_);\n        _amountOut = (amountIn_ * _price) / 10**IERC20Metadata(token_).decimals();\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        return quoteUsdToToken(token_, amountIn_, poolFee_, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint32 twapPeriod_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        return quoteUsdToToken(token_, amountIn_, defaultPoolFee, twapPeriod_);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_,\n        uint32 twapPeriod_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        uint256 _price;\n        (_price, _lastUpdatedAt) = getPriceInUsd(token_, poolFee_, twapPeriod_);\n        _amountOut = (amountIn_ * 10**IERC20Metadata(token_).decimals()) / _price;\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function updateDefaultTwapPeriod(uint32 newDefaultTwapPeriod_) external onlyGovernor {\n        emit DefaultTwapPeriodUpdated(defaultTwapPeriod, newDefaultTwapPeriod_);\n        defaultTwapPeriod = newDefaultTwapPeriod_;\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function updateDefaultPoolFee(uint24 newDefaultPoolFee_) external onlyGovernor {\n        emit DefaultPoolFeeUpdated(defaultPoolFee, newDefaultPoolFee_);\n        defaultPoolFee = newDefaultPoolFee_;\n    }\n}\n"
    },
    "contracts/interfaces/utils/IUniswapV3CrossPoolOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/**\n * @title UniswapV3 oracle with ability to query across an intermediate liquidity pool\n */\ninterface IUniswapV3CrossPoolOracle {\n    function nativeToken() external view returns (address);\n\n    function assetToEth(\n        address _tokenIn,\n        uint256 _amountIn,\n        uint24 _fee,\n        uint32 _twapPeriod\n    ) external view returns (uint256 ethAmountOut);\n\n    function ethToAsset(\n        uint256 _ethAmountIn,\n        address _tokenOut,\n        uint24 _fee,\n        uint32 _twapPeriod\n    ) external view returns (uint256 amountOut);\n\n    function assetToAsset(\n        address _tokenIn,\n        uint256 _amountIn,\n        address _tokenOut,\n        uint24 _fee,\n        uint32 _twapPeriod\n    ) external view returns (uint256 amountOut);\n\n    function assetToAssetThruRoute(\n        address _tokenIn,\n        uint256 _amountIn,\n        address _tokenOut,\n        uint32 _twapPeriod,\n        address _routeThruToken,\n        uint24[2] memory _poolFees\n    ) external view returns (uint256 amountOut);\n}\n"
    },
    "contracts/interfaces/core/IUniswapV3PriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./IPriceProvider.sol\";\n\ninterface IUniswapV3PriceProvider is IPriceProvider {\n    /**\n     * @notice The default time-weighted average price (TWAP) period\n     * Used when a period isn't specified\n     * @dev See more: https://docs.uniswap.org/protocol/concepts/V3-overview/oracle\n     */\n    function defaultTwapPeriod() external view returns (uint32);\n\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of assetIn\n     * @param poolFee_ The pools' fees\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(address token_, uint24 poolFee_)\n        external\n        view\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of assetIn\n     * @param twapPeriod_ The TWAP period\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(address token_, uint32 twapPeriod_)\n        external\n        view\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of assetIn\n     * @param poolFee_ The pools' fees\n     * @param twapPeriod_ The TWAP period\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(\n        address token_,\n        uint24 poolFee_,\n        uint32 twapPeriod_\n    ) external view returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param twapPeriod_ The TWAP period\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint32 twapPeriod_,\n        uint256 amountIn_\n    )\n        external\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param poolFee_ The pools' fees\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint24 poolFee_,\n        uint256 amountIn_\n    )\n        external\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param poolFee_ The pools' fees\n     * @param twapPeriod_ The TWAP period\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint24 poolFee_,\n        uint32 twapPeriod_,\n        uint256 amountIn_\n    )\n        external\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @param poolFee_ The pools' fees\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_\n    ) external view returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @param twapPeriod_ The TWAP period\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint32 twapPeriod_\n    ) external view returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @param poolFee_ The pools' fees\n     * @param twapPeriod_ The TWAP period\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_,\n        uint32 twapPeriod_\n    ) external view returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetIn\n     * @param amountIn_ Input amount in USD\n     * @param poolFee_ The TWAP period\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetIn\n     * @param amountIn_ Input amount in USD\n     * @param twapPeriod_ The TWAP period\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint32 twapPeriod_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetIn\n     * @param amountIn_ Input amount in USD\n     * @param poolFee_ The TWAP period\n     * @param twapPeriod_ The TWAP period\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_,\n        uint32 twapPeriod_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Update the default TWAP period\n     * @dev Administrative function\n     * @param newDefaultTwapPeriod_ The new default period\n     */\n    function updateDefaultTwapPeriod(uint32 newDefaultTwapPeriod_) external;\n\n    /**\n     * @notice Update the default pool fee\n     * @dev Administrative function\n     * @param newDefaultPoolFee_ The new default period\n     */\n    function updateDefaultPoolFee(uint24 newDefaultPoolFee_) external;\n}\n"
    },
    "contracts/core/PriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../interfaces/core/IPriceProvider.sol\";\n\n/**\n * @title Price providers' super class that implements common functions\n */\nabstract contract PriceProvider is IPriceProvider {\n    uint256 public constant USD_DECIMALS = 18;\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(address token_) public view virtual returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /// @inheritdoc IPriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        view\n        virtual\n        override\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        uint256 _amountInUsd;\n        (_amountInUsd, _tokenInLastUpdatedAt) = quoteTokenToUsd(tokenIn_, amountIn_);\n        (_amountOut, _tokenOutLastUpdatedAt) = quoteUsdToToken(tokenOut_, _amountInUsd);\n    }\n\n    /// @inheritdoc IPriceProvider\n    function quoteTokenToUsd(address token_, uint256 amountIn_)\n        public\n        view\n        override\n        returns (uint256 _amountOut, uint256 _lastUpdatedAt)\n    {\n        uint256 _price;\n        (_price, _lastUpdatedAt) = getPriceInUsd(token_);\n        _amountOut = (amountIn_ * _price) / 10**IERC20Metadata(token_).decimals();\n    }\n\n    /// @inheritdoc IPriceProvider\n    function quoteUsdToToken(address token_, uint256 amountIn_)\n        public\n        view\n        override\n        returns (uint256 _amountOut, uint256 _lastUpdatedAt)\n    {\n        uint256 _price;\n        (_price, _lastUpdatedAt) = getPriceInUsd(token_);\n        _amountOut = (amountIn_ * 10**IERC20Metadata(token_).decimals()) / _price;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/core/UniswapV2LikePriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@uniswap/lib/contracts/libraries/FixedPoint.sol\";\nimport \"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"../access/Governable.sol\";\nimport \"../interfaces/core/IUniswapV2LikePriceProvider.sol\";\nimport \"./PriceProvider.sol\";\n\n/**\n * @title UniswapV2 (and forks) TWAP Oracle implementation\n * Based on https://github.com/Uniswap/v2-periphery/blob/master/contracts/examples/ExampleOracleSimple.sol\n */\ncontract UniswapV2LikePriceProvider is IUniswapV2LikePriceProvider, Governable, PriceProvider {\n    using FixedPoint for *;\n\n    /**\n     * @notice The UniswapV2-like factory's address\n     */\n    address public immutable factory;\n\n    /**\n     * @notice The native wrapped token (e.g. WETH, WAVAX, WMATIC, etc)\n     */\n    address public immutable nativeToken;\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    uint256 public override defaultTwapPeriod;\n\n    struct Oracle {\n        address token0;\n        address token1;\n        uint256 price0CumulativeLast;\n        uint256 price1CumulativeLast;\n        uint32 blockTimestampLast;\n        FixedPoint.uq112x112 price0Average;\n        FixedPoint.uq112x112 price1Average;\n    }\n\n    /**\n     * @notice Oracles'\n     * @dev pair => twapPeriod => oracle\n     */\n    mapping(IUniswapV2Pair => mapping(uint256 => Oracle)) public oracles;\n\n    /// @notice Emitted when default TWAP period is updated\n    event DefaultTwapPeriodUpdated(uint256 oldTwapPeriod, uint256 newTwapPeriod);\n\n    constructor(\n        address factory_,\n        uint256 defaultTwapPeriod_,\n        address nativeToken_\n    ) {\n        require(factory_ != address(0), \"factory-is-null\");\n        defaultTwapPeriod = defaultTwapPeriod_;\n        factory = factory_;\n        nativeToken = nativeToken_;\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function hasOracle(IUniswapV2Pair pair_) external view override returns (bool) {\n        return hasOracle(pair_, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function hasOracle(IUniswapV2Pair pair_, uint256 twapPeriod_) public view override returns (bool) {\n        return oracles[pair_][twapPeriod_].blockTimestampLast > 0;\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function pairFor(address token0_, address token1_) public view override returns (IUniswapV2Pair _pair) {\n        _pair = IUniswapV2Pair(IUniswapV2Factory(factory).getPair(token0_, token1_));\n    }\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(address token_)\n        public\n        view\n        override(IPriceProvider, PriceProvider)\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        return getPriceInUsd(token_, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function getPriceInUsd(address token_, uint256 twapPeriod_)\n        public\n        view\n        override\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        IStableCoinProvider _stableCoinProvider = addressProvider.stableCoinProvider();\n        require(address(_stableCoinProvider) != address(0), \"stable-coin-not-supported\");\n\n        uint256 _stableCoinAmount;\n        (_stableCoinAmount, _lastUpdatedAt, ) = quote(\n            token_,\n            _stableCoinProvider.getStableCoinIfPegged(),\n            twapPeriod_,\n            10**IERC20Metadata(token_).decimals() // ONE\n        );\n        _priceInUsd = _stableCoinProvider.toUsdRepresentation(_stableCoinAmount);\n    }\n\n    /// @inheritdoc IPriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        view\n        override(IPriceProvider, PriceProvider)\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        return quote(tokenIn_, tokenOut_, defaultTwapPeriod, amountIn_);\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_,\n        uint256 amountIn_\n    )\n        public\n        view\n        override\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        if (tokenIn_ == tokenOut_) {\n            return (amountIn_, block.timestamp, block.timestamp);\n        }\n\n        if (hasOracle(pairFor(tokenIn_, tokenOut_), twapPeriod_)) {\n            (_amountOut, _tokenInLastUpdatedAt) = _getAmountOut(tokenIn_, tokenOut_, twapPeriod_, amountIn_);\n            _tokenOutLastUpdatedAt = _tokenInLastUpdatedAt;\n        } else {\n            (_amountOut, _tokenInLastUpdatedAt) = _getAmountOut(tokenIn_, nativeToken, twapPeriod_, amountIn_);\n            (_amountOut, _tokenOutLastUpdatedAt) = _getAmountOut(nativeToken, tokenOut_, twapPeriod_, _amountOut);\n        }\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint256 twapPeriod_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        uint256 _price;\n        (_price, _lastUpdatedAt) = getPriceInUsd(token_, twapPeriod_);\n        _amountOut = (amountIn_ * _price) / 10**IERC20Metadata(token_).decimals();\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint256 twapPeriod_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        uint256 _price;\n        (_price, _lastUpdatedAt) = getPriceInUsd(token_, twapPeriod_);\n        _amountOut = (amountIn_ * 10**IERC20Metadata(token_).decimals()) / _price;\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function updateAndQuote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        override\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        return updateAndQuote(tokenIn_, tokenOut_, defaultTwapPeriod, amountIn_);\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function updateAndQuote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_,\n        uint256 amountIn_\n    )\n        public\n        override\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        updateOrAdd(tokenIn_, tokenOut_, twapPeriod_);\n        return quote(tokenIn_, tokenOut_, twapPeriod_, amountIn_);\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function updateOrAdd(address tokenIn_, address tokenOut_) external override {\n        updateOrAdd(tokenIn_, tokenOut_, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function updateOrAdd(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_\n    ) public override {\n        IUniswapV2Pair _pair = pairFor(tokenIn_, tokenOut_);\n        if (!hasOracle(_pair, twapPeriod_)) {\n            _addOracleFor(_pair, twapPeriod_);\n        }\n        _updateIfNeeded(_pair, twapPeriod_);\n    }\n\n    /**\n     * @notice Create new oracle\n     * @param pair_ The pair to get prices from\n     * @param twapPeriod_ The TWAP period\n     */\n    function _addOracleFor(IUniswapV2Pair pair_, uint256 twapPeriod_) private {\n        require(address(pair_) != address(0), \"invalid-pair\");\n\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = pair_.getReserves();\n\n        require(_reserve0 != 0 && _reserve1 != 0, \"no-reserves\");\n\n        oracles[pair_][twapPeriod_] = Oracle({\n            token0: pair_.token0(),\n            token1: pair_.token1(),\n            price0CumulativeLast: pair_.price0CumulativeLast(),\n            price1CumulativeLast: pair_.price1CumulativeLast(),\n            blockTimestampLast: _blockTimestampLast,\n            price0Average: uint112(0).encode(),\n            price1Average: uint112(0).encode()\n        });\n    }\n\n    /**\n     * @notice Get the output amount for a given oracle\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param twapPeriod_ The TWAP period\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function _getAmountOut(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_,\n        uint256 amountIn_\n    ) private view returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        Oracle memory _oracle = oracles[pairFor(tokenIn_, tokenOut_)][twapPeriod_];\n        if (tokenIn_ == _oracle.token0) {\n            _amountOut = _oracle.price0Average.mul(amountIn_).decode144();\n        } else {\n            _amountOut = _oracle.price1Average.mul(amountIn_).decode144();\n        }\n        _lastUpdatedAt = _oracle.blockTimestampLast;\n    }\n\n    /**\n     * @notice Update an oracle\n     * @param pair_ The pair to update\n     * @param twapPeriod_ The TWAP period\n     * @return True if updated was performed\n     */\n    function _updateIfNeeded(IUniswapV2Pair pair_, uint256 twapPeriod_) private returns (bool) {\n        Oracle storage _oracle = oracles[pair_][twapPeriod_];\n\n        (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) = UniswapV2OracleLibrary\n            .currentCumulativePrices(address(pair_));\n        uint32 timeElapsed;\n        unchecked {\n            timeElapsed = blockTimestamp - _oracle.blockTimestampLast; // overflow is desired\n        }\n        // ensure that at least one full period has passed since the last update\n        if (timeElapsed < twapPeriod_) return false;\n\n        uint256 price0new;\n        uint256 price1new;\n\n        unchecked {\n            price0new = price0Cumulative - _oracle.price0CumulativeLast;\n            price1new = price1Cumulative - _oracle.price1CumulativeLast;\n        }\n\n        // overflow is desired, casting never truncates\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\n        _oracle.price0Average = FixedPoint.uq112x112(uint224(price0new / timeElapsed));\n        _oracle.price1Average = FixedPoint.uq112x112(uint224(price1new / timeElapsed));\n        _oracle.price0CumulativeLast = price0Cumulative;\n        _oracle.price1CumulativeLast = price1Cumulative;\n        _oracle.blockTimestampLast = blockTimestamp;\n        return true;\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function updateDefaultTwapPeriod(uint256 newDefaultTwapPeriod_) external override onlyGovernor {\n        emit DefaultTwapPeriodUpdated(defaultTwapPeriod, newDefaultTwapPeriod_);\n        defaultTwapPeriod = newDefaultTwapPeriod_;\n    }\n}\n"
    },
    "contracts/interfaces/core/IUniswapV2LikePriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"./IPriceProvider.sol\";\n\ninterface IUniswapV2LikePriceProvider is IPriceProvider {\n    /**\n     * @notice The default time-weighted average price (TWAP) period\n     * Used when a period isn't specified\n     * @dev See more: https://docs.uniswap.org/protocol/concepts/V3-overview/oracle\n     */\n    function defaultTwapPeriod() external view returns (uint256);\n\n    /**\n     * @notice Check if there is an oracle for the PAIR-TWAP key\n     * @param pair_ The pair\n     * @param twapPeriod_ The TWAP period\n     * @return True if exists\n     */\n    function hasOracle(IUniswapV2Pair pair_, uint256 twapPeriod_) external view returns (bool);\n\n    /**\n     * @notice Check if there is an oracle for the PAIR-TWAP key\n     * @dev Uses `defaultTwapPeriod`\n     * @param pair_ The pair\n     * @return True if exists\n     */\n    function hasOracle(IUniswapV2Pair pair_) external view returns (bool);\n\n    /**\n     * @notice Returns the pair's contract\n     */\n    function pairFor(address token0_, address token1_) external view returns (IUniswapV2Pair _pair);\n\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of assetIn\n     * @param twapPeriod_ The TWAP period\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(address token_, uint256 twapPeriod_)\n        external\n        view\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param twapPeriod_ The TWAP period\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_,\n        uint256 amountIn_\n    )\n        external\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @param twapPeriod_ The TWAP period\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint256 twapPeriod_\n    ) external view returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetIn\n     * @param amountIn_ Input amount in USD\n     * @param twapPeriod_ The TWAP period\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint256 twapPeriod_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @dev Will update the oracle if needed before getting quote\n     * @dev Uses `defaultTwapPeriod`\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function updateAndQuote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote\n     * @dev Will update the oracle if needed before getting quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param twapPeriod_ The TWAP period\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function updateAndQuote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_,\n        uint256 amountIn_\n    )\n        external\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Update the default TWAP period\n     * @dev Administrative function\n     * @param newDefaultTwapPeriod_ The new default period\n     */\n    function updateDefaultTwapPeriod(uint256 newDefaultTwapPeriod_) external;\n\n    /**\n     * @notice Update cumulative and average price of pair\n     * @dev Will create the pair if it doesn't exist\n     * @dev Uses `defaultTwapPeriod`\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     */\n    function updateOrAdd(address tokenIn_, address tokenOut_) external;\n\n    /**\n     * @notice Update cumulative and average price of pair\n     * @dev Will create the pair if it doesn't exist\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param twapPeriod_ The TWAP period\n     */\n    function updateOrAdd(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_\n    ) external;\n}\n"
    },
    "@uniswap/lib/contracts/libraries/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\nimport './Babylonian.sol';\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n    uint private constant Q112 = uint(1) << RESOLUTION;\n    uint private constant Q224 = Q112 << RESOLUTION;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\n        return uq112x112(self._x / uint224(x));\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\n        uint z;\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\n        return uq144x112(z);\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // equivalent to encode(numerator).div(denominator)\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n\n    // take the reciprocal of a UQ112x112\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        require(self._x != 0, 'FixedPoint: ZERO_RECIPROCAL');\n        return uq112x112(uint224(Q224 / self._x));\n    }\n\n    // square root of a UQ112x112\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x)) << 56));\n    }\n}\n"
    },
    "@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol": {
      "content": "pragma solidity >=0.5.0;\n\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport '@uniswap/lib/contracts/libraries/FixedPoint.sol';\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n    using FixedPoint for *;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2 ** 32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(\n        address pair\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n            // counterfactual\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n        }\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n        // else z = 0\n    }\n}\n"
    },
    "contracts/periphery/tokens/VspMainnetOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../../features/UsingMaxDeviation.sol\";\nimport \"../../features/UsingStalePeriod.sol\";\nimport \"../../interfaces/periphery/IUpdatableOracle.sol\";\nimport \"../../interfaces/core/IUniswapV2LikePriceProvider.sol\";\n\n/**\n * @title VSP oracle (mainnet)\n */\ncontract VspMainnetOracle is IUpdatableOracle, UsingMaxDeviation, UsingStalePeriod {\n    uint256 public constant ONE_VSP = 1e18;\n    address public constant VSP_ADDRESS = 0x1b40183EFB4Dd766f11bDa7A7c3AD8982e998421;\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    constructor(uint256 maxDeviation_, uint256 stalePeriod_)\n        UsingMaxDeviation(maxDeviation_)\n        UsingStalePeriod(stalePeriod_)\n    {}\n\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address _asset) external view returns (uint256 _priceInUsd) {\n        require(address(_asset) == VSP_ADDRESS, \"invalid-token\");\n        uint256 _lastUpdatedAt;\n        IPriceProvidersAggregator _aggregator = addressProvider.providersAggregator();\n\n        (_priceInUsd, _lastUpdatedAt) = _aggregator.quoteTokenToUsd(\n            DataTypes.Provider.UNISWAP_V2,\n            VSP_ADDRESS,\n            ONE_VSP\n        );\n        (uint256 _priceInUsd1, uint256 _lastUpdatedAt1) = _aggregator.quoteTokenToUsd(\n            DataTypes.Provider.SUSHISWAP,\n            VSP_ADDRESS,\n            ONE_VSP\n        );\n\n        require(\n            _priceInUsd > 0 && _priceInUsd1 > 0 && !_priceIsStale(_asset, Math.min(_lastUpdatedAt, _lastUpdatedAt1)),\n            \"one-or-both-prices-invalid\"\n        );\n        require(_isDeviationOK(_priceInUsd, _priceInUsd1), \"prices-deviation-too-high\");\n    }\n\n    /// @inheritdoc IUpdatableOracle\n    function update() external override {\n        IAddressProvider _addressProvider = addressProvider;\n        IPriceProvidersAggregator _aggregator = _addressProvider.providersAggregator();\n        address _stableCoin = _addressProvider.stableCoinProvider().getStableCoinIfPegged();\n\n        IUniswapV2LikePriceProvider _uniswapV2PriceProvider = IUniswapV2LikePriceProvider(\n            address(_aggregator.priceProviders(DataTypes.Provider.UNISWAP_V2))\n        );\n        IUniswapV2LikePriceProvider _sushiswapPriceProvider = IUniswapV2LikePriceProvider(\n            address(_aggregator.priceProviders(DataTypes.Provider.SUSHISWAP))\n        );\n\n        _uniswapV2PriceProvider.updateOrAdd(VSP_ADDRESS, WETH_ADDRESS);\n        _uniswapV2PriceProvider.updateOrAdd(WETH_ADDRESS, _stableCoin);\n        _sushiswapPriceProvider.updateOrAdd(VSP_ADDRESS, WETH_ADDRESS);\n        _sushiswapPriceProvider.updateOrAdd(WETH_ADDRESS, _stableCoin);\n    }\n}\n"
    },
    "contracts/features/UsingMaxDeviation.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../access/Governable.sol\";\n\n/**\n * @title Deviation check feature, useful when checking prices from different providers for the same asset\n */\nabstract contract UsingMaxDeviation is Governable {\n    /**\n     * @notice The max acceptable deviation\n     * @dev 18-decimals scale (e.g 1e17 = 10%)\n     */\n    uint256 public maxDeviation;\n\n    /// @notice Emitted when max deviation is updated\n    event MaxDeviationUpdated(uint256 oldMaxDeviation, uint256 newMaxDeviation);\n\n    constructor(uint256 maxDeviation_) {\n        maxDeviation = maxDeviation_;\n    }\n\n    /**\n     * @notice Update max deviation\n     */\n    function updateMaxDeviation(uint256 maxDeviation_) external onlyGovernor {\n        emit MaxDeviationUpdated(maxDeviation, maxDeviation_);\n        maxDeviation = maxDeviation_;\n    }\n\n    /**\n     * @notice Check if two numbers deviation is acceptable\n     */\n    function _isDeviationOK(uint256 a_, uint256 b_) internal view returns (bool) {\n        uint256 _deviation = a_ > b_ ? ((a_ - b_) * 1e18) / a_ : ((b_ - a_) * 1e18) / b_;\n        return _deviation <= maxDeviation;\n    }\n}\n"
    },
    "contracts/interfaces/periphery/IUpdatableOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./ITokenOracle.sol\";\n\ninterface IUpdatableOracle is ITokenOracle {\n    /**\n     * @notice Update underlying price providers (i.e. UniswapV2-Like)\n     */\n    function update() external;\n}\n"
    },
    "contracts/periphery/tokens/AlusdTokenMainnetOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../../features/UsingMaxDeviation.sol\";\nimport \"../../features/UsingStalePeriod.sol\";\nimport \"../../interfaces/periphery/IUpdatableOracle.sol\";\nimport \"../../interfaces/core/IUniswapV2LikePriceProvider.sol\";\n\n/**\n * @title alUSD Oracle (mainnet-only)\n */\ncontract AlusdTokenMainnetOracle is IUpdatableOracle, UsingStalePeriod {\n    uint256 public constant ONE_ALUSD = 1e18;\n    address public constant ALUSD_ADDRESS = 0xBC6DA0FE9aD5f3b0d58160288917AA56653660E9;\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    constructor(uint256 stalePeriod_) UsingStalePeriod(stalePeriod_) {}\n\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address _asset) external view returns (uint256 _priceInUsd) {\n        require(address(_asset) == ALUSD_ADDRESS, \"invalid-token\");\n\n        uint256 _lastUpdatedAt;\n        (_priceInUsd, _lastUpdatedAt) = addressProvider.providersAggregator().quoteTokenToUsd(\n            DataTypes.Provider.SUSHISWAP,\n            ALUSD_ADDRESS,\n            ONE_ALUSD\n        );\n\n        require(_priceInUsd > 0 && !_priceIsStale(_lastUpdatedAt, defaultStalePeriod), \"price-invalid\");\n    }\n\n    /// @inheritdoc IUpdatableOracle\n    function update() external override {\n        IAddressProvider _addressProvider = addressProvider;\n        IUniswapV2LikePriceProvider _sushiswap = IUniswapV2LikePriceProvider(\n            address(_addressProvider.providersAggregator().priceProviders(DataTypes.Provider.SUSHISWAP))\n        );\n        _sushiswap.updateOrAdd(ALUSD_ADDRESS, WETH_ADDRESS);\n        _sushiswap.updateOrAdd(WETH_ADDRESS, _addressProvider.stableCoinProvider().getStableCoinIfPegged());\n    }\n}\n"
    },
    "contracts/periphery/tokens/CurveLpTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\nimport \"../../interfaces/external/curve/ICurveAddressProvider.sol\";\nimport \"../../interfaces/external/curve/ICurveRegistry.sol\";\nimport \"../../interfaces/external/curve/ICurvePool.sol\";\nimport \"../../interfaces/periphery/IOracle.sol\";\nimport \"../../access/Governable.sol\";\n\n/**\n * @title Oracle for Curve LP tokens\n */\ncontract CurveLpTokenOracle is ITokenOracle, Governable {\n    ICurveAddressProvider public immutable curveAddressProvider;\n\n    /// @notice Registry contract\n    address public immutable registry;\n\n    /// @notice LP token => coins mapping\n    mapping(address => address[]) public underlyingTokens;\n\n    /// @notice LP token => pool\n    mapping(address => address) public poolOf;\n\n    /// @notice Emitted when a token is registered\n    event LpRegistered(address indexed lpToken, bool isLending);\n\n    constructor(ICurveAddressProvider curveAddressProvider_) {\n        require(address(curveAddressProvider_) != address(0), \"null-address-provider\");\n        curveAddressProvider = curveAddressProvider_;\n        registry = curveAddressProvider.get_registry();\n    }\n\n    /// @inheritdoc ITokenOracle\n    /// @dev This function is supposed to be called from `MasterOracle` only\n    function getPriceInUsd(address lpToken_) public view override returns (uint256 _priceInUsd) {\n        address _pool = poolOf[lpToken_];\n        require(_pool != address(0), \"lp-is-not-registered\");\n        address[] memory _tokens = underlyingTokens[lpToken_];\n        uint256 _min = type(uint256).max;\n        uint256 _n = _tokens.length;\n\n        for (uint256 i; i < _n; i++) {\n            // Note: `msg.sender` is the `MasterOracle` contract\n            uint256 _price = IOracle(msg.sender).getPriceInUsd(_tokens[i]);\n            if (_price < _min) _min = _price;\n        }\n\n        require(_min < type(uint256).max, \"no-min-underlying-price-found\");\n        require(_min > 0, \"invalid-min-price\");\n\n        return (_min * ICurvePool(_pool).get_virtual_price()) / 1e18;\n    }\n\n    /// @notice Register LP token data\n    function registerLp(address lpToken_) external onlyGovernor {\n        _registerLp(lpToken_, false);\n    }\n\n    /// @notice Register LP token data\n    function registerLendingLp(address lpToken_) external onlyGovernor {\n        _registerLp(lpToken_, true);\n    }\n\n    /// @notice Register LP token data\n    function _registerLp(address lpToken_, bool isLending_) internal virtual {\n        ICurveRegistry _registry = ICurveRegistry(registry);\n        address _pool = _registry.get_pool_from_lp_token(lpToken_);\n        require(_pool != address(0), \"invalid-non-factory-lp\");\n\n        address[8] memory _tokens;\n        if (isLending_) {\n            _tokens = _registry.get_underlying_coins(_pool);\n        } else {\n            _tokens = _registry.get_coins(_pool);\n        }\n\n        if (poolOf[lpToken_] != address(0)) {\n            // Clean current tokens if LP exists\n            delete underlyingTokens[lpToken_];\n        }\n\n        poolOf[lpToken_] = _pool;\n\n        uint256 _n = _registry.get_n_coins(_pool);\n        for (uint256 i; i < _n; i++) {\n            underlyingTokens[lpToken_].push(_tokens[i]);\n        }\n\n        emit LpRegistered(lpToken_, isLending_);\n    }\n}\n"
    },
    "contracts/interfaces/external/curve/ICurveAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ICurveAddressProvider {\n    function get_registry() external view returns (address);\n\n    function get_address(uint256 i) external view returns (address);\n}\n"
    },
    "contracts/interfaces/external/curve/ICurveRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ICurveRegistry {\n    function get_n_coins(address lp) external view returns (uint256);\n\n    function get_coins(address pool) external view returns (address[8] memory);\n\n    function get_underlying_coins(address pool) external view returns (address[8] memory);\n\n    function get_pool_from_lp_token(address lp) external view returns (address);\n\n    function is_meta(address pool) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/external/curve/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ICurvePool {\n    function get_virtual_price() external view returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 min_amount\n    ) external;\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external returns (uint256);\n}\n"
    },
    "contracts/periphery/tokens/EllipsisLpTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../interfaces/external/ellipsis/IEllipsisRegistry.sol\";\nimport \"./CurveLpTokenOracle.sol\";\n\n/**\n * @title Oracle for Ellipsis LP tokens\n */\ncontract EllipsisLpTokenOracle is CurveLpTokenOracle {\n    constructor(ICurveAddressProvider addressProvider_) CurveLpTokenOracle(addressProvider_) {}\n\n    /// @notice Register LP token data\n    function _registerLp(address lpToken_, bool isLending_) internal override {\n        IEllipsisRegistry _registry = IEllipsisRegistry(registry);\n        address _pool = _registry.get_pool_from_lp_token(lpToken_);\n        require(_pool != address(0), \"invalid-non-factory-lp\");\n\n        address[4] memory _tokens = _registry.get_coins(_pool);\n\n        if (poolOf[lpToken_] != address(0)) {\n            // Clean current tokens if LP exists\n            delete underlyingTokens[lpToken_];\n        }\n\n        poolOf[lpToken_] = _pool;\n\n        uint256 _n = _registry.get_n_coins(_pool);\n        for (uint256 i; i < _n; i++) {\n            underlyingTokens[lpToken_].push(_tokens[i]);\n        }\n\n        emit LpRegistered(lpToken_, isLending_);\n    }\n}\n"
    },
    "contracts/interfaces/external/ellipsis/IEllipsisRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/* solhint-disable */\npragma solidity 0.8.9;\n\ninterface IEllipsisRegistry {\n    function get_n_coins(address pool) external view returns (uint256);\n\n    function get_pool_from_lp_token(address lp) external view returns (address);\n\n    function get_coins(address pool) external view returns (address[4] memory);\n}\n"
    },
    "contracts/periphery/MasterOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../interfaces/periphery/IOracle.sol\";\nimport \"../access/Governable.sol\";\n\n/**\n * @title MasterOracle\n */\ncontract MasterOracle is IOracle, Governable {\n    /**\n     * @notice Default oracle to use when token hasn't custom oracle\n     */\n    IOracle public defaultOracle;\n\n    /**\n     * @notice Custom tokens' oracles\n     * @dev Useful when dealing with special tokens (e.g. LP, IB, etc)\n     */\n    mapping(address => IOracle) public oracles;\n\n    /// @notice Emitted when a token's oracle is set\n    event TokenOracleUpdated(address indexed token, IOracle indexed oracle);\n\n    /// @notice Emitted when the default oracle is updated\n    event DefaultOracleUpdated(IOracle indexed defaultOracle);\n\n    constructor(IOracle defaultOracle_) {\n        defaultOracle = defaultOracle_;\n    }\n\n    /// @inheritdoc IOracle\n    function getPriceInUsd(address token_) public view override returns (uint256 _priceInUsd) {\n        IOracle _oracle = oracles[token_];\n\n        if (address(_oracle) != address(0)) {\n            _priceInUsd = _oracle.getPriceInUsd(token_);\n        } else if (address(defaultOracle) != address(0)) {\n            _priceInUsd = defaultOracle.getPriceInUsd(token_);\n        } else {\n            revert(\"token-without-oracle\");\n        }\n\n        require(_priceInUsd > 0, \"invalid-token-price\");\n    }\n\n    /// @inheritdoc IOracle\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external view virtual override returns (uint256 _amountOut) {\n        _amountOut = quoteUsdToToken(tokenOut_, quoteTokenToUsd(tokenIn_, amountIn_));\n    }\n\n    /// @inheritdoc IOracle\n    function quoteTokenToUsd(address token_, uint256 amountIn_) public view override returns (uint256 _amountOut) {\n        _amountOut = (amountIn_ * getPriceInUsd(token_)) / 10**IERC20Metadata(token_).decimals();\n    }\n\n    /// @inheritdoc IOracle\n    function quoteUsdToToken(address token_, uint256 amountIn_) public view override returns (uint256 _amountOut) {\n        _amountOut = (amountIn_ * 10**IERC20Metadata(token_).decimals()) / getPriceInUsd(token_);\n    }\n\n    /// @notice Set custom oracle for a token\n    function _updateTokenOracle(address token_, IOracle oracle_) private {\n        oracles[token_] = oracle_;\n        emit TokenOracleUpdated(token_, oracle_);\n    }\n\n    /// @notice Update the default oracle\n    function updateDefaultOracle(IOracle defaultOracle_) external onlyGovernor {\n        defaultOracle = defaultOracle_;\n        emit DefaultOracleUpdated(defaultOracle_);\n    }\n\n    /// @notice Set custom oracle for a token\n    function updateTokenOracle(address token_, IOracle oracle_) external onlyGovernor {\n        _updateTokenOracle(token_, oracle_);\n    }\n\n    /**\n     * @notice Set custom oracles for a set of tokens\n     * @dev We allow null address inside of the `oracles_` array in order to turn off oracle for a given asset\n     */\n    function updateTokenOracles(address[] calldata tokens_, IOracle[] calldata oracles_) external onlyGovernor {\n        uint256 _tokensLength = tokens_.length;\n        require(_tokensLength > 0 && _tokensLength == oracles_.length, \"invalid-arrays-length\");\n\n        for (uint256 i; i < _tokensLength; ++i) {\n            address _token = tokens_[i];\n            require(_token != address(0), \"a-token-has-null-address\");\n            _updateTokenOracle(_token, oracles_[i]);\n        }\n    }\n}\n"
    },
    "contracts/periphery/ChainlinkOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../interfaces/periphery/IOracle.sol\";\nimport \"../features/UsingStalePeriod.sol\";\n\n/**\n * @title Chainlink oracle\n */\ncontract ChainlinkOracle is IOracle, UsingStalePeriod {\n    constructor(uint256 stalePeriod_) UsingStalePeriod(stalePeriod_) {}\n\n    /// @inheritdoc IOracle\n    function getPriceInUsd(address token_) public view virtual returns (uint256 _priceInUsd) {\n        uint256 _lastUpdatedAt;\n        (_priceInUsd, _lastUpdatedAt) = addressProvider.providersAggregator().getPriceInUsd(\n            DataTypes.Provider.CHAINLINK,\n            token_\n        );\n        require(_priceInUsd > 0 && !_priceIsStale(token_, _lastUpdatedAt), \"price-invalid\");\n    }\n\n    /// @inheritdoc IOracle\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) public view virtual returns (uint256 _amountOut) {\n        uint256 _tokenInLastUpdatedAt;\n        uint256 _tokenOutLastUpdatedAt;\n        (_amountOut, _tokenInLastUpdatedAt, _tokenOutLastUpdatedAt) = addressProvider.providersAggregator().quote(\n            DataTypes.Provider.CHAINLINK,\n            tokenIn_,\n            tokenOut_,\n            amountIn_\n        );\n\n        require(\n            _amountOut > 0 &&\n                !_priceIsStale(tokenIn_, _tokenInLastUpdatedAt) &&\n                !_priceIsStale(tokenIn_, _tokenOutLastUpdatedAt),\n            \"price-invalid\"\n        );\n    }\n\n    /// @inheritdoc IOracle\n    function quoteTokenToUsd(address token_, uint256 amountIn_) public view virtual returns (uint256 _amountOut) {\n        uint256 _lastUpdatedAt;\n        (_amountOut, _lastUpdatedAt) = addressProvider.providersAggregator().quoteTokenToUsd(\n            DataTypes.Provider.CHAINLINK,\n            token_,\n            amountIn_\n        );\n        require(_amountOut > 0 && !_priceIsStale(token_, _lastUpdatedAt), \"price-invalid\");\n    }\n\n    /// @inheritdoc IOracle\n    function quoteUsdToToken(address token_, uint256 amountIn_) public view virtual returns (uint256 _amountOut) {\n        uint256 _lastUpdatedAt;\n        (_amountOut, _lastUpdatedAt) = addressProvider.providersAggregator().quoteUsdToToken(\n            DataTypes.Provider.CHAINLINK,\n            token_,\n            amountIn_\n        );\n        require(_amountOut > 0 && !_priceIsStale(token_, _lastUpdatedAt), \"price-invalid\");\n    }\n}\n"
    },
    "contracts/periphery/ChainlinkAndFallbacksOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../interfaces/core/IPriceProvidersAggregator.sol\";\nimport \"../interfaces/periphery/IOracle.sol\";\nimport \"../features/UsingMaxDeviation.sol\";\nimport \"../features/UsingStalePeriod.sol\";\n\n/**\n * @title Chainlink and Fallbacks oracle\n * @dev Uses chainlink as primary oracle, if it doesn't support the asset(s), get price from fallback providers\n */\ncontract ChainlinkAndFallbacksOracle is IOracle, UsingMaxDeviation, UsingStalePeriod {\n    /// @notice The fallback provider A. It's used when Chainlink isn't available\n    DataTypes.Provider public fallbackProviderA;\n\n    /// @notice The fallback provider B. It's used when Chainlink isn't available\n    /// @dev This is optional\n    DataTypes.Provider public fallbackProviderB;\n\n    /// @notice Emitted when fallback providers are updated\n    event FallbackProvidersUpdated(\n        DataTypes.Provider oldFallbackProviderA,\n        DataTypes.Provider newFallbackProviderA,\n        DataTypes.Provider oldFallbackProviderB,\n        DataTypes.Provider newFallbackProviderB\n    );\n\n    constructor(\n        uint256 maxDeviation_,\n        uint256 stalePeriod_,\n        DataTypes.Provider fallbackProviderA_,\n        DataTypes.Provider fallbackProviderB_\n    ) UsingMaxDeviation(maxDeviation_) UsingStalePeriod(stalePeriod_) {\n        require(fallbackProviderA_ != DataTypes.Provider.NONE, \"fallback-provider-not-set\");\n        fallbackProviderA = fallbackProviderA_;\n        fallbackProviderB = fallbackProviderB_;\n    }\n\n    /// @inheritdoc IOracle\n    function getPriceInUsd(address _asset) public view virtual returns (uint256 _priceInUsd) {\n        // 1. Get price from chainlink\n        uint256 _lastUpdatedAt;\n        (_priceInUsd, _lastUpdatedAt) = _getPriceInUsd(DataTypes.Provider.CHAINLINK, _asset);\n        uint256 _stalePeriod = stalePeriodOf(_asset);\n\n        // 2. If price from chainlink is OK return it\n        if (_priceInUsd > 0 && !_priceIsStale(_lastUpdatedAt, _stalePeriod)) {\n            return _priceInUsd;\n        }\n\n        // 3. Get price from fallback A\n        (uint256 _amountOutA, uint256 _lastUpdatedAtA) = _getPriceInUsd(fallbackProviderA, _asset);\n\n        // 4. If price from fallback A is OK and there isn't a fallback B, return price from fallback A\n        bool _aPriceOK = _amountOutA > 0 && !_priceIsStale(_lastUpdatedAtA, _stalePeriod);\n        if (fallbackProviderB == DataTypes.Provider.NONE) {\n            require(_aPriceOK, \"fallback-a-failed\");\n            return _amountOutA;\n        }\n\n        // 5. Get price from fallback B\n        (uint256 _amountOutB, uint256 _lastUpdatedAtB) = _getPriceInUsd(fallbackProviderB, _asset);\n\n        // 6. If only one price from fallbacks is valid, return it\n        bool _bPriceOK = _amountOutB > 0 && !_priceIsStale(_lastUpdatedAtB, _stalePeriod);\n        if (!_bPriceOK && _aPriceOK) {\n            return _amountOutA;\n        } else if (_bPriceOK && !_aPriceOK) {\n            return _amountOutB;\n        }\n\n        // 7. Check fallback prices deviation\n        require(_aPriceOK && _bPriceOK, \"fallbacks-failed\");\n        require(_isDeviationOK(_amountOutA, _amountOutB), \"prices-deviation-too-high\");\n\n        // 8. If deviation is OK, return price from fallback A\n        return _amountOutA;\n    }\n\n    /// @inheritdoc IOracle\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) public view virtual returns (uint256 _amountOut) {\n        // 1. Get price from chainlink\n        uint256 _tokenInLastUpdatedAt;\n        uint256 _tokenOutLastUpdatedAt;\n        (_amountOut, _tokenInLastUpdatedAt, _tokenOutLastUpdatedAt) = _quote(\n            DataTypes.Provider.CHAINLINK,\n            tokenIn_,\n            tokenOut_,\n            amountIn_\n        );\n\n        // 2. If price from chainlink is OK return it\n        if (\n            _amountOut > 0 &&\n            !_priceIsStale(tokenIn_, _tokenInLastUpdatedAt) &&\n            !_priceIsStale(tokenOut_, _tokenOutLastUpdatedAt)\n        ) {\n            return _amountOut;\n        }\n\n        // 3. Get price from fallback A\n        (uint256 _amountOutA, uint256 _tokenInLastUpdatedAtA, uint256 _tokenOutLastUpdatedAtA) = _quote(\n            fallbackProviderA,\n            tokenIn_,\n            tokenOut_,\n            amountIn_\n        );\n\n        // 4. If price from fallback A is OK and there isn't a fallback B, return price from fallback A\n        bool _aPriceOK = _amountOutA > 0 &&\n            !_priceIsStale(tokenIn_, _tokenInLastUpdatedAtA) &&\n            !_priceIsStale(tokenOut_, _tokenOutLastUpdatedAtA);\n        if (fallbackProviderB == DataTypes.Provider.NONE) {\n            require(_aPriceOK, \"fallback-a-failed\");\n            return _amountOutA;\n        }\n\n        // 5. Get price from fallback B\n        (uint256 _amountOutB, uint256 _tokenInLastUpdatedAtB, uint256 _tokenOutLastUpdatedAtB) = _quote(\n            fallbackProviderB,\n            tokenIn_,\n            tokenOut_,\n            amountIn_\n        );\n\n        // 6. If only one price from fallbacks is valid, return it\n        bool _bPriceOK = _amountOutB > 0 &&\n            !_priceIsStale(tokenIn_, _tokenInLastUpdatedAtB) &&\n            !_priceIsStale(tokenOut_, _tokenOutLastUpdatedAtB);\n        if (!_bPriceOK && _aPriceOK) {\n            return _amountOutA;\n        } else if (_bPriceOK && !_aPriceOK) {\n            return _amountOutB;\n        }\n\n        // 7. Check fallback prices deviation\n        require(_aPriceOK && _bPriceOK, \"fallbacks-failed\");\n        require(_isDeviationOK(_amountOutA, _amountOutB), \"prices-deviation-too-high\");\n\n        // 8. If deviation is OK, return price from fallback A\n        return _amountOutA;\n    }\n\n    /// @inheritdoc IOracle\n    function quoteTokenToUsd(address token_, uint256 amountIn_) public view virtual returns (uint256 _amountOut) {\n        // 1. Get price from chainlink\n        uint256 _lastUpdatedAt;\n        (_amountOut, _lastUpdatedAt) = _quoteTokenToUsd(DataTypes.Provider.CHAINLINK, token_, amountIn_);\n        uint256 _stalePeriod = stalePeriodOf(token_);\n\n        // 2. If price from chainlink is OK return it\n        if (_amountOut > 0 && !_priceIsStale(_lastUpdatedAt, _stalePeriod)) {\n            return _amountOut;\n        }\n\n        // 3. Get price from fallback A\n        (uint256 _amountOutA, uint256 _lastUpdatedAtA) = _quoteTokenToUsd(fallbackProviderA, token_, amountIn_);\n\n        // 4. If price from fallback A is OK and there isn't a fallback B, return price from fallback A\n        bool _aPriceOK = _amountOutA > 0 && !_priceIsStale(_lastUpdatedAtA, _stalePeriod);\n        if (fallbackProviderB == DataTypes.Provider.NONE) {\n            require(_aPriceOK, \"fallback-a-failed\");\n            return _amountOutA;\n        }\n\n        // 5. Get price from fallback B\n        (uint256 _amountOutB, uint256 _lastUpdatedAtB) = _quoteTokenToUsd(fallbackProviderB, token_, amountIn_);\n\n        // 6. If only one price from fallbacks is valid, return it\n        bool _bPriceOK = _amountOutB > 0 && !_priceIsStale(_lastUpdatedAtB, _stalePeriod);\n        if (!_bPriceOK && _aPriceOK) {\n            return _amountOutA;\n        } else if (_bPriceOK && !_aPriceOK) {\n            return _amountOutB;\n        }\n\n        // 7. Check fallback prices deviation\n        require(_aPriceOK && _bPriceOK, \"fallbacks-failed\");\n        require(_isDeviationOK(_amountOutA, _amountOutB), \"prices-deviation-too-high\");\n\n        // 8. If deviation is OK, return price from fallback A\n        return _amountOutA;\n    }\n\n    /// @inheritdoc IOracle\n    function quoteUsdToToken(address token_, uint256 amountIn_) public view virtual returns (uint256 _amountOut) {\n        // 1. Get price from chainlink\n        uint256 _lastUpdatedAt;\n        (_amountOut, _lastUpdatedAt) = _quoteUsdToToken(DataTypes.Provider.CHAINLINK, token_, amountIn_);\n        uint256 _stalePeriod = stalePeriodOf(token_);\n\n        // 2. If price from chainlink is OK return it\n        if (_amountOut > 0 && !_priceIsStale(_lastUpdatedAt, _stalePeriod)) {\n            return _amountOut;\n        }\n\n        // 3. Get price from fallback A\n        (uint256 _amountOutA, uint256 _lastUpdatedAtA) = _quoteUsdToToken(fallbackProviderA, token_, amountIn_);\n\n        // 4. If price from fallback A is OK and there isn't a fallback B, return price from fallback A\n        bool _aPriceOK = _amountOutA > 0 && !_priceIsStale(_lastUpdatedAtA, _stalePeriod);\n        if (fallbackProviderB == DataTypes.Provider.NONE) {\n            require(_aPriceOK, \"fallback-a-failed\");\n            return _amountOutA;\n        }\n\n        // 5. Get price from fallback B\n        (uint256 _amountOutB, uint256 _lastUpdatedAtB) = _quoteUsdToToken(fallbackProviderB, token_, amountIn_);\n\n        // 6. If only one price from fallbacks is valid, return it\n        bool _bPriceOK = _amountOutB > 0 && !_priceIsStale(_lastUpdatedAtB, _stalePeriod);\n        if (!_bPriceOK && _aPriceOK) {\n            return _amountOutA;\n        } else if (_bPriceOK && !_aPriceOK) {\n            return _amountOutB;\n        }\n\n        // 7. Check fallback prices deviation\n        require(_aPriceOK && _bPriceOK, \"fallbacks-failed\");\n        require(_isDeviationOK(_amountOutA, _amountOutB), \"prices-deviation-too-high\");\n\n        // 8. If deviation is OK, return price from fallback A\n        return _amountOutA;\n    }\n\n    /**\n     * @notice Wrapped `getPriceInUsd` function\n     * @dev Return [0,0] (i.e. invalid quote) if the call reverts\n     */\n    function _getPriceInUsd(DataTypes.Provider provider_, address token_)\n        private\n        view\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        try addressProvider.providersAggregator().getPriceInUsd(provider_, token_) returns (\n            uint256 __priceInUsd,\n            uint256 __lastUpdatedAt\n        ) {\n            _priceInUsd = __priceInUsd;\n            _lastUpdatedAt = __lastUpdatedAt;\n        } catch {}\n    }\n\n    /**\n     * @notice Wrapped providers aggregator's `quote` function\n     * @dev Return [0,0] (i.e. invalid quote) if the call reverts\n     */\n    function _quote(\n        DataTypes.Provider provider_,\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        private\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        try addressProvider.providersAggregator().quote(provider_, tokenIn_, tokenOut_, amountIn_) returns (\n            uint256 __amountOut,\n            uint256 __tokenInLastUpdatedAt,\n            uint256 __tokenOutLastUpdatedAt\n        ) {\n            _amountOut = __amountOut;\n\n            _tokenInLastUpdatedAt = __tokenInLastUpdatedAt;\n            _tokenOutLastUpdatedAt = __tokenOutLastUpdatedAt;\n        } catch {}\n    }\n\n    /**\n     * @notice Wrapped providers aggregator's `quoteTokenToUsd` function\n     * @dev Return [0,0] (i.e. invalid quote) if the call reverts\n     */\n    function _quoteTokenToUsd(\n        DataTypes.Provider provider_,\n        address token_,\n        uint256 amountIn_\n    ) private view returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        try addressProvider.providersAggregator().quoteTokenToUsd(provider_, token_, amountIn_) returns (\n            uint256 __amountOut,\n            uint256 __lastUpdatedAt\n        ) {\n            _amountOut = __amountOut;\n            _lastUpdatedAt = __lastUpdatedAt;\n        } catch {}\n    }\n\n    /**\n     * @notice Wrapped providers aggregator's `quoteUsdToToken` function\n     * @dev Return [0,0] (i.e. invalid quote) if the call reverts\n     */\n    function _quoteUsdToToken(\n        DataTypes.Provider provider_,\n        address token_,\n        uint256 amountIn_\n    ) private view returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        try addressProvider.providersAggregator().quoteUsdToToken(provider_, token_, amountIn_) returns (\n            uint256 __amountOut,\n            uint256 __lastUpdatedAt\n        ) {\n            _amountOut = __amountOut;\n            _lastUpdatedAt = __lastUpdatedAt;\n        } catch {}\n    }\n\n    /**\n     * @notice Update fallback providers\n     * @dev The fallback provider B is optional\n     */\n    function updateFallbackProviders(DataTypes.Provider fallbackProviderA_, DataTypes.Provider fallbackProviderB_)\n        external\n        onlyGovernor\n    {\n        require(fallbackProviderA_ != DataTypes.Provider.NONE, \"fallback-a-is-null\");\n        emit FallbackProvidersUpdated(fallbackProviderA, fallbackProviderA_, fallbackProviderB, fallbackProviderB_);\n        fallbackProviderA = fallbackProviderA_;\n        fallbackProviderB = fallbackProviderB_;\n    }\n}\n"
    },
    "contracts/mock/UsingMaxDeviationMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../features/UsingMaxDeviation.sol\";\n\ncontract UsingMaxDeviationMock is UsingMaxDeviation {\n    constructor(uint256 maxDeviation_) UsingMaxDeviation(maxDeviation_) {}\n\n    function isDeviationOK(uint256 a_, uint256 b_) external view returns (bool) {\n        return _isDeviationOK(a_, b_);\n    }\n}\n"
    },
    "contracts/core/StableCoinProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../libraries/OracleHelpers.sol\";\nimport \"../interfaces/core/IStableCoinProvider.sol\";\nimport \"../features/UsingStalePeriod.sol\";\nimport \"../features/UsingMaxDeviation.sol\";\n\n/**\n * @title Provide pegged stable coin, useful for getting USD prices reference from DEXes\n * @dev This contract mitigates a de-peg scenario by checking price against two stable coins that should be around 1\n */\ncontract StableCoinProvider is IStableCoinProvider, UsingStalePeriod, UsingMaxDeviation {\n    using OracleHelpers for uint256;\n\n    uint256 public constant USD_DECIMALS = 18;\n    uint256 public constant ONE_USD = 10**USD_DECIMALS;\n\n    /**\n     * @notice A stable coin to use as USD price reference\n     * @dev Should not be called directly from other contracts, must use `getStableCoinIfPegged`\n     */\n    address public primaryStableCoin;\n    uint8 private __primaryStableCoinDecimals;\n\n    /**\n     * @notice A secondary stable coin used to check USD-peg against primary\n     * @dev Should not be called directly from other contracts, must use `getStableCoinIfPegged`\n     */\n    address public secondaryStableCoin;\n    uint8 private __secondaryStableCoinDecimals;\n\n    /// @notice Emitted when stable coin is updated\n    event StableCoinsUpdated(\n        address oldPrimaryStableCoin,\n        address oldSecondaryStableCoin,\n        address newPrimaryStableCoin,\n        address newSecondaryStableCoin\n    );\n\n    constructor(\n        address primaryStableCoin_,\n        address secondaryStableCoin_,\n        uint256 stalePeriod_,\n        uint256 maxDeviation_\n    ) UsingStalePeriod(stalePeriod_) UsingMaxDeviation(maxDeviation_) {\n        _updateStableCoins(primaryStableCoin_, secondaryStableCoin_);\n    }\n\n    /// @inheritdoc IStableCoinProvider\n    function getStableCoinIfPegged() external view returns (address _stableCoin) {\n        // Note: Chainlink supports DAI/USDC/USDT on all chains that we're using\n        IPriceProvider _chainlink = addressProvider.providersAggregator().priceProviders(DataTypes.Provider.CHAINLINK);\n\n        (uint256 _priceInUsd, uint256 _lastUpdatedAt) = _chainlink.getPriceInUsd(primaryStableCoin);\n\n        if (!_priceIsStale(primaryStableCoin, _lastUpdatedAt) && _isDeviationOK(_priceInUsd, ONE_USD)) {\n            return primaryStableCoin;\n        }\n\n        (_priceInUsd, _lastUpdatedAt) = _chainlink.getPriceInUsd(secondaryStableCoin);\n\n        require(\n            !_priceIsStale(secondaryStableCoin, _lastUpdatedAt) && _isDeviationOK(_priceInUsd, ONE_USD),\n            \"stable-prices-invalid\"\n        );\n\n        return secondaryStableCoin;\n    }\n\n    /// @inheritdoc IStableCoinProvider\n    function toUsdRepresentation(uint256 stableCoinAmount_) external view returns (uint256 _usdAmount) {\n        uint256 _stableCoinDecimals = __primaryStableCoinDecimals;\n        if (_stableCoinDecimals == USD_DECIMALS) {\n            return stableCoinAmount_;\n        }\n        _usdAmount = stableCoinAmount_.scaleDecimal(_stableCoinDecimals, USD_DECIMALS);\n    }\n\n    /**\n     * @notice Update the stable coin keeping correct decimals value\n     * @dev Must have both as set or null\n     */\n    function _updateStableCoins(address primaryStableCoin_, address secondaryStableCoin_) private {\n        require(primaryStableCoin_ != address(0) && secondaryStableCoin_ != address(0), \"stable-coins-are-null\");\n        require(primaryStableCoin_ != secondaryStableCoin_, \"stable-coins-are-the-same\");\n\n        // Update both\n        primaryStableCoin = primaryStableCoin_;\n        secondaryStableCoin = secondaryStableCoin_;\n        __primaryStableCoinDecimals = IERC20Metadata(primaryStableCoin_).decimals();\n        __secondaryStableCoinDecimals = IERC20Metadata(secondaryStableCoin_).decimals();\n    }\n\n    /**\n     * @notice Update stable coin\n     * @dev Used externally by the governor\n     */\n    function updateStableCoins(address primaryStableCoin_, address secondaryStableCoin_) external onlyGovernor {\n        emit StableCoinsUpdated(primaryStableCoin, secondaryStableCoin, primaryStableCoin_, secondaryStableCoin_);\n        _updateStableCoins(primaryStableCoin_, secondaryStableCoin_);\n    }\n}\n"
    },
    "contracts/libraries/OracleHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2;\n\nlibrary OracleHelpers {\n    function scaleDecimal(\n        uint256 amount,\n        uint256 _fromDecimal,\n        uint256 _toDecimal\n    ) internal pure returns (uint256) {\n        if (_fromDecimal > _toDecimal) {\n            return amount / (10**(_fromDecimal - _toDecimal));\n        } else if (_fromDecimal < _toDecimal) {\n            return amount * (10**(_toDecimal - _fromDecimal));\n        }\n        return amount;\n    }\n}\n"
    },
    "contracts/core/UmbrellaPassportPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../dependencies/@umb-network/lib/ValueDecoder.sol\";\nimport \"./UmbrellaPriceProvider.sol\";\nimport \"../interfaces/core/IUmbrellaPassportPriceProvider.sol\";\n\n/**\n * @title Umbrella Passport's Datum receiver & Price provider\n * @dev Based on https://bscscan.com/address/0xd3e5Bf479BF8A2252D89D2990dDE2173869166D0#code\n * Important: This contract assumes that all pallets are USD prices (i.e. `XYZ-USD` quotes).\n */\ncontract UmbrellaPassportPriceProvider is IUmbrellaPassportPriceProvider, UmbrellaPriceProvider {\n    using ValueDecoder for bytes32;\n    using SafeCast for uint256;\n\n    bytes32 private constant DATUM_REGISTRY = bytes32(\"DatumRegistry\");\n\n    struct PriceData {\n        uint224 priceInUsd;\n        uint32 lastUpdatedAt;\n    }\n\n    struct UpdatePolicy {\n        uint128 heartbeatTimestamp; // must update at least once on every heartbeat\n        uint128 deviationThreshold; // must update if deviation reaches threshold (% in 18-decimals)\n    }\n\n    /// @notice Parameters used to accept new prices\n    UpdatePolicy public updatePolicy;\n\n    /// @notice Mapping of latest price of key\n    mapping(bytes32 => PriceData) public latestPriceOf;\n\n    /// @notice Emitted when heartbeat is updated\n    event HeartbeatTimestampUpdated(uint128 oldHeartbeatTimestamp, uint128 newHeartbeatTimestamp);\n\n    /// @notice Emitted when deviation threshold is updated\n    event DeviationThresholdUpdated(uint128 oldDeviationThreshold, uint128 newDeviationThreshold);\n\n    constructor(\n        IRegistry registry_,\n        uint128 heartbeatTimestamp_,\n        uint128 deviationThreshold_\n    ) UmbrellaPriceProvider(registry_) {\n        updatePolicy = UpdatePolicy({heartbeatTimestamp: heartbeatTimestamp_, deviationThreshold: deviationThreshold_});\n    }\n\n    /// @inheritdoc IDatumReceiver\n    function approvePallet(Pallet calldata pallet_) external view virtual override returns (bool) {\n        IChain.Block memory _block = _chain().blocks(pallet_.blockId);\n\n        UpdatePolicy memory _updatePolicy = updatePolicy;\n        PriceData memory _priceData = latestPriceOf[pallet_.key];\n\n        if (_block.dataTimestamp > _priceData.lastUpdatedAt + _updatePolicy.heartbeatTimestamp) {\n            return true;\n        }\n\n        uint224 _latestPrice = _priceData.priceInUsd;\n        uint224 _newPrice = pallet_.value.toUint().toUint224();\n        uint256 _deviation = _latestPrice > _newPrice\n            ? ((_latestPrice - _newPrice) * 1e18) / _latestPrice\n            : ((_newPrice - _latestPrice) * 1e18) / _newPrice;\n\n        require(_deviation > _updatePolicy.deviationThreshold, \"did-not-match-conditions\");\n\n        return true;\n    }\n\n    /// @inheritdoc IDatumReceiver\n    function receivePallet(Pallet calldata pallet_) external virtual override {\n        require(msg.sender == registry.getAddress(DATUM_REGISTRY), \"not-datum-registry\");\n\n        uint32 _palletTimestamp = _chain().blocks(pallet_.blockId).dataTimestamp;\n\n        require(latestPriceOf[pallet_.key].lastUpdatedAt < _palletTimestamp, \"update-already-received\");\n\n        latestPriceOf[pallet_.key] = PriceData({\n            lastUpdatedAt: _palletTimestamp,\n            priceInUsd: pallet_.value.toUint().toUint224()\n        });\n    }\n\n    /// @inheritdoc IUmbrellaPassportPriceProvider\n    function updateHeartbeatTimestamp(uint128 heartbeatTimestamp_) external onlyGovernor {\n        emit HeartbeatTimestampUpdated(updatePolicy.heartbeatTimestamp, heartbeatTimestamp_);\n        updatePolicy.heartbeatTimestamp = heartbeatTimestamp_;\n    }\n\n    /// @inheritdoc IUmbrellaPassportPriceProvider\n    function updateDeviationThreshold(uint128 deviationThreshold_) external onlyGovernor {\n        emit DeviationThresholdUpdated(updatePolicy.deviationThreshold, deviationThreshold_);\n        updatePolicy.deviationThreshold = deviationThreshold_;\n    }\n\n    /**\n     * @inheritdoc IPriceProvider\n     * @dev Get the latest price between Chain (Firs Class Data) and Passport data\n     */\n    function getPriceInUsd(address token_)\n        public\n        view\n        override(IPriceProvider, UmbrellaPriceProvider)\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        bytes32 _key = keyOfToken[token_];\n\n        (_priceInUsd, _lastUpdatedAt) = _chain().getCurrentValue(_key);\n        PriceData memory _priceData = latestPriceOf[_key];\n\n        if (_priceData.lastUpdatedAt >= _lastUpdatedAt) {\n            _priceInUsd = _priceData.priceInUsd;\n            _lastUpdatedAt = _priceData.lastUpdatedAt;\n        }\n\n        require(_lastUpdatedAt > 0, \"invalid-quote\");\n    }\n}\n"
    },
    "contracts/dependencies/@umb-network/lib/ValueDecoder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nlibrary ValueDecoder {\n  function toUint(bytes memory _bytes) internal pure returns (uint256 value) {\n    assembly {\n      value := mload(add(_bytes, 32))\n    }\n  }\n\n  function toUint(bytes32 _bytes) internal pure returns (uint256 value) {\n    assembly {\n      value := _bytes\n    }\n  }\n\n  function toInt(uint224 u) internal pure returns (int256) {\n    int224 i;\n    uint224 max = type(uint224).max;\n\n    if (u <= (max - 1) / 2) { // positive values\n      assembly {\n        i := add(u, 0)\n      }\n\n      return i;\n    } else { // negative values\n      assembly {\n        i := sub(sub(u, max), 1)\n      }\n    }\n\n    return i;\n  }\n}\n\n"
    },
    "contracts/core/UmbrellaPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@umb-network/toolbox/dist/contracts/IChain.sol\";\nimport \"@umb-network/toolbox/dist/contracts/IRegistry.sol\";\nimport \"../access/Governable.sol\";\nimport \"../interfaces/core/IUmbrellaPriceProvider.sol\";\nimport \"./PriceProvider.sol\";\n\n/**\n * @notice Umbrella's price provider\n */\ncontract UmbrellaPriceProvider is IUmbrellaPriceProvider, PriceProvider, Governable {\n    bytes32 private constant CHAIN = bytes32(\"Chain\");\n\n    /**\n     * @notice token => Umbrella's key mapping (e.g. WBTC => \"BTC-USD\")\n     */\n    mapping(address => bytes32) public keyOfToken;\n\n    /**\n     * @notice Umbrella's Registry\n     * @dev Stores the other Umbrella's contracts' addresses\n     */\n    IRegistry public immutable registry;\n\n    event KeyOfTokenUpdated(address indexed token, bytes32 oldKey, bytes32 newKey);\n\n    constructor(IRegistry registry_) {\n        require(address(registry_) != address(0), \"registry-is-null\");\n        registry = registry_;\n    }\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(address token_)\n        public\n        view\n        virtual\n        override(IPriceProvider, PriceProvider)\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        (_priceInUsd, _lastUpdatedAt) = _chain().getCurrentValue(keyOfToken[token_]);\n        require(_lastUpdatedAt > 0, \"invalid-quote\");\n    }\n\n    /**\n     * @notice Get Umbrella's main contract\n     */\n    function _chain() internal view returns (IChain umbChain) {\n        umbChain = IChain(registry.getAddress(CHAIN));\n    }\n\n    /**\n     * @notice Build key from quote/base string in bytes format\n     * @dev The standard parser `bytes32(bytes)` will right pad with zeros\n     * but Umbrella expects left padded bytes as key\n     * @dev See if there is a simpler way to do the same as this function\n     */\n    function _toKey(bytes memory quotePairAsBytes_) private pure returns (bytes32) {\n        bytes memory _aux = new bytes(32);\n        uint256 _len = quotePairAsBytes_.length;\n        for (uint256 i; i < _len; ++i) {\n            uint256 _idx = 32 - _len + i;\n            _aux[_idx] = quotePairAsBytes_[i];\n        }\n        return bytes32(_aux);\n    }\n\n    /**\n     * @notice Update Umbrella's key of a token\n     * Use `BASE-QUOTE` format (e.g. BTC-USD, ETH-USD, etc)\n     */\n    function updateKeyOfToken(address token_, string memory quotePair_) external onlyGovernor {\n        require(token_ != address(0), \"address-is-null\");\n        bytes32 _currentKey = keyOfToken[token_];\n        bytes32 _newKey = _toKey(bytes(quotePair_));\n        keyOfToken[token_] = _newKey;\n        emit KeyOfTokenUpdated(token_, _currentKey, _newKey);\n    }\n}\n"
    },
    "contracts/interfaces/core/IUmbrellaPassportPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../dependencies/@umb-network/interfaces/IDatumReceiver.sol\";\nimport \"./IUmbrellaPriceProvider.sol\";\n\ninterface IUmbrellaPassportPriceProvider is IUmbrellaPriceProvider, IDatumReceiver {\n    /**\n     * @notice Updates heartbeat\n     */\n    function updateHeartbeatTimestamp(uint128 heartbeatTimestamp_) external;\n\n    /**\n     * @notice Updates deviation threshold\n     */\n    function updateDeviationThreshold(uint128 deviationThreshold_) external;\n}\n"
    },
    "contracts/interfaces/core/IUmbrellaPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./IPriceProvider.sol\";\n\ninterface IUmbrellaPriceProvider is IPriceProvider {}\n"
    },
    "@umb-network/toolbox/dist/contracts/IChain.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.8;\npragma abicoder v2;\n\ninterface IChain {\n  struct Block {\n    bytes32 root;\n    uint32 dataTimestamp;\n  }\n\n  struct FirstClassData {\n    uint224 value;\n    uint32 dataTimestamp;\n  }\n\n  function isForeign() external pure returns (bool);\n\n  function blocks(uint256) external view returns (Block memory);\n\n  function fcds(bytes32) external view returns (FirstClassData memory);\n\n  function blocksCount() external view returns (uint32);\n\n  function blocksCountOffset() external view returns (uint32);\n\n  function padding() external view returns (uint16);\n\n  function getName() external pure returns (bytes32);\n\n  function recoverSigner(bytes32 affidavit, uint8 _v, bytes32 _r, bytes32 _s) external pure returns (address);\n\n  function getStatus() external view returns(\n    uint256 blockNumber,\n    uint16 timePadding,\n    uint32 lastDataTimestamp,\n    uint32 lastBlockId,\n    address nextLeader,\n    uint32 nextBlockId,\n    address[] memory validators,\n    uint256[] memory powers,\n    string[] memory locations,\n    uint256 staked\n  );\n\n  function getBlockId() external view returns (uint32);\n\n  // this function does not works for past timestamps\n  function getBlockIdAtTimestamp(uint256 _timestamp) external view returns (uint32);\n\n  function getLatestBlockId() external view returns (uint32);\n\n  function getLeaderIndex(uint256 _numberOfValidators, uint256 _timestamp) external view returns (uint256);\n\n  function getNextLeaderAddress() external view returns (address);\n\n  function getLeaderAddress() external view returns (address);\n\n  function getLeaderAddressAtTime(uint232 _timestamp) external view returns (address);\n\n  function hashLeaf(bytes calldata _key, bytes calldata _value) external pure returns (bytes32);\n\n  function verifyProof(bytes32[] calldata _proof, bytes32 _root, bytes32 _leaf) external pure returns (bool);\n\n  function verifyProofForBlock(\n    uint256 _blockId,\n    bytes32[] calldata _proof,\n    bytes calldata _key,\n    bytes calldata _value\n  ) external view returns (bool);\n\n  function bytesToBytes32Array(\n    bytes calldata _data,\n    uint256 _offset,\n    uint256 _items\n  ) external pure returns (bytes32[] memory);\n\n  function verifyProofs(\n    uint32[] memory _blockIds,\n    bytes memory _proofs,\n    uint256[] memory _proofItemsCounter,\n    bytes32[] memory _leaves\n  ) external view returns (bool[] memory results);\n  \n  function getBlockRoot(uint256 _blockId) external view returns (bytes32);\n\n  function getBlockTimestamp(uint32 _blockId) external view returns (uint32);\n\n  function getCurrentValues(bytes32[] calldata _keys)\n  external view returns (uint256[] memory values, uint32[] memory timestamps);\n\n  function getCurrentValue(bytes32 _key) external view returns (uint256 value, uint256 timestamp);\n}\n"
    },
    "@umb-network/toolbox/dist/contracts/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.8;\n\ninterface IRegistry {\n  function registry(bytes32 _name) external view returns (address);\n\n  function requireAndGetAddress(bytes32 _name) external view returns (address);\n\n  function getAddress(bytes32 _bytes) external view returns (address);\n\n  function getAddressByString(string memory _name) external view returns (address);\n\n  function stringToBytes32(string memory _string) external pure returns (bytes32);\n}\n"
    },
    "contracts/dependencies/@umb-network/interfaces/IDatumReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../lib/PassportStructs.sol\";\n\ninterface IDatumReceiver {\n  /// @notice This function will hold the parameters or business rules that consumer\n  /// wants to do with the received data structure, here called Pallet.\n  /// @param _pallet the structure sent by DatumRegistry, containing proof, key and value\n  function receivePallet(Pallet calldata _pallet) external;\n\n  /// @notice This function holds rules that consumer may need to check before accepting\n  /// the Pallet. Rules like how old is the block, or how many blocks have passed since\n  /// last storage. Deliverer will check if approvePallet reverted this call or returned true.\n  /// @param _pallet The exact same Pallet that will arrive at the receivePallet endpoint.\n  /// @return true if wants pallet or should REVERT if Contract does not want the pallet.\n  /// @dev DO NOT RETURN false.\n  function approvePallet(Pallet calldata _pallet) external view returns (bool);\n}\n"
    },
    "contracts/dependencies/@umb-network/lib/PassportStructs.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nstruct Datum {\n  address receiver;\n  bytes32[] keys;\n  address funder;\n  uint128 balance;\n  bool enabled;\n}\n\nstruct Pallet {\n  uint32 blockId;\n  bytes32 key;\n  bytes32 value;\n  bytes32[] proof;\n}\n\nstruct Delivery {\n  bytes32 datumId;\n  uint256[] indexes;\n}\n"
    },
    "contracts/core/FluxPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../interfaces/core/IFluxPriceProvider.sol\";\nimport \"../features/UsingMaxDeviation.sol\";\nimport \"./PriceProvider.sol\";\n\n/**\n * @title Flux's price provider\n * @dev The Flux uses the same aggregator's interface as Chainlink\n */\ncontract FluxPriceProvider is IFluxPriceProvider, PriceProvider, UsingMaxDeviation {\n    using SafeCast for int256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 public constant FLUX_DECIMALS = 8;\n    uint256 public constant TO_SCALE = 10**(USD_DECIMALS - FLUX_DECIMALS);\n\n    /**\n     * @notice Aggregators map (token => aggregator[])\n     */\n    mapping(address => EnumerableSet.AddressSet) internal aggregatorsOf;\n\n    /// Emitted when an aggregator is added\n    event AggregatorAdded(address token, address aggregator);\n\n    /// Emitted when an aggregator is removed\n    event AggregatorRemoved(address token, address aggregator);\n\n    constructor(uint256 maxDeviation_) UsingMaxDeviation(maxDeviation_) {}\n\n    /**\n     * @notice Get all aggregators of token\n     * @dev WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees.\n     */\n    function getAggregatorsOf(address token_) external view returns (address[] memory) {\n        return aggregatorsOf[token_].values();\n    }\n\n    /**\n     * @inheritdoc IPriceProvider\n     * @dev Sweep all aggregators and get the most recent price, revert if deviation among prices are too high.\n     */\n    function getPriceInUsd(address token_)\n        public\n        view\n        override(IPriceProvider, PriceProvider)\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        EnumerableSet.AddressSet storage _aggregatorOf = aggregatorsOf[token_];\n\n        uint256 _len = aggregatorsOf[token_].length();\n        require(_len > 0, \"aggregator-not-found\");\n        int256 _price;\n        (, _price, , _lastUpdatedAt, ) = AggregatorV3Interface(_aggregatorOf.at(0)).latestRoundData();\n\n        for (uint256 i = 1; i < _len; ++i) {\n            (, int256 _iPrice, , uint256 _iLastUpdatedAt, ) = AggregatorV3Interface(_aggregatorOf.at(i))\n                .latestRoundData();\n\n            require(_isDeviationOK(_iPrice.toUint256(), _price.toUint256()), \"prices-deviation-too-high\");\n\n            if (_iLastUpdatedAt > _lastUpdatedAt) {\n                _price = _iPrice;\n                _lastUpdatedAt = _iLastUpdatedAt;\n            }\n        }\n\n        return (_price.toUint256() * TO_SCALE, _lastUpdatedAt);\n    }\n\n    /// @inheritdoc IFluxPriceProvider\n    function addAggregator(address token_, address aggregator_) external override onlyGovernor {\n        require(token_ != address(0), \"token-is-null\");\n        require(aggregator_ != address(0), \"aggregator-is-null\");\n        require(AggregatorV3Interface(aggregator_).decimals() == FLUX_DECIMALS, \"invalid-decimals\");\n        require(aggregatorsOf[token_].add(aggregator_), \"aggregator-exists\");\n\n        emit AggregatorAdded(token_, aggregator_);\n    }\n\n    /// @inheritdoc IFluxPriceProvider\n    function removeAggregator(address token_, address aggregator_) external override onlyGovernor {\n        require(token_ != address(0), \"token-is-null\");\n        require(aggregator_ != address(0), \"aggregator-is-null\");\n\n        require(aggregatorsOf[token_].remove(aggregator_), \"aggregator-doesnt-exist\");\n\n        emit AggregatorRemoved(token_, aggregator_);\n    }\n}\n"
    },
    "contracts/interfaces/core/IFluxPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./IPriceProvider.sol\";\n\ninterface IFluxPriceProvider is IPriceProvider {\n    /**\n     * @notice Add an aggregator to the token\n     */\n    function addAggregator(address token_, address aggregator_) external;\n\n    /**\n     * @notice Remove an aggregator from the token\n     */\n    function removeAggregator(address token_, address aggregator_) external;\n}\n"
    },
    "contracts/core/ChainlinkPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../interfaces/core/IChainlinkPriceProvider.sol\";\nimport \"./PriceProvider.sol\";\nimport \"../access/Governable.sol\";\n\n/**\n * @title ChainLink's price provider\n * @dev This contract wraps chainlink aggregators\n */\ncontract ChainlinkPriceProvider is IChainlinkPriceProvider, PriceProvider, Governable {\n    using SafeCast for int256;\n\n    uint256 public constant CHAINLINK_DECIMALS = 8;\n    uint256 public constant TO_SCALE = 10**(USD_DECIMALS - CHAINLINK_DECIMALS);\n\n    /**\n     * @notice Aggregators map (token => aggregator)\n     */\n    mapping(address => AggregatorV3Interface) public aggregators;\n\n    /// Emitted when an aggregator is updated\n    event AggregatorUpdated(address token, AggregatorV3Interface oldAggregator, AggregatorV3Interface newAggregator);\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(address token_)\n        public\n        view\n        virtual\n        override(IPriceProvider, PriceProvider)\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        AggregatorV3Interface _aggregator = aggregators[token_];\n        require(address(_aggregator) != address(0), \"token-without-aggregator\");\n        int256 _price;\n        (, _price, , _lastUpdatedAt, ) = _aggregator.latestRoundData();\n        return (_price.toUint256() * TO_SCALE, _lastUpdatedAt);\n    }\n\n    /// @inheritdoc IChainlinkPriceProvider\n    function updateAggregator(address token_, AggregatorV3Interface aggregator_) external override onlyGovernor {\n        require(token_ != address(0), \"token-is-null\");\n        AggregatorV3Interface _current = aggregators[token_];\n        require(aggregator_ != _current, \"same-as-current\");\n        _setAggregator(token_, aggregator_);\n        emit AggregatorUpdated(token_, _current, aggregator_);\n    }\n\n    function _setAggregator(address token_, AggregatorV3Interface aggregator_) internal {\n        require(address(aggregator_) == address(0) || aggregator_.decimals() == CHAINLINK_DECIMALS, \"invalid-decimals\");\n        aggregators[token_] = aggregator_;\n    }\n}\n"
    },
    "contracts/interfaces/core/IChainlinkPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./IPriceProvider.sol\";\n\ninterface IChainlinkPriceProvider is IPriceProvider {\n    /**\n     * @notice Update token's aggregator\n     */\n    function updateAggregator(address token_, AggregatorV3Interface aggregator_) external;\n}\n"
    },
    "contracts/core/ChainlinkPolygonPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./ChainlinkPriceProvider.sol\";\n\n/**\n * @title Chainlink's price provider for Polygon network\n */\ncontract ChainlinkPolygonPriceProvider is ChainlinkPriceProvider {\n    constructor() {\n        // Polygon's aggregators: https://docs.chain.link/docs/matic-addresses/\n        _setAggregator(0x9c2C5fd7b07E95EE044DDeba0E97a665F142394f, AggregatorV3Interface(0x443C5116CdF663Eb387e72C688D276e702135C87)); // 1INCH\n        _setAggregator(0xD6DF932A45C0f255f85145f286eA0b292B21C90B, AggregatorV3Interface(0x72484B12719E23115761D5DA1646945632979bB6)); // AAVE\n        _setAggregator(0x3Cef98bb43d732E2F285eE605a8158cDE967D219, AggregatorV3Interface(0x2346Ce62bd732c62618944E51cbFa09D985d86D2)); // BAT\n        _setAggregator(0x3BA4c387f786bFEE076A58914F5Bd38d668B42c3, AggregatorV3Interface(0x82a6c4AF830caa6c97bb504425f6A66165C2c26e)); // BNB\n        _setAggregator(0xc26D47d5c33aC71AC5CF9F776D63Ba292a4F7842, AggregatorV3Interface(0xF5724884b6E99257cC003375e6b844bC776183f9)); // BNT\n        _setAggregator(0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6, AggregatorV3Interface(0xc907E116054Ad103354f2D350FD2514433D57F6f)); // WBTC\n        _setAggregator(0xD85d1e945766Fea5Eda9103F918Bd915FbCa63E6, AggregatorV3Interface(0xc9ECF45956f576681bDc01F79602A79bC2667B0c)); // CEL\n        _setAggregator(0xf1938Ce12400f9a761084E7A80d37e732a4dA056, AggregatorV3Interface(0x2409987e514Ad8B0973C2b90ee1D95051DF0ECB9)); // CHZ\n        _setAggregator(0x8505b9d2254A7Ae468c0E9dd10Ccea3A837aef5c, AggregatorV3Interface(0x2A8758b7257102461BC958279054e372C2b1bDE6)); // COMP\n        _setAggregator(0x172370d5Cd63279eFa6d502DAB29171933a610AF, AggregatorV3Interface(0x336584C8E6Dc19637A5b36206B1c79923111b405)); // CRV\n        _setAggregator(0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063, AggregatorV3Interface(0x4746DeC9e833A82EC7C2C1356372CcF2cfcD2F3D)); // DAI\n        _setAggregator(0x7eC26842F195c852Fa843bB9f6D8B583a274a157, AggregatorV3Interface(0x440A341bbC9FA86aA60A195e2409a547e48d4C0C)); // ENJ\n        _setAggregator(0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619, AggregatorV3Interface(0xF9680D99D6C9589e2a93a78A04A279e509205945)); // WETH\n        _setAggregator(0x45c32fA6DF82ead1e2EF74d17b76547EDdFaFF89, AggregatorV3Interface(0x00DBeB1e45485d53DF7C2F0dF1Aa0b6Dc30311d3)); // FRAX\n        _setAggregator(0xC9c1c1c20B3658F8787CC2FD702267791f224Ce1, AggregatorV3Interface(0x58326c0F831b2Dbf7234A4204F28Bba79AA06d5f)); // FTM\n        _setAggregator(0x1a3acf6D19267E2d3e7f898f42803e90C9219062, AggregatorV3Interface(0x6C0fe985D3cAcbCdE428b84fc9431792694d0f51)); // FXS\n        _setAggregator(0x385Eeac5cB85A38A9a07A70c73e0a3271CfB54A7, AggregatorV3Interface(0xDD229Ce42f11D8Ee7fFf29bDB71C7b81352e11be)); // GHST\n        _setAggregator(0x5FFD62D3C3eE2E81C00A7b9079FB248e7dF024A8, AggregatorV3Interface(0x432fa0899cF1BcDb98592D7eAA23C372b8b8ddf2)); // GNO\n        _setAggregator(0x5fe2B58c013d7601147DcdD68C143A77499f5531, AggregatorV3Interface(0x3FabBfb300B1e2D7c9B84512fe9D30aeDF24C410)); // GRT\n        _setAggregator(0xFAD65Eb62a97fF5Ed91B23aFD039956aaCa6e93b, AggregatorV3Interface(0x6F8F9e75C0285AecE30ADFe1BCc1955f145d971A)); // HT\n        _setAggregator(0x42f37A1296b2981F7C3cAcEd84c5096b2Eb0C72C, AggregatorV3Interface(0x5438E60A06C7447432512264Fa57e2FeD3224b33)); // KEEP\n        _setAggregator(0x1C954E8fe737F99f68Fa1CCda3e51ebDB291948C, AggregatorV3Interface(0x10e5f3DFc81B3e5Ef4e648C4454D04e79E1E41E2)); // KNC\n        _setAggregator(0x53E0bca35eC356BD5ddDFebbD1Fc0fD03FaBad39, AggregatorV3Interface(0xd9FFdb71EbE7496cC440152d43986Aae0AB76665)); // LINK\n        _setAggregator(0x3962F4A0A0051DccE0be73A7e09cEf5756736712, AggregatorV3Interface(0xBAaF11CeDA1d1Ca9Cf01748F8196653c9656a400)); // LPT\n        _setAggregator(0xA1c57f48F0Deb89f569dFbE6E2B7f46D33606fD4, AggregatorV3Interface(0xA1CbF3Fe43BC3501e3Fc4b573e822c70e76A7512)); // MANA\n        _setAggregator(0x6f7C932e7684666C9fd1d44527765433e01fF61d, AggregatorV3Interface(0xa070427bF5bA5709f70e98b94Cb2F435a242C46C)); // MKR\n        _setAggregator(0x41b3966B4FF7b427969ddf5da3627d6AEAE9a48E, AggregatorV3Interface(0x666bb13b3ED3816504E8c30D0F9B9C16b371774b)); // NEXO\n        _setAggregator(0x282d8efCe846A88B159800bd4130ad77443Fa1A1, AggregatorV3Interface(0xdcda79097C44353Dee65684328793695bd34A629)); // OCEAN\n        _setAggregator(0x62414D03084EeB269E18C970a21f45D2967F0170, AggregatorV3Interface(0x93FfEE768F74208a7b9f2a4426f0F6BCbb1D09de)); // OMG\n        _setAggregator(0x6F3B3286fd86d8b47EC737CEB3D0D354cc657B3e, AggregatorV3Interface(0x56D55D34EcC616e71ae998aCcba79F236ff2ff46)); // PAX\n        _setAggregator(0x553d3D295e0f695B9228246232eDF400ed3560B5, AggregatorV3Interface(0x0f6914d8e7e1214CDb3A4C6fbf729b75C69DF608)); // PAXG\n        _setAggregator(0xcB059C5573646047D6d88dDdb87B745C18161d3b, AggregatorV3Interface(0xC741F7752BAe936fCE97933b755884AF66fB69C1)); // POLY\n        _setAggregator(0xBbba073C31bF03b8ACf7c28EF0738DeCF3695683, AggregatorV3Interface(0x3D49406EDd4D52Fb7FFd25485f32E073b529C924)); // SAND\n        _setAggregator(0x50B728D8D964fd00C2d0AAD81718b71311feF68a, AggregatorV3Interface(0xbF90A5D9B6EE9019028dbFc2a9E50056d5252894)); // SNX\n        _setAggregator(0x6Bf2eb299E51Fc5DF30Dec81D9445dDe70e3F185, AggregatorV3Interface(0xd8F8a7a38A1ac326312000d0a0218BF3216BfAbB)); // SRM\n        _setAggregator(0x0b3F868E0BE5597D5DB7fEB59E1CADBb0fdDa50a, AggregatorV3Interface(0x49B0c695039243BBfEb8EcD054EB70061fd54aa0)); // SUSHI\n        _setAggregator(0xB46E0ae620EFd98516f49bb00263317096C114b2, AggregatorV3Interface(0x38611b09F8f2D520c14eA973765C225Bf57B9Eac)); // THETA\n        _setAggregator(0x2e1AD108fF1D8C782fcBbB89AAd783aC49586756, AggregatorV3Interface(0x7C5D415B64312D38c56B54358449d0a4058339d2)); // TUSD\n        _setAggregator(0x3066818837c5e6eD6601bd5a91B0762877A6B731, AggregatorV3Interface(0x33D9B1BAaDcF4b26ab6F8E83e9cb8a611B2B3956)); // UMA\n        _setAggregator(0xb33EaAd8d922B1083446DC23f610c2567fB5180f, AggregatorV3Interface(0xdf0Fb4e4F928d2dCB76f438575fDD8682386e13C)); // UNI\n        _setAggregator(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174, AggregatorV3Interface(0xfE4A8cc5b5B2366C1B58Bea3858e81843581b2F7)); // USDC\n        _setAggregator(0xc2132D05D31c914a87C6611C10748AEb04B58e8F, AggregatorV3Interface(0x0A6513e40db6EB1b165753AD52E80663aeA50545)); // USDT\n        _setAggregator(0xDA537104D6A5edd53c6fBba9A898708E465260b6, AggregatorV3Interface(0x9d3A43c111E7b2C6601705D9fcF7a70c95b1dc55)); // YFI\n        _setAggregator(0x5559Edb74751A0edE9DeA4DC23aeE72cCA6bE3D5, AggregatorV3Interface(0x6EA4d89474d9410939d429B786208c74853A5B47)); // ZRX\n    }\n}\n"
    },
    "contracts/core/ChainlinkMainnetPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol\";\nimport \"./ChainlinkPriceProvider.sol\";\nimport \"../libraries/OracleHelpers.sol\";\n\n/**\n * @title Chainlink's price provider for Mainnet network\n * @dev Not uses price feed in order to save gas\n */\ncontract ChainlinkMainnetPriceProvider is ChainlinkPriceProvider {\n    constructor() {\n        // Mainnet's aggregators: https://docs.chain.link/docs/ethereum-addresses/\n        // Note: These are NOT all available aggregators, not adding them all to avoid too expensive deployment cost\n        _setAggregator(0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9, AggregatorV3Interface(0x547a514d5e3769680Ce22B2361c10Ea13619e8a9)); // AAVE\n        _setAggregator(0x85f138bfEE4ef8e540890CFb48F620571d67Eda3, AggregatorV3Interface(0xFF3EEb22B5E3dE6e705b44749C2559d704923FD7)); // WAVAX\n        _setAggregator(0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C, AggregatorV3Interface(0x1E6cF0D433de4FE882A437ABC654F58E1e78548c)); // BNT\n        _setAggregator(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599, AggregatorV3Interface(0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c)); // WBTC\n        _setAggregator(0xc00e94Cb662C3520282E6f5717214004A7f26888, AggregatorV3Interface(0xdbd020CAeF83eFd542f4De03e3cF0C28A4428bd5)); // COMP\n        _setAggregator(0xD533a949740bb3306d119CC777fa900bA034cd52, AggregatorV3Interface(0xCd627aA160A6fA45Eb793D19Ef54f5062F20f33f)); // CRV\n        _setAggregator(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B, AggregatorV3Interface(0xd962fC30A72A84cE50161031391756Bf2876Af5D)); // CVX\n        _setAggregator(0x6B175474E89094C44Da98b954EedeAC495271d0F, AggregatorV3Interface(0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9)); // DAI\n        _setAggregator(0x1494CA1F11D487c2bBe4543E90080AeBa4BA3C2b, AggregatorV3Interface(0xD2A593BF7594aCE1faD597adb697b5645d5edDB2)); // DPI\n        _setAggregator(0x92D6C1e31e14520e676a687F0a93788B716BEff5, AggregatorV3Interface(0x478909D4D798f3a1F11fFB25E4920C959B4aDe0b)); // DYDX\n        _setAggregator(0xC18360217D8F7Ab5e7c516566761Ea12Ce7F9D72, AggregatorV3Interface(0x5C00128d4d1c2F4f652C267d7bcdD7aC99C16E16)); // ENS\n        _setAggregator(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419)); // WETH\n        _setAggregator(0x956F47F50A910163D8BF957Cf5846D573E7f87CA, AggregatorV3Interface(0x31e0a88fecB6eC0a411DBe0e9E76391498296EE9)); // FEI\n        _setAggregator(0x853d955aCEf822Db058eb8505911ED77F175b99e, AggregatorV3Interface(0xB9E1E3A9feFf48998E45Fa90847ed4D467E8BcfD)); // FRAX\n        _setAggregator(0xc944E90C64B2c07662A292be6244BDf05Cda44a7, AggregatorV3Interface(0x86cF33a451dE9dc61a2862FD94FF4ad4Bd65A5d2)); // GRT\n        _setAggregator(0x056Fd409E1d7A124BD7017459dFEa2F387b6d5Cd, AggregatorV3Interface(0xa89f5d2365ce98B3cD68012b6f503ab1416245Fc)); // GUSD\n        _setAggregator(0x514910771AF9Ca656af840dff83E8264EcF986CA, AggregatorV3Interface(0x2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c)); // LINK\n        _setAggregator(0x0F5D2fB29fb7d3CFeE444a200298f468908cC942, AggregatorV3Interface(0x56a4857acbcfe3a66965c251628B1c9f1c408C19)); // MANA\n        _setAggregator(0x7c9f4C87d911613Fe9ca58b579f737911AAD2D43, AggregatorV3Interface(0x7bAC85A8a13A4BcD8abb3eB7d6b4d632c5a57676)); // WMATIC\n        _setAggregator(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3, AggregatorV3Interface(0x7A364e8770418566e3eb2001A96116E6138Eb32F)); // MIM\n        _setAggregator(0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2, AggregatorV3Interface(0xec1D1B3b0443256cc3860e24a46F108e699484Aa)); // MKR\n        _setAggregator(0xd26114cd6EE289AccF82350c8d8487fedB8A0C07, AggregatorV3Interface(0x7D476f061F8212A8C9317D5784e72B4212436E93)); // OMG\n        _setAggregator(0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F, AggregatorV3Interface(0xDC3EA94CD0AC27d9A86C180091e7f78C683d3699)); // SNX\n        _setAggregator(0x090185f2135308BaD17527004364eBcC2D37e5F6, AggregatorV3Interface(0x8c110B94C5f1d347fAcF5E1E938AB2db60E3c9a8)); // SPELL\n        _setAggregator(0x57Ab1ec28D129707052df4dF418D58a2D46d5f51, AggregatorV3Interface(0xad35Bd71b9aFE6e4bDc266B345c198eaDEf9Ad94)); // sUSD\n        _setAggregator(0x6B3595068778DD592e39A122f4f5a5cF09C90fE2, AggregatorV3Interface(0xCc70F09A6CC17553b2E31954cD36E4A2d89501f7)); // SUSHI\n        _setAggregator(0x0000000000085d4780B73119b644AE5ecd22b376, AggregatorV3Interface(0xec746eCF986E2927Abd291a2A1716c940100f8Ba)); // TUSD\n        _setAggregator(0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984, AggregatorV3Interface(0x553303d460EE0afB37EdFf9bE42922D8FF63220e)); // UNI\n        _setAggregator(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, AggregatorV3Interface(0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6)); // USDC\n        _setAggregator(0xdAC17F958D2ee523a2206206994597C13D831ec7, AggregatorV3Interface(0x3E7d1eAB13ad0104d2750B8863b489D65364e32D)); // USDT\n        _setAggregator(0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e, AggregatorV3Interface(0xA027702dbb89fbd58938e4324ac03B58d812b0E1)); // YFI\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"./AggregatorV2V3Interface.sol\";\n\ninterface FeedRegistryInterface {\n  struct Phase {\n    uint16 phaseId;\n    uint80 startingAggregatorRoundId;\n    uint80 endingAggregatorRoundId;\n  }\n\n  event FeedProposed(\n    address indexed asset,\n    address indexed denomination,\n    address indexed proposedAggregator,\n    address currentAggregator,\n    address sender\n  );\n  event FeedConfirmed(\n    address indexed asset,\n    address indexed denomination,\n    address indexed latestAggregator,\n    address previousAggregator,\n    uint16 nextPhaseId,\n    address sender\n  );\n\n  // V3 AggregatorV3Interface\n\n  function decimals(address base, address quote) external view returns (uint8);\n\n  function description(address base, address quote) external view returns (string memory);\n\n  function version(address base, address quote) external view returns (uint256);\n\n  function latestRoundData(address base, address quote)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function getRoundData(\n    address base,\n    address quote,\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  // V2 AggregatorInterface\n\n  function latestAnswer(address base, address quote) external view returns (int256 answer);\n\n  function latestTimestamp(address base, address quote) external view returns (uint256 timestamp);\n\n  function latestRound(address base, address quote) external view returns (uint256 roundId);\n\n  function getAnswer(\n    address base,\n    address quote,\n    uint256 roundId\n  ) external view returns (int256 answer);\n\n  function getTimestamp(\n    address base,\n    address quote,\n    uint256 roundId\n  ) external view returns (uint256 timestamp);\n\n  // Registry getters\n\n  function getFeed(address base, address quote) external view returns (AggregatorV2V3Interface aggregator);\n\n  function getPhaseFeed(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (AggregatorV2V3Interface aggregator);\n\n  function isFeedEnabled(address aggregator) external view returns (bool);\n\n  function getPhase(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (Phase memory phase);\n\n  // Round helpers\n\n  function getRoundFeed(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (AggregatorV2V3Interface aggregator);\n\n  function getPhaseRange(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (uint80 startingRoundId, uint80 endingRoundId);\n\n  function getPreviousRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (uint80 previousRoundId);\n\n  function getNextRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (uint80 nextRoundId);\n\n  // Feed management\n\n  function proposeFeed(\n    address base,\n    address quote,\n    address aggregator\n  ) external;\n\n  function confirmFeed(\n    address base,\n    address quote,\n    address aggregator\n  ) external;\n\n  // Proposed aggregator\n\n  function getProposedFeed(address base, address quote)\n    external\n    view\n    returns (AggregatorV2V3Interface proposedAggregator);\n\n  function proposedGetRoundData(\n    address base,\n    address quote,\n    uint80 roundId\n  )\n    external\n    view\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function proposedLatestRoundData(address base, address quote)\n    external\n    view\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  // Phases\n  function getCurrentPhaseId(address base, address quote) external view returns (uint16 currentPhaseId);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "contracts/core/ChainlinkFeedPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol\";\nimport \"./ChainlinkPriceProvider.sol\";\nimport \"../libraries/OracleHelpers.sol\";\n\n/**\n * @title ChainLink's price provider that uses price feed (only available on Mainnet currently)\n * @dev This contract is more expensive (+ ~1.3k) than others contracts (that don't use feed)\n * because they get decimals during aggregator addition\n */\ncontract ChainlinkFeedPriceProvider is ChainlinkPriceProvider {\n    using SafeCast for int256;\n    using OracleHelpers for uint256;\n\n    address public constant USD = address(840); // Chainlink follows https://en.wikipedia.org/wiki/ISO_4217\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant BTC = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\n    FeedRegistryInterface public constant PRICE_FEED =\n        FeedRegistryInterface(0x47Fb2585D2C56Fe188D0E6ec628a38b74fCeeeDf);\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(address token_) public view override returns (uint256 _priceInUsd, uint256 _lastUpdatedAt) {\n        int256 _price;\n\n        AggregatorV3Interface _aggregator = aggregators[token_];\n        if (address(_aggregator) != address(0)) {\n            (, _price, , _lastUpdatedAt, ) = _aggregator.latestRoundData();\n            return (_price.toUint256() * TO_SCALE, _lastUpdatedAt);\n        }\n\n        if (token_ == WETH) {\n            token_ = ETH;\n        } else if (token_ == WBTC) {\n            token_ = BTC;\n        }\n        (, _price, , _lastUpdatedAt, ) = PRICE_FEED.latestRoundData(token_, USD);\n        _priceInUsd = _price.toUint256().scaleDecimal(PRICE_FEED.decimals(token_, USD), USD_DECIMALS);\n    }\n}\n"
    },
    "contracts/core/ChainlinkBscPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./ChainlinkPriceProvider.sol\";\n\n/**\n * @title Chainlink's price provider for BSC (Binance) network\n */\ncontract ChainlinkBscPriceProvider is ChainlinkPriceProvider {\n    constructor() {\n        // Binance's aggregators: https://docs.chain.link/docs/data-feeds/price-feeds/addresses/?network=bnb-chain\n        // Note: These are NOT all available aggregators, not adding them all to avoid too expensive deployment cost\n        _setAggregator(0x2170Ed0880ac9A755fd29B2688956BD959F933F8, AggregatorV3Interface(0x2A3796273d47c4eD363b361D3AEFb7F7E2A13782)); // BETH\n        _setAggregator(0x55d398326f99059fF775485246999027B3197955, AggregatorV3Interface(0xB97Ad0E74fa7d920791E90258A6E2085088b4320)); // USDT\n        _setAggregator(0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d, AggregatorV3Interface(0x51597f405303C4377E36123cBc172b13269EA163)); // BUSD\n        _setAggregator(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c, AggregatorV3Interface(0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE)); // WBNB\n        _setAggregator(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56, AggregatorV3Interface(0xcBb98864Ef56E9042e7d2efef76141f15731B82f)); // BUSD\n        _setAggregator(0x1AF3F329e8BE154074D8769D1FFa4eE058B1DBc3, AggregatorV3Interface(0x132d3C0B1D2cEa0BC552588063bdBb210FDeecfA)); // DAI\n        _setAggregator(0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c, AggregatorV3Interface(0x264990fbd0A4796A3E3d8E37C4d5F87a3aCa5Ebf)); // BTCB\n       \n    }\n}\n"
    },
    "contracts/core/ChainlinkAvalanchePriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./ChainlinkPriceProvider.sol\";\n\n/**\n * @title ChainLink's price provider for Avalanche network\n */\ncontract ChainlinkAvalanchePriceProvider is ChainlinkPriceProvider {\n    constructor() {\n        // Avalanche's aggregators: https://docs.chain.link/docs/avalanche-price-feeds/\n        _setAggregator(0x63a72806098Bd3D9520cC43356dD78afe5D386D9, AggregatorV3Interface(0x3CA13391E9fb38a75330fb28f8cc2eB3D9ceceED)); // AAVE.e\n        _setAggregator(0x2147EFFF675e4A4eE1C2f918d181cDBd7a8E208f, AggregatorV3Interface(0x7B0ca9A6D03FE0467A31Ca850f5bcA51e027B3aF)); // ALPHA.e\n        _setAggregator(0x027dbcA046ca156De9622cD1e2D907d375e53aa7, AggregatorV3Interface(0xcf667FB6Bd30c520A435391c50caDcDe15e5e12f)); // AMPL\n        _setAggregator(0x19860CCB0A68fd4213aB9D8266F7bBf05A8dDe98, AggregatorV3Interface(0x827f8a0dC5c943F7524Dda178E2e7F275AAd743f)); // BUSD.e\n        _setAggregator(0x249848BeCA43aC405b8102Ec90Dd5F22CA513c06, AggregatorV3Interface(0x7CF8A6090A9053B01F3DF4D4e6CfEdd8c90d9027)); // CRV.e\n        _setAggregator(0xd586E7F844cEa2F87f50152665BCbc2C279D8d70, AggregatorV3Interface(0x51D7180edA2260cc4F6e4EebB82FEF5c3c2B8300)); // DAI.e\n        _setAggregator(0x6e84a6216eA6dACC71eE8E6b0a5B7322EEbC0fDd, AggregatorV3Interface(0x02D35d3a8aC3e1626d3eE09A78Dd87286F5E8e3a)); // JOE\n        _setAggregator(0x5947BB275c521040051D82396192181b413227A3, AggregatorV3Interface(0x49ccd9ca821EfEab2b98c60dC60F518E765EDe9a)); // LINK.e\n        _setAggregator(0x130966628846BFd36ff31a822705796e8cb8C18D, AggregatorV3Interface(0x54EdAB30a7134A16a54218AE64C73e1DAf48a8Fb)); // MIM\n        _setAggregator(0x8729438EB15e2C8B576fCc6AeCdA6A148776C0F5, AggregatorV3Interface(0x36E039e6391A5E7A7267650979fdf613f659be5D)); // QI\n        _setAggregator(0xCE1bFFBD5374Dac86a2893119683F4911a2F7814, AggregatorV3Interface(0x4F3ddF9378a4865cf4f28BE51E10AECb83B7daeE)); // SPELL\n        _setAggregator(0x37B608519F91f70F2EeB0e5Ed9AF4061722e4F76, AggregatorV3Interface(0x449A373A090d8A1e5F74c63Ef831Ceff39E94563)); // SUSHI.e\n        _setAggregator(0x1C20E891Bab6b1727d14Da358FAe2984Ed9B59EB, AggregatorV3Interface(0x9Cf3Ef104A973b351B2c032AA6793c3A6F76b448)); // TUSD\n        _setAggregator(0x8eBAf22B6F053dFFeaf46f4Dd9eFA95D89ba8580, AggregatorV3Interface(0x9a1372f9b1B71B3A5a72E092AE67E172dBd7Daaa)); // UNI.e\n        _setAggregator(0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664, AggregatorV3Interface(0xF096872672F44d6EBA71458D74fe67F9a77a23B9)); // USDC.e\n        _setAggregator(0xc7198437980c041c805A1EDcbA50c1Ce5db95118, AggregatorV3Interface(0xEBE676ee90Fe1112671f19b6B7459bC678B67e8a)); // USDT.e\n        _setAggregator(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7, AggregatorV3Interface(0x0A77230d17318075983913bC2145DB16C7366156)); // WAVAX\n        _setAggregator(0x50b7545627a5162F82A992c33b87aDc75187B218, AggregatorV3Interface(0x2779D32d5166BAaa2B2b658333bA7e6Ec0C65743)); // WBTC.e\n        _setAggregator(0x49D5c2BdFfac6CE2BFdB6640F4F80f226bc10bAB, AggregatorV3Interface(0x976B3D034E162d8bD72D6b9C989d545b839003b0)); // WETH.e\n        _setAggregator(0xd1c3f94DE7e5B45fa4eDBBA472491a9f4B166FC4, AggregatorV3Interface(0x4Cf57DC9028187b9DAaF773c8ecA941036989238)); // XAVA\n        _setAggregator(0x9eAaC1B23d935365bD7b542Fe22cEEe2922f52dc, AggregatorV3Interface(0x28043B1Ebd41860B93EC1F1eC19560760B6dB556)); // YFI.e\n    }\n}\n"
    },
    "contracts/core/ChainlinkArbitrumPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./ChainlinkPriceProvider.sol\";\n\n/**\n * @title ChainLink's price provider for Arbitrum network\n */\ncontract ChainlinkArbitrumPriceProvider is ChainlinkPriceProvider {\n    constructor() {\n        // Arbitrum's aggregators: https://docs.chain.link/docs/arbitrum-price-feeds/\n        _setAggregator(0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f, AggregatorV3Interface(0x6ce185860a4963106506C203335A2910413708e9)); // WBTC\n        _setAggregator(0x11cDb42B0EB46D95f990BeDD4695A6e3fA034978, AggregatorV3Interface(0xaebDA2c976cfd1eE1977Eac079B4382acb849325)); // CRV\n        _setAggregator(0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1, AggregatorV3Interface(0xc5C8E77B397E531B8EC06BFb0048328B30E9eCfB)); // DAI\n        _setAggregator(0x69Eb4FA4a2fbd498C257C57Ea8b7655a2559A581, AggregatorV3Interface(0xA33a06c119EC08F92735F9ccA37e07Af08C4f281)); // DODO\n        _setAggregator(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1, AggregatorV3Interface(0x639Fe6ab55C921f74e7fac1ee960C0B6293ba612)); // WETH\n        _setAggregator(0x17FC002b466eEc40DaE837Fc4bE5c67993ddBd6F, AggregatorV3Interface(0x0809E3d38d1B4214958faf06D8b1B1a2b73f2ab8)); // FRAX\n        _setAggregator(0x9d2F299715D94d8A7E6F5eaa8E654E8c74a988A7, AggregatorV3Interface(0x36a121448D74Fa81450c992A1a44B9b7377CD3a5)); // FXS\n        _setAggregator(0xf97f4df75117a78c1A5a0DBb814Af92458539FB4, AggregatorV3Interface(0x86E53CF1B870786351Da77A57575e79CB55812CB)); // LINK\n        _setAggregator(0x1A4dA80967373fd929961e976b4b53ceeC063a15, AggregatorV3Interface(0x81a065E74943A8B6380C23f8b440Aea1Dc3530cA)); // LUNA\n        _setAggregator(0xFEa7a6a0B346362BF88A9e4A88416B77a57D6c2A, AggregatorV3Interface(0x87121F6c9A9F6E90E59591E4Cf4804873f54A95b)); // MIM\n        _setAggregator(0x3E6648C5a70A150A88bCE65F4aD4d506Fe15d2AF, AggregatorV3Interface(0x383b3624478124697BEF675F07cA37570b73992f)); // SPELL\n        _setAggregator(0xd4d42F0b6DEF4CE0383636770eF773390d85c61A, AggregatorV3Interface(0xb2A8BA74cbca38508BA1632761b56C897060147C)); // SUSHI\n        _setAggregator(0xFa7F8980b0f1E64A2062791cc3b0871572f1F7f0, AggregatorV3Interface(0x9C917083fDb403ab5ADbEC26Ee294f6EcAda2720)); // UNI\n        _setAggregator(0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8, AggregatorV3Interface(0x50834F3163758fcC1Df9973b6e91f0F0F0434aD3)); // USDC\n        _setAggregator(0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9, AggregatorV3Interface(0x3f3f5dF88dC9F13eac63DF89EC16ef6e7E25DdE7)); // USDT\n        _setAggregator(0x82e3A8F066a6989666b031d916c43672085b1582, AggregatorV3Interface(0x745Ab5b69E01E2BE1104Ca84937Bb71f96f5fB21)); // YFI\n    }\n}\n"
    },
    "contracts/core/PriceProvidersAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../interfaces/core/IPriceProvidersAggregator.sol\";\nimport \"../access/Governable.sol\";\n\n/**\n * @title Price Providers Aggregator\n */\ncontract PriceProvidersAggregator is IPriceProvidersAggregator, Governable {\n    /**\n     * The native token (usually the most liquid asset in the chain)\n     * @dev Is used when getting quote from two price providers\n     */\n    address public immutable nativeToken;\n\n    /**\n     * @notice Price providers map\n     */\n    mapping(DataTypes.Provider => IPriceProvider) public override priceProviders;\n\n    /// Emitted when an price provider is updated\n    event PriceProviderUpdated(\n        DataTypes.Provider provider,\n        IPriceProvider oldPriceProvider,\n        IPriceProvider newPriceProvider\n    );\n\n    constructor(address nativeToken_) {\n        require(nativeToken_ != address(0), \"native-token-is-null\");\n        nativeToken = nativeToken_;\n    }\n\n    /// @inheritdoc IPriceProvidersAggregator\n    function getPriceInUsd(DataTypes.Provider provider_, address token_)\n        external\n        view\n        override\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        IPriceProvider _provider = priceProviders[provider_];\n        require(address(_provider) != address(0), \"provider-not-set\");\n        return _provider.getPriceInUsd(token_);\n    }\n\n    /// @inheritdoc IPriceProvidersAggregator\n    function quote(\n        DataTypes.Provider provider_,\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        view\n        override\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        IPriceProvider _provider = priceProviders[provider_];\n        require(address(_provider) != address(0), \"provider-not-set\");\n        return _provider.quote(tokenIn_, tokenOut_, amountIn_);\n    }\n\n    /// @inheritdoc IPriceProvidersAggregator\n    function quote(\n        DataTypes.Provider providerIn_,\n        address tokenIn_,\n        DataTypes.Provider providerOut_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        public\n        view\n        override\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _nativeTokenLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        IPriceProvider _providerIn = priceProviders[providerIn_];\n        require(address(_providerIn) != address(0), \"provider-in-not-set\");\n\n        if (providerIn_ == providerOut_) {\n            (_amountOut, _tokenInLastUpdatedAt, _tokenOutLastUpdatedAt) = _providerIn.quote(\n                tokenIn_,\n                tokenOut_,\n                amountIn_\n            );\n            _nativeTokenLastUpdatedAt = block.timestamp;\n            return (_amountOut, _tokenInLastUpdatedAt, _nativeTokenLastUpdatedAt, _tokenOutLastUpdatedAt);\n        }\n\n        IPriceProvider _providerOut = priceProviders[providerOut_];\n        require(address(_providerOut) != address(0), \"provider-out-not-set\");\n\n        uint256 _nativeTokenLastUpdatedAt0;\n        uint256 _nativeTokenLastUpdatedAt1;\n        (_amountOut, _tokenInLastUpdatedAt, _nativeTokenLastUpdatedAt0) = _providerIn.quote(\n            tokenIn_,\n            nativeToken,\n            amountIn_\n        );\n        (_amountOut, _nativeTokenLastUpdatedAt1, _tokenOutLastUpdatedAt) = _providerOut.quote(\n            nativeToken,\n            tokenOut_,\n            _amountOut\n        );\n        _nativeTokenLastUpdatedAt = Math.min(_nativeTokenLastUpdatedAt0, _nativeTokenLastUpdatedAt1);\n    }\n\n    /// @inheritdoc IPriceProvidersAggregator\n    function quoteTokenToUsd(\n        DataTypes.Provider provider_,\n        address token_,\n        uint256 amountIn_\n    ) external view override returns (uint256 amountOut_, uint256 _lastUpdatedAt) {\n        IPriceProvider _provider = priceProviders[provider_];\n        require(address(_provider) != address(0), \"provider-not-set\");\n        return _provider.quoteTokenToUsd(token_, amountIn_);\n    }\n\n    /// @inheritdoc IPriceProvidersAggregator\n    function quoteUsdToToken(\n        DataTypes.Provider provider_,\n        address token_,\n        uint256 amountIn_\n    ) external view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        IPriceProvider _provider = priceProviders[provider_];\n        require(address(_provider) != address(0), \"provider-not-set\");\n        return _provider.quoteUsdToToken(token_, amountIn_);\n    }\n\n    /// @inheritdoc IPriceProvidersAggregator\n    function setPriceProvider(DataTypes.Provider provider_, IPriceProvider priceProvider_)\n        external\n        override\n        onlyGovernor\n    {\n        require(provider_ != DataTypes.Provider.NONE, \"invalid-provider\");\n        IPriceProvider _current = priceProviders[provider_];\n        require(priceProvider_ != _current, \"same-as-current\");\n\n        emit PriceProviderUpdated(provider_, _current, priceProvider_);\n\n        priceProviders[provider_] = priceProvider_;\n    }\n}\n"
    },
    "contracts/mock/UsingStalePeriodMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../features/UsingStalePeriod.sol\";\n\ncontract UsingStalePeriodMock is UsingStalePeriod {\n    constructor(uint256 stalePeriod_) UsingStalePeriod(stalePeriod_) {}\n\n    function priceIsStale(uint256 timeOfLastUpdate_, uint256 stalePeriod_) external view returns (bool) {\n        return _priceIsStale(timeOfLastUpdate_, stalePeriod_);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 5000
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}