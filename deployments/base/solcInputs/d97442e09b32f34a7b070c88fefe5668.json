{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"./AggregatorV2V3Interface.sol\";\n\ninterface FeedRegistryInterface {\n  struct Phase {\n    uint16 phaseId;\n    uint80 startingAggregatorRoundId;\n    uint80 endingAggregatorRoundId;\n  }\n\n  event FeedProposed(\n    address indexed asset,\n    address indexed denomination,\n    address indexed proposedAggregator,\n    address currentAggregator,\n    address sender\n  );\n  event FeedConfirmed(\n    address indexed asset,\n    address indexed denomination,\n    address indexed latestAggregator,\n    address previousAggregator,\n    uint16 nextPhaseId,\n    address sender\n  );\n\n  // V3 AggregatorV3Interface\n\n  function decimals(address base, address quote) external view returns (uint8);\n\n  function description(address base, address quote) external view returns (string memory);\n\n  function version(address base, address quote) external view returns (uint256);\n\n  function latestRoundData(address base, address quote)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function getRoundData(\n    address base,\n    address quote,\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  // V2 AggregatorInterface\n\n  function latestAnswer(address base, address quote) external view returns (int256 answer);\n\n  function latestTimestamp(address base, address quote) external view returns (uint256 timestamp);\n\n  function latestRound(address base, address quote) external view returns (uint256 roundId);\n\n  function getAnswer(\n    address base,\n    address quote,\n    uint256 roundId\n  ) external view returns (int256 answer);\n\n  function getTimestamp(\n    address base,\n    address quote,\n    uint256 roundId\n  ) external view returns (uint256 timestamp);\n\n  // Registry getters\n\n  function getFeed(address base, address quote) external view returns (AggregatorV2V3Interface aggregator);\n\n  function getPhaseFeed(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (AggregatorV2V3Interface aggregator);\n\n  function isFeedEnabled(address aggregator) external view returns (bool);\n\n  function getPhase(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (Phase memory phase);\n\n  // Round helpers\n\n  function getRoundFeed(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (AggregatorV2V3Interface aggregator);\n\n  function getPhaseRange(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (uint80 startingRoundId, uint80 endingRoundId);\n\n  function getPreviousRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (uint80 previousRoundId);\n\n  function getNextRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (uint80 nextRoundId);\n\n  // Feed management\n\n  function proposeFeed(\n    address base,\n    address quote,\n    address aggregator\n  ) external;\n\n  function confirmFeed(\n    address base,\n    address quote,\n    address aggregator\n  ) external;\n\n  // Proposed aggregator\n\n  function getProposedFeed(address base, address quote)\n    external\n    view\n    returns (AggregatorV2V3Interface proposedAggregator);\n\n  function proposedGetRoundData(\n    address base,\n    address quote,\n    uint80 roundId\n  )\n    external\n    view\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function proposedLatestRoundData(address base, address quote)\n    external\n    view\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  // Phases\n  function getCurrentPhaseId(address base, address quote) external view returns (uint16 currentPhaseId);\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = _setInitializedVersion(1);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        bool isTopLevelCall = _setInitializedVersion(version);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(version);\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        _setInitializedVersion(type(uint8).max);\n    }\n\n    function _setInitializedVersion(uint8 version) private returns (bool) {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\n        // of initializers, because in other contexts the contract may have been reentered.\n        if (_initializing) {\n            require(\n                version == 1 && !Address.isContract(address(this)),\n                \"Initializable: contract is already initialized\"\n            );\n            return false;\n        } else {\n            require(_initialized < version, \"Initializable: contract is already initialized\");\n            _initialized = version;\n            return true;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@prb/math/contracts/PRBMath.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\n\n/// @notice Emitted when one of the inputs is type(int256).min.\nerror PRBMath__MulDivSignedInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows int256.\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is MIN_SD59x18.\nerror PRBMathSD59x18__AbsInputTooSmall();\n\n/// @notice Emitted when ceiling a number overflows SD59x18.\nerror PRBMathSD59x18__CeilOverflow(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__DivInputTooSmall();\n\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\n\n/// @notice Emitted when flooring a number underflows SD59x18.\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\n\n/// @notice Emitted when the product of the inputs is negative.\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\n\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\n\n/// @notice Emitted when the input is less than or equal to zero.\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__MulInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is negative.\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\n\n/// @notice Emitted when the calculating the square root overflows SD59x18.\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\n\n/// @notice Emitted when addition overflows UD60x18.\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when ceiling a number overflows UD60x18.\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\n\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when the input is less than 1.\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\n\n/// @notice Emitted when the calculating the square root overflows UD60x18.\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\n\n/// @notice Emitted when subtraction underflows UD60x18.\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\n\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\nlibrary PRBMath {\n    /// STRUCTS ///\n\n    struct SD59x18 {\n        int256 value;\n    }\n\n    struct UD60x18 {\n        uint256 value;\n    }\n\n    /// STORAGE ///\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @dev Largest power of two divisor of SCALE.\n    uint256 internal constant SCALE_LPOTD = 262144;\n\n    /// @dev SCALE inverted mod 2^256.\n    uint256 internal constant SCALE_INVERSE =\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n    /// FUNCTIONS ///\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    /// @dev Has to use 192.64-bit fixed-point numbers.\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // Start from 0.5 in the 192.64-bit fixed-point format.\n            result = 0x800000000000000000000000000000000000000000000000;\n\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n\n            // We're doing two things at the same time:\n            //\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\n            //      rather than 192.\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\n            //\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\n            result *= SCALE;\n            result >>= (191 - (x >> 64));\n        }\n    }\n\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n    /// @param x The uint256 number for which to find the index of the most significant bit.\n    /// @return msb The index of the most significant bit as an uint256.\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\n        if (x >= 2**128) {\n            x >>= 128;\n            msb += 128;\n        }\n        if (x >= 2**64) {\n            x >>= 64;\n            msb += 64;\n        }\n        if (x >= 2**32) {\n            x >>= 32;\n            msb += 32;\n        }\n        if (x >= 2**16) {\n            x >>= 16;\n            msb += 16;\n        }\n        if (x >= 2**8) {\n            x >>= 8;\n            msb += 8;\n        }\n        if (x >= 2**4) {\n            x >>= 4;\n            msb += 4;\n        }\n        if (x >= 2**2) {\n            x >>= 2;\n            msb += 2;\n        }\n        if (x >= 2**1) {\n            // No need to shift x any more.\n            msb += 1;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The multiplicand as an uint256.\n    /// @param y The multiplier as an uint256.\n    /// @param denominator The divisor as an uint256.\n    /// @return result The result as an uint256.\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        if (prod1 >= denominator) {\n            revert PRBMath__MulDivOverflow(prod1, denominator);\n        }\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        unchecked {\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by lpotdod.\n                denominator := div(denominator, lpotdod)\n\n                // Divide [prod1 prod0] by lpotdod.\n                prod0 := div(prod0, lpotdod)\n\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * lpotdod;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷1e18) with full precision.\n    ///\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\n    ///\n    /// Requirements:\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\n    ///     1. x * y = type(uint256).max * SCALE\n    ///     2. (x * y) % SCALE >= SCALE / 2\n    ///\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= SCALE) {\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\n        }\n\n        uint256 remainder;\n        uint256 roundUpUnit;\n        assembly {\n            remainder := mulmod(x, y, SCALE)\n            roundUpUnit := gt(remainder, 499999999999999999)\n        }\n\n        if (prod1 == 0) {\n            unchecked {\n                result = (prod0 / SCALE) + roundUpUnit;\n                return result;\n            }\n        }\n\n        assembly {\n            result := add(\n                mul(\n                    or(\n                        div(sub(prod0, remainder), SCALE_LPOTD),\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\n                    ),\n                    SCALE_INVERSE\n                ),\n                roundUpUnit\n            )\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - None of the inputs can be type(int256).min.\n    /// - The result must fit within int256.\n    ///\n    /// @param x The multiplicand as an int256.\n    /// @param y The multiplier as an int256.\n    /// @param denominator The divisor as an int256.\n    /// @return result The result as an int256.\n    function mulDivSigned(\n        int256 x,\n        int256 y,\n        int256 denominator\n    ) internal pure returns (int256 result) {\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n            revert PRBMath__MulDivSignedInputTooSmall();\n        }\n\n        // Get hold of the absolute values of x, y and the denominator.\n        uint256 ax;\n        uint256 ay;\n        uint256 ad;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n        }\n\n        // Compute the absolute value of (x*y)÷denominator. The result must fit within int256.\n        uint256 rAbs = mulDiv(ax, ay, ad);\n        if (rAbs > uint256(type(int256).max)) {\n            revert PRBMath__MulDivSignedOverflow(rAbs);\n        }\n\n        // Get the signs of x, y and the denominator.\n        uint256 sx;\n        uint256 sy;\n        uint256 sd;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n            sd := sgt(denominator, sub(0, 1))\n        }\n\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\n        // If yes, the result should be negative.\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The uint256 number for which to calculate the square root.\n    /// @return result The result as an uint256.\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        // Set the initial guess to the least power of two that is greater than or equal to sqrt(x).\n        uint256 xAux = uint256(x);\n        result = 1;\n        if (xAux >= 0x100000000000000000000000000000000) {\n            xAux >>= 128;\n            result <<= 64;\n        }\n        if (xAux >= 0x10000000000000000) {\n            xAux >>= 64;\n            result <<= 32;\n        }\n        if (xAux >= 0x100000000) {\n            xAux >>= 32;\n            result <<= 16;\n        }\n        if (xAux >= 0x10000) {\n            xAux >>= 16;\n            result <<= 8;\n        }\n        if (xAux >= 0x100) {\n            xAux >>= 8;\n            result <<= 4;\n        }\n        if (xAux >= 0x10) {\n            xAux >>= 4;\n            result <<= 2;\n        }\n        if (xAux >= 0x8) {\n            result <<= 1;\n        }\n\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\n        unchecked {\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1; // Seven iterations should be enough\n            uint256 roundedDownResult = x / result;\n            return result >= roundedDownResult ? roundedDownResult : result;\n        }\n    }\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPyth.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./PythStructs.sol\";\nimport \"./IPythEvents.sol\";\n\n/// @title Consume prices from the Pyth Network (https://pyth.network/).\n/// @dev Please refer to the guidance at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how to consume prices safely.\n/// @author Pyth Data Association\ninterface IPyth is IPythEvents {\n    /// @notice Returns the price of a price feed without any sanity checks.\n    /// @dev This function returns the most recent price update in this contract without any recency checks.\n    /// This function is unsafe as the returned price update may be arbitrarily far in the past.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use `getPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price that is no older than `age` seconds of the current time.\n    /// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.\n    /// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.\n    /// However, if the price is not recent this function returns the latest available price.\n    ///\n    /// The returned price can be from arbitrarily far in the past; this function makes no guarantees that\n    /// the returned price is recent or useful for any particular application.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds\n    /// of the current time.\n    /// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Update price feeds with given update messages.\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    /// Prices will be updated if they are more recent than the current stored prices.\n    /// The call will succeed even if the update is not the most recent.\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    function updatePriceFeeds(bytes[] calldata updateData) external payable;\n\n    /// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is\n    /// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the\n    /// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    /// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime\n    /// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have\n    /// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.\n    /// Otherwise, it calls updatePriceFeeds method to update the prices.\n    ///\n    /// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`\n    function updatePriceFeedsIfNecessary(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64[] calldata publishTimes\n    ) external payable;\n\n    /// @notice Returns the required fee to update an array of price updates.\n    /// @param updateData Array of price update data.\n    /// @return feeAmount The required fee in Wei.\n    function getUpdateFee(\n        bytes[] calldata updateData\n    ) external view returns (uint feeAmount);\n\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\n    /// within `minPublishTime` and `maxPublishTime`.\n    ///\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\n    /// otherwise, please consider using `updatePriceFeeds`. This method may store the price updates on-chain, if they\n    /// are more recent than the current stored prices.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n\n    /// @notice Similar to `parsePriceFeedUpdates` but ensures the updates returned are\n    /// the first updates published in minPublishTime. That is, if there are multiple updates for a given timestamp,\n    /// this method will return the first update. This method may store the price updates on-chain, if they\n    /// are more recent than the current stored prices.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range and uniqueness condition.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdatesUnique(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPythEvents.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @title IPythEvents contains the events that Pyth contract emits.\n/// @dev This interface can be used for listening to the updates for off-chain and testing purposes.\ninterface IPythEvents {\n    /// @dev Emitted when the price feed with `id` has received a fresh update.\n    /// @param id The Pyth Price Feed ID.\n    /// @param publishTime Publish time of the given price update.\n    /// @param price Price of the given price update.\n    /// @param conf Confidence interval of the given price update.\n    event PriceFeedUpdate(\n        bytes32 indexed id,\n        uint64 publishTime,\n        int64 price,\n        uint64 conf\n    );\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/PythStructs.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ncontract PythStructs {\n    // A price with a degree of uncertainty, represented as a price +- a confidence interval.\n    //\n    // The confidence interval roughly corresponds to the standard error of a normal distribution.\n    // Both the price and confidence are stored in a fixed-point numeric representation,\n    // `x * (10^expo)`, where `expo` is the exponent.\n    //\n    // Please refer to the documentation at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how\n    // to how this price safely.\n    struct Price {\n        // Price\n        int64 price;\n        // Confidence interval around the price\n        uint64 conf;\n        // Price exponent\n        int32 expo;\n        // Unix timestamp describing when the price was published\n        uint publishTime;\n    }\n\n    // PriceFeed represents a current aggregate price from pyth publisher feeds.\n    struct PriceFeed {\n        // The price ID.\n        bytes32 id;\n        // Latest available price\n        Price price;\n        // Latest available exponentially-weighted moving average price\n        Price emaPrice;\n    }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/CalldataExtractor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"./RedstoneConstants.sol\";\n\n/**\n * @title The base contract with the main logic of data extraction from calldata\n * @author The Redstone Oracles team\n * @dev This contract was created to reuse the same logic in the RedstoneConsumerBase\n * and the ProxyConnector contracts\n */\ncontract CalldataExtractor is RedstoneConstants {\n\n  error DataPackageTimestampMustNotBeZero();\n  error DataPackageTimestampsMustBeEqual();\n  error RedstonePayloadMustHaveAtLeastOneDataPackage();\n  error TooLargeValueByteSize(uint256 valueByteSize);\n\n  function extractTimestampsAndAssertAllAreEqual() public pure returns (uint256 extractedTimestamp) {\n    uint256 calldataNegativeOffset = _extractByteSizeOfUnsignedMetadata();\n    uint256 dataPackagesCount;\n    (dataPackagesCount, calldataNegativeOffset) = _extractDataPackagesCountFromCalldata(calldataNegativeOffset);\n\n    if (dataPackagesCount == 0) {\n      revert RedstonePayloadMustHaveAtLeastOneDataPackage();\n    }\n\n    for (uint256 dataPackageIndex = 0; dataPackageIndex < dataPackagesCount; dataPackageIndex++) {\n      uint256 dataPackageByteSize = _getDataPackageByteSize(calldataNegativeOffset);\n\n      // Extracting timestamp for the current data package\n      uint48 dataPackageTimestamp; // uint48, because timestamp uses 6 bytes\n      uint256 timestampNegativeOffset = (calldataNegativeOffset + TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS);\n      uint256 timestampOffset = msg.data.length - timestampNegativeOffset;\n      assembly {\n        dataPackageTimestamp := calldataload(timestampOffset)\n      }\n\n      if (dataPackageTimestamp == 0) {\n        revert DataPackageTimestampMustNotBeZero();\n      }\n\n      if (extractedTimestamp == 0) {\n        extractedTimestamp = dataPackageTimestamp;\n      } else if (dataPackageTimestamp != extractedTimestamp) {\n        revert DataPackageTimestampsMustBeEqual();\n      }\n\n      calldataNegativeOffset += dataPackageByteSize;\n    }\n  }\n\n  function _getDataPackageByteSize(uint256 calldataNegativeOffset) internal pure returns (uint256) {\n    (\n      uint256 dataPointsCount,\n      uint256 eachDataPointValueByteSize\n    ) = _extractDataPointsDetailsForDataPackage(calldataNegativeOffset);\n\n    return\n      dataPointsCount *\n      (DATA_POINT_SYMBOL_BS + eachDataPointValueByteSize) +\n      DATA_PACKAGE_WITHOUT_DATA_POINTS_BS;\n  }\n\n  function _extractByteSizeOfUnsignedMetadata() internal pure returns (uint256) {\n    // Checking if the calldata ends with the RedStone marker\n    bool hasValidRedstoneMarker;\n    assembly {\n      let calldataLast32Bytes := calldataload(sub(calldatasize(), STANDARD_SLOT_BS))\n      hasValidRedstoneMarker := eq(\n        REDSTONE_MARKER_MASK,\n        and(calldataLast32Bytes, REDSTONE_MARKER_MASK)\n      )\n    }\n    if (!hasValidRedstoneMarker) {\n      revert CalldataMustHaveValidPayload();\n    }\n\n    // Using uint24, because unsigned metadata byte size number has 3 bytes\n    uint24 unsignedMetadataByteSize;\n    if (REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS > msg.data.length) {\n      revert CalldataOverOrUnderFlow();\n    }\n    assembly {\n      unsignedMetadataByteSize := calldataload(\n        sub(calldatasize(), REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS)\n      )\n    }\n    uint256 calldataNegativeOffset = unsignedMetadataByteSize\n      + UNSIGNED_METADATA_BYTE_SIZE_BS\n      + REDSTONE_MARKER_BS;\n    if (calldataNegativeOffset + DATA_PACKAGES_COUNT_BS > msg.data.length) {\n      revert IncorrectUnsignedMetadataSize();\n    }\n    return calldataNegativeOffset;\n  }\n\n  // We return uint16, because unsigned metadata byte size number has 2 bytes\n  function _extractDataPackagesCountFromCalldata(uint256 calldataNegativeOffset)\n    internal\n    pure\n    returns (uint16 dataPackagesCount, uint256 nextCalldataNegativeOffset)\n  {\n    uint256 calldataNegativeOffsetWithStandardSlot = calldataNegativeOffset + STANDARD_SLOT_BS;\n    if (calldataNegativeOffsetWithStandardSlot > msg.data.length) {\n      revert CalldataOverOrUnderFlow();\n    }\n    assembly {\n      dataPackagesCount := calldataload(\n        sub(calldatasize(), calldataNegativeOffsetWithStandardSlot)\n      )\n    }\n    return (dataPackagesCount, calldataNegativeOffset + DATA_PACKAGES_COUNT_BS);\n  }\n\n  function _extractDataPointValueAndDataFeedId(\n    uint256 dataPointNegativeOffset,\n    uint256 dataPointValueByteSize\n  ) internal pure virtual returns (bytes32 dataPointDataFeedId, uint256 dataPointValue) {\n    uint256 dataPointCalldataOffset = msg.data.length - dataPointNegativeOffset;\n    assembly {\n      dataPointDataFeedId := calldataload(dataPointCalldataOffset)\n      dataPointValue := calldataload(add(dataPointCalldataOffset, DATA_POINT_SYMBOL_BS))\n    }\n    if (dataPointValueByteSize >= 33) {\n      revert TooLargeValueByteSize(dataPointValueByteSize);\n    }\n    unchecked {\n      dataPointValue = dataPointValue >> (32 - dataPointValueByteSize) * 8; \n    }\n  }\n\n  function _extractDataPointsDetailsForDataPackage(uint256 calldataNegativeOffsetForDataPackage)\n    internal\n    pure\n    returns (uint256 dataPointsCount, uint256 eachDataPointValueByteSize)\n  {\n    // Using uint24, because data points count byte size number has 3 bytes\n    uint24 dataPointsCount_;\n\n    // Using uint32, because data point value byte size has 4 bytes\n    uint32 eachDataPointValueByteSize_;\n\n    // Extract data points count\n    uint256 calldataOffset = msg.data.length - (calldataNegativeOffsetForDataPackage + SIG_BS + STANDARD_SLOT_BS);\n    assembly {\n      dataPointsCount_ := calldataload(calldataOffset)\n    }\n\n    // Extract each data point value size\n    calldataOffset = calldataOffset - DATA_POINTS_COUNT_BS;\n    assembly {\n      eachDataPointValueByteSize_ := calldataload(calldataOffset)\n    }\n\n    // Prepare returned values\n    dataPointsCount = dataPointsCount_;\n    eachDataPointValueByteSize = eachDataPointValueByteSize_;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneConstants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\n/**\n * @title The base contract with helpful constants\n * @author The Redstone Oracles team\n * @dev It mainly contains redstone-related values, which improve readability\n * of other contracts (e.g. CalldataExtractor and RedstoneConsumerBase)\n */\ncontract RedstoneConstants {\n  // === Abbreviations ===\n  // BS - Bytes size\n  // PTR - Pointer (memory location)\n  // SIG - Signature\n\n  // Solidity and YUL constants\n  uint256 internal constant STANDARD_SLOT_BS = 32;\n  uint256 internal constant FREE_MEMORY_PTR = 0x40;\n  uint256 internal constant BYTES_ARR_LEN_VAR_BS = 32;\n  uint256 internal constant FUNCTION_SIGNATURE_BS = 4;\n  uint256 internal constant REVERT_MSG_OFFSET = 68; // Revert message structure described here: https://ethereum.stackexchange.com/a/66173/106364\n  uint256 internal constant STRING_ERR_MESSAGE_MASK = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n\n  // RedStone protocol consts\n  uint256 internal constant SIG_BS = 65;\n  uint256 internal constant TIMESTAMP_BS = 6;\n  uint256 internal constant DATA_PACKAGES_COUNT_BS = 2;\n  uint256 internal constant DATA_POINTS_COUNT_BS = 3;\n  uint256 internal constant DATA_POINT_VALUE_BYTE_SIZE_BS = 4;\n  uint256 internal constant DATA_POINT_SYMBOL_BS = 32;\n  uint256 internal constant DEFAULT_DATA_POINT_VALUE_BS = 32;\n  uint256 internal constant UNSIGNED_METADATA_BYTE_SIZE_BS = 3;\n  uint256 internal constant REDSTONE_MARKER_BS = 9; // byte size of 0x000002ed57011e0000\n  uint256 internal constant REDSTONE_MARKER_MASK = 0x0000000000000000000000000000000000000000000000000002ed57011e0000;\n\n  // Derived values (based on consts)\n  uint256 internal constant TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS = 104; // SIG_BS + DATA_POINTS_COUNT_BS + DATA_POINT_VALUE_BYTE_SIZE_BS + STANDARD_SLOT_BS\n  uint256 internal constant DATA_PACKAGE_WITHOUT_DATA_POINTS_BS = 78; // DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS + SIG_BS\n  uint256 internal constant DATA_PACKAGE_WITHOUT_DATA_POINTS_AND_SIG_BS = 13; // DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS\n  uint256 internal constant REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS = 41; // REDSTONE_MARKER_BS + STANDARD_SLOT_BS\n\n  // Error messages\n  error CalldataOverOrUnderFlow();\n  error IncorrectUnsignedMetadataSize();\n  error InsufficientNumberOfUniqueSigners(uint256 receivedSignersCount, uint256 requiredSignersCount);\n  error EachSignerMustProvideTheSameValue();\n  error EmptyCalldataPointersArr();\n  error InvalidCalldataPointer();\n  error CalldataMustHaveValidPayload();\n  error SignerNotAuthorised(address receivedSigner);\n  error DataTimestampCannotBeZero();\n  error TimestampsMustBeEqual();\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"./RedstoneConstants.sol\";\nimport \"./RedstoneDefaultsLib.sol\";\nimport \"./CalldataExtractor.sol\";\nimport \"../libs/BitmapLib.sol\";\nimport \"../libs/SignatureLib.sol\";\n\n/**\n * @title The base contract with the main Redstone logic\n * @author The Redstone Oracles team\n * @dev Do not use this contract directly in consumer contracts, take a\n * look at `RedstoneConsumerNumericBase` and `RedstoneConsumerBytesBase` instead\n */\nabstract contract RedstoneConsumerBase is CalldataExtractor {\n\n  error GetDataServiceIdNotImplemented();\n\n  /* ========== VIRTUAL FUNCTIONS (MAY BE OVERRIDDEN IN CHILD CONTRACTS) ========== */\n\n  /**\n   * @dev This function must be implemented by the child consumer contract.\n   * It should return dataServiceId which DataServiceWrapper will use if not provided explicitly .\n   * If not overridden, value will always have to be provided explicitly in DataServiceWrapper.\n   * @return dataServiceId being consumed by contract\n   */\n  function getDataServiceId() public view virtual returns (string memory) {\n    revert GetDataServiceIdNotImplemented();\n  }\n\n  /**\n   * @dev This function must be implemented by the child consumer contract.\n   * It should return a unique index for a given signer address if the signer\n   * is authorised, otherwise it should revert\n   * @param receivedSigner The address of a signer, recovered from ECDSA signature\n   * @return Unique index for a signer in the range [0..255]\n   */\n  function getAuthorisedSignerIndex(address receivedSigner) public view virtual returns (uint8);\n\n  /**\n   * @dev This function may be overridden by the child consumer contract.\n   * It should validate the timestamp against the current time (block.timestamp)\n   * It should revert with a helpful message if the timestamp is not valid\n   * @param receivedTimestampMilliseconds Timestamp extracted from calldata\n   */\n  function validateTimestamp(uint256 receivedTimestampMilliseconds) public view virtual {\n    RedstoneDefaultsLib.validateTimestamp(receivedTimestampMilliseconds);\n  }\n\n  /**\n   * @dev This function should be overridden by the child consumer contract.\n   * @return The minimum required value of unique authorised signers\n   */\n  function getUniqueSignersThreshold() public view virtual returns (uint8) {\n    return 1;\n  }\n\n  /**\n   * @dev This function may be overridden by the child consumer contract.\n   * It should aggregate values from different signers to a single uint value.\n   * By default, it calculates the median value\n   * @param values An array of uint256 values from different signers\n   * @return Result of the aggregation in the form of a single number\n   */\n  function aggregateValues(uint256[] memory values) public view virtual returns (uint256) {\n    return RedstoneDefaultsLib.aggregateValues(values);\n  }\n\n  /* ========== FUNCTIONS WITH IMPLEMENTATION (CAN NOT BE OVERRIDDEN) ========== */\n\n  /**\n   * @dev This is an internal helpful function for secure extraction oracle values\n   * from the tx calldata. Security is achieved by signatures verification, timestamp\n   * validation, and aggregating values from different authorised signers into a\n   * single numeric value. If any of the required conditions (e.g. packages with different \n   * timestamps or insufficient number of authorised signers) do not match, the function \n   * will revert.\n   *\n   * Note! You should not call this function in a consumer contract. You can use\n   * `getOracleNumericValuesFromTxMsg` or `getOracleNumericValueFromTxMsg` instead.\n   *\n   * @param dataFeedIds An array of unique data feed identifiers\n   * @return An array of the extracted and verified oracle values in the same order\n   * as they are requested in dataFeedIds array\n   * @return dataPackagesTimestamp timestamp equal for all data packages\n   */\n  function _securelyExtractOracleValuesAndTimestampFromTxMsg(bytes32[] memory dataFeedIds)\n    internal\n    view\n    returns (uint256[] memory, uint256 dataPackagesTimestamp)\n  {\n    // Initializing helpful variables and allocating memory\n    uint256[] memory uniqueSignerCountForDataFeedIds = new uint256[](dataFeedIds.length);\n    uint256[] memory signersBitmapForDataFeedIds = new uint256[](dataFeedIds.length);\n    uint256[][] memory valuesForDataFeeds = new uint256[][](dataFeedIds.length);\n    for (uint256 i = 0; i < dataFeedIds.length;) {\n      // The line below is commented because newly allocated arrays are filled with zeros\n      // But we left it for better readability\n      // signersBitmapForDataFeedIds[i] = 0; // <- setting to an empty bitmap\n      valuesForDataFeeds[i] = new uint256[](getUniqueSignersThreshold());\n      unchecked {\n        i++;\n      }\n    }\n\n    // Extracting the number of data packages from calldata\n    uint256 calldataNegativeOffset = _extractByteSizeOfUnsignedMetadata();\n    uint256 dataPackagesCount;\n    (dataPackagesCount, calldataNegativeOffset) = _extractDataPackagesCountFromCalldata(calldataNegativeOffset);\n\n    // Saving current free memory pointer\n    uint256 freeMemPtr;\n    assembly {\n      freeMemPtr := mload(FREE_MEMORY_PTR)\n    }\n\n    // Data packages extraction in a loop\n    for (uint256 dataPackageIndex = 0; dataPackageIndex < dataPackagesCount;) {\n      // Extract data package details and update calldata offset\n      uint256 dataPackageTimestamp;\n      (calldataNegativeOffset, dataPackageTimestamp) = _extractDataPackage(\n        dataFeedIds,\n        uniqueSignerCountForDataFeedIds,\n        signersBitmapForDataFeedIds,\n        valuesForDataFeeds,\n        calldataNegativeOffset\n      );\n\n      if (dataPackageTimestamp == 0) {\n        revert DataTimestampCannotBeZero();\n      }\n\n      if (dataPackageTimestamp != dataPackagesTimestamp && dataPackagesTimestamp != 0) {\n        revert TimestampsMustBeEqual();\n      }\n\n      dataPackagesTimestamp = dataPackageTimestamp;\n\n      // Shifting memory pointer back to the \"safe\" value\n      assembly {\n        mstore(FREE_MEMORY_PTR, freeMemPtr)\n      }\n      unchecked {\n        dataPackageIndex++;\n      }\n    }\n\n    // Validating numbers of unique signers and calculating aggregated values for each dataFeedId\n    return (_getAggregatedValues(valuesForDataFeeds, uniqueSignerCountForDataFeedIds), dataPackagesTimestamp);\n  }\n\n  /**\n   * @dev This is a private helpful function, which extracts data for a data package based\n   * on the given negative calldata offset, verifies them, and in the case of successful\n   * verification updates the corresponding data package values in memory\n   *\n   * @param dataFeedIds an array of unique data feed identifiers\n   * @param uniqueSignerCountForDataFeedIds an array with the numbers of unique signers\n   * for each data feed\n   * @param signersBitmapForDataFeedIds an array of signer bitmaps for data feeds\n   * @param valuesForDataFeeds 2-dimensional array, valuesForDataFeeds[i][j] contains\n   * j-th value for the i-th data feed\n   * @param calldataNegativeOffset negative calldata offset for the given data package\n   *\n   * @return nextCalldataNegativeOffset negative calldata offset for the next data package\n   * @return dataPackageTimestamp data package timestamp\n   */\n  function _extractDataPackage(\n    bytes32[] memory dataFeedIds,\n    uint256[] memory uniqueSignerCountForDataFeedIds,\n    uint256[] memory signersBitmapForDataFeedIds,\n    uint256[][] memory valuesForDataFeeds,\n    uint256 calldataNegativeOffset\n  ) private view returns (uint256 nextCalldataNegativeOffset, uint256 dataPackageTimestamp) {\n    uint256 signerIndex;\n\n    (\n      uint256 dataPointsCount,\n      uint256 eachDataPointValueByteSize\n    ) = _extractDataPointsDetailsForDataPackage(calldataNegativeOffset);\n\n    // We use scopes to resolve problem with too deep stack\n    {\n      address signerAddress;\n      bytes32 signedHash;\n      bytes memory signedMessage;\n      uint256 signedMessageBytesCount;\n      uint48 extractedTimestamp;\n\n      signedMessageBytesCount = dataPointsCount * (eachDataPointValueByteSize + DATA_POINT_SYMBOL_BS)\n        + DATA_PACKAGE_WITHOUT_DATA_POINTS_AND_SIG_BS; //DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS\n\n      uint256 timestampCalldataOffset = msg.data.length - \n        (calldataNegativeOffset + TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS);\n\n      uint256 signedMessageCalldataOffset = msg.data.length - \n        (calldataNegativeOffset + SIG_BS + signedMessageBytesCount);\n\n      assembly {\n        // Extracting the signed message\n        signedMessage := extractBytesFromCalldata(\n          signedMessageCalldataOffset,\n          signedMessageBytesCount\n        )\n\n        // Hashing the signed message\n        signedHash := keccak256(add(signedMessage, BYTES_ARR_LEN_VAR_BS), signedMessageBytesCount)\n\n        // Extracting timestamp\n        extractedTimestamp := calldataload(timestampCalldataOffset)\n\n        function initByteArray(bytesCount) -> ptr {\n          ptr := mload(FREE_MEMORY_PTR)\n          mstore(ptr, bytesCount)\n          ptr := add(ptr, BYTES_ARR_LEN_VAR_BS)\n          mstore(FREE_MEMORY_PTR, add(ptr, bytesCount))\n        }\n\n        function extractBytesFromCalldata(offset, bytesCount) -> extractedBytes {\n          let extractedBytesStartPtr := initByteArray(bytesCount)\n          calldatacopy(\n            extractedBytesStartPtr,\n            offset,\n            bytesCount\n          )\n          extractedBytes := sub(extractedBytesStartPtr, BYTES_ARR_LEN_VAR_BS)\n        }\n      }\n\n      dataPackageTimestamp = extractedTimestamp;\n\n      // Verifying the off-chain signature against on-chain hashed data\n      signerAddress = SignatureLib.recoverSignerAddress(\n        signedHash,\n        calldataNegativeOffset + SIG_BS\n      );\n      signerIndex = getAuthorisedSignerIndex(signerAddress);\n    }\n\n    // Updating helpful arrays\n    {\n      calldataNegativeOffset = calldataNegativeOffset + DATA_PACKAGE_WITHOUT_DATA_POINTS_BS;\n      bytes32 dataPointDataFeedId;\n      uint256 dataPointValue;\n      for (uint256 dataPointIndex = 0; dataPointIndex < dataPointsCount;) {\n        calldataNegativeOffset = calldataNegativeOffset + eachDataPointValueByteSize + DATA_POINT_SYMBOL_BS;\n        // Extracting data feed id and value for the current data point\n        (dataPointDataFeedId, dataPointValue) = _extractDataPointValueAndDataFeedId(\n          calldataNegativeOffset,\n          eachDataPointValueByteSize\n        );\n\n        for (\n          uint256 dataFeedIdIndex = 0;\n          dataFeedIdIndex < dataFeedIds.length;\n        ) {\n          if (dataPointDataFeedId == dataFeedIds[dataFeedIdIndex]) {\n            uint256 bitmapSignersForDataFeedId = signersBitmapForDataFeedIds[dataFeedIdIndex];\n\n            if (\n              !BitmapLib.getBitFromBitmap(bitmapSignersForDataFeedId, signerIndex) && /* current signer was not counted for current dataFeedId */\n              uniqueSignerCountForDataFeedIds[dataFeedIdIndex] < getUniqueSignersThreshold()\n            ) {\n              // Add new value\n              valuesForDataFeeds[dataFeedIdIndex][uniqueSignerCountForDataFeedIds[dataFeedIdIndex]] = dataPointValue;\n\n              // Increase unique signer counter\n              uniqueSignerCountForDataFeedIds[dataFeedIdIndex]++;\n\n              // Update signers bitmap\n              signersBitmapForDataFeedIds[dataFeedIdIndex] = BitmapLib.setBitInBitmap(\n                bitmapSignersForDataFeedId,\n                signerIndex\n              );\n            }\n\n            // Breaking, as there couldn't be several indexes for the same feed ID\n            break;\n          }\n          unchecked {\n            dataFeedIdIndex++;\n          }\n        }\n        unchecked {\n           dataPointIndex++;\n        }\n      }\n    }\n\n    return (calldataNegativeOffset, dataPackageTimestamp);\n  }\n\n  /**\n   * @dev This is a private helpful function, which aggregates values from different\n   * authorised signers for the given arrays of values for each data feed\n   *\n   * @param valuesForDataFeeds 2-dimensional array, valuesForDataFeeds[i][j] contains\n   * j-th value for the i-th data feed\n   * @param uniqueSignerCountForDataFeedIds an array with the numbers of unique signers\n   * for each data feed\n   *\n   * @return An array of the aggregated values\n   */\n  function _getAggregatedValues(\n    uint256[][] memory valuesForDataFeeds,\n    uint256[] memory uniqueSignerCountForDataFeedIds\n  ) private view returns (uint256[] memory) {\n    uint256[] memory aggregatedValues = new uint256[](valuesForDataFeeds.length);\n    uint256 uniqueSignersThreshold = getUniqueSignersThreshold();\n\n    for (uint256 dataFeedIndex = 0; dataFeedIndex < valuesForDataFeeds.length; dataFeedIndex++) {\n      if (uniqueSignerCountForDataFeedIds[dataFeedIndex] < uniqueSignersThreshold) {\n        revert InsufficientNumberOfUniqueSigners(\n          uniqueSignerCountForDataFeedIds[dataFeedIndex],\n          uniqueSignersThreshold);\n      }\n      uint256 aggregatedValueForDataFeedId = aggregateValues(valuesForDataFeeds[dataFeedIndex]);\n      aggregatedValues[dataFeedIndex] = aggregatedValueForDataFeedId;\n    }\n\n    return aggregatedValues;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneConsumerNumericBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"./RedstoneConsumerBase.sol\";\n\n/**\n * @title The base contract for Redstone consumers' contracts that allows to\n * securely calculate numeric redstone oracle values\n * @author The Redstone Oracles team\n * @dev This contract can extend other contracts to allow them\n * securely fetch Redstone oracle data from transactions calldata\n */\nabstract contract RedstoneConsumerNumericBase is RedstoneConsumerBase {\n  /**\n   * @dev This function can be used in a consumer contract to securely extract an\n   * oracle value for a given data feed id. Security is achieved by\n   * signatures verification, timestamp validation, and aggregating values\n   * from different authorised signers into a single numeric value. If any of the\n   * required conditions do not match, the function will revert.\n   * Note! This function expects that tx calldata contains redstone payload in the end\n   * Learn more about redstone payload here: https://github.com/redstone-finance/redstone-oracles-monorepo/tree/main/packages/evm-connector#readme\n   * @param dataFeedId bytes32 value that uniquely identifies the data feed\n   * @return Extracted and verified numeric oracle value for the given data feed id\n   */\n  function getOracleNumericValueFromTxMsg(bytes32 dataFeedId)\n    internal\n    view\n    virtual\n    returns (uint256)\n  {\n    bytes32[] memory dataFeedIds = new bytes32[](1);\n    dataFeedIds[0] = dataFeedId;\n    return getOracleNumericValuesFromTxMsg(dataFeedIds)[0];\n  }\n\n  /**\n   * @dev This function can be used in a consumer contract to securely extract several\n   * numeric oracle values for a given array of data feed ids. Security is achieved by\n   * signatures verification, timestamp validation, and aggregating values\n   * from different authorised signers into a single numeric value. If any of the\n   * required conditions do not match, the function will revert.\n   * Note! This function expects that tx calldata contains redstone payload in the end\n   * Learn more about redstone payload here: https://github.com/redstone-finance/redstone-oracles-monorepo/tree/main/packages/evm-connector#readme\n   * @param dataFeedIds An array of unique data feed identifiers\n   * @return An array of the extracted and verified oracle values in the same order\n   * as they are requested in the dataFeedIds array\n   */\n  function getOracleNumericValuesFromTxMsg(bytes32[] memory dataFeedIds)\n    internal\n    view\n    virtual\n    returns (uint256[] memory)\n  {\n    (uint256[] memory values, uint256 timestamp) = _securelyExtractOracleValuesAndTimestampFromTxMsg(dataFeedIds);\n    validateTimestamp(timestamp);\n    return values;\n  }\n\n  /**\n   * @dev This function can be used in a consumer contract to securely extract several\n   * numeric oracle values for a given array of data feed ids. Security is achieved by\n   * signatures verification and aggregating values from different authorised signers \n   * into a single numeric value. If any of the required conditions do not match, \n   * the function will revert.\n   * Note! This function returns the timestamp of the packages (it requires it to be \n   * the same for all), but does not validate this timestamp.\n   * Note! This function expects that tx calldata contains redstone payload in the end\n   * Learn more about redstone payload here: https://github.com/redstone-finance/redstone-oracles-monorepo/tree/main/packages/evm-connector#readme\n   * @param dataFeedIds An array of unique data feed identifiers\n   * @return An array of the extracted and verified oracle values in the same order\n   * as they are requested in the dataFeedIds array and data packages timestamp\n   */\n   function getOracleNumericValuesAndTimestampFromTxMsg(bytes32[] memory dataFeedIds)\n    internal\n    view\n    virtual\n    returns (uint256[] memory, uint256)\n  {\n    return _securelyExtractOracleValuesAndTimestampFromTxMsg(dataFeedIds);\n  }\n\n  /**\n   * @dev This function works similarly to the `getOracleNumericValuesFromTxMsg` with the\n   * only difference that it allows to request oracle data for an array of data feeds\n   * that may contain duplicates\n   * \n   * @param dataFeedIdsWithDuplicates An array of data feed identifiers (duplicates are allowed)\n   * @return An array of the extracted and verified oracle values in the same order\n   * as they are requested in the dataFeedIdsWithDuplicates array\n   */\n  function getOracleNumericValuesWithDuplicatesFromTxMsg(bytes32[] memory dataFeedIdsWithDuplicates) internal view returns (uint256[] memory) {\n    // Building an array without duplicates\n    bytes32[] memory dataFeedIdsWithoutDuplicates = new bytes32[](dataFeedIdsWithDuplicates.length);\n    bool alreadyIncluded;\n    uint256 uniqueDataFeedIdsCount = 0;\n\n    for (uint256 indexWithDup = 0; indexWithDup < dataFeedIdsWithDuplicates.length; indexWithDup++) {\n      // Checking if current element is already included in `dataFeedIdsWithoutDuplicates`\n      alreadyIncluded = false;\n      for (uint256 indexWithoutDup = 0; indexWithoutDup < uniqueDataFeedIdsCount; indexWithoutDup++) {\n        if (dataFeedIdsWithoutDuplicates[indexWithoutDup] == dataFeedIdsWithDuplicates[indexWithDup]) {\n          alreadyIncluded = true;\n          break;\n        }\n      }\n\n      // Adding if not included\n      if (!alreadyIncluded) {\n        dataFeedIdsWithoutDuplicates[uniqueDataFeedIdsCount] = dataFeedIdsWithDuplicates[indexWithDup];\n        uniqueDataFeedIdsCount++;\n      }\n    }\n\n    // Overriding dataFeedIdsWithoutDuplicates.length\n    // Equivalent to: dataFeedIdsWithoutDuplicates.length = uniqueDataFeedIdsCount;\n    assembly {\n      mstore(dataFeedIdsWithoutDuplicates, uniqueDataFeedIdsCount)\n    }\n\n    // Requesting oracle values (without duplicates)\n    (uint256[] memory valuesWithoutDuplicates, uint256 timestamp) = _securelyExtractOracleValuesAndTimestampFromTxMsg(dataFeedIdsWithoutDuplicates);\n    validateTimestamp(timestamp);\n\n    // Preparing result values array\n    uint256[] memory valuesWithDuplicates = new uint256[](dataFeedIdsWithDuplicates.length);\n    for (uint256 indexWithDup = 0; indexWithDup < dataFeedIdsWithDuplicates.length; indexWithDup++) {\n      for (uint256 indexWithoutDup = 0; indexWithoutDup < dataFeedIdsWithoutDuplicates.length; indexWithoutDup++) {\n        if (dataFeedIdsWithDuplicates[indexWithDup] == dataFeedIdsWithoutDuplicates[indexWithoutDup]) {\n          valuesWithDuplicates[indexWithDup] = valuesWithoutDuplicates[indexWithoutDup];\n          break;\n        }\n      }\n    }\n\n    return valuesWithDuplicates;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneDefaultsLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"../libs/NumericArrayLib.sol\";\n\n/**\n * @title Default implementations of virtual redstone consumer base functions\n * @author The Redstone Oracles team\n */\nlibrary RedstoneDefaultsLib {\n  uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS = 3 minutes;\n  uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_AHEAD_SECONDS = 1 minutes;\n\n  error TimestampFromTooLongFuture(uint256 receivedTimestampSeconds, uint256 blockTimestamp);\n  error TimestampIsTooOld(uint256 receivedTimestampSeconds, uint256 blockTimestamp);\n\n  function validateTimestamp(uint256 receivedTimestampMilliseconds) internal view {\n    // Getting data timestamp from future seems quite unlikely\n    // But we've already spent too much time with different cases\n    // Where block.timestamp was less than dataPackage.timestamp.\n    // Some blockchains may case this problem as well.\n    // That's why we add MAX_BLOCK_TIMESTAMP_DELAY\n    // and allow data \"from future\" but with a small delay\n    uint256 receivedTimestampSeconds = receivedTimestampMilliseconds / 1000;\n\n    if (block.timestamp < receivedTimestampSeconds) {\n      if ((receivedTimestampSeconds - block.timestamp) > DEFAULT_MAX_DATA_TIMESTAMP_AHEAD_SECONDS) {\n        revert TimestampFromTooLongFuture(receivedTimestampSeconds, block.timestamp);\n      }\n    } else if ((block.timestamp - receivedTimestampSeconds) > DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS) {\n      revert TimestampIsTooOld(receivedTimestampSeconds, block.timestamp);\n    }\n  }\n\n  function aggregateValues(uint256[] memory values) internal pure returns (uint256) {\n    return NumericArrayLib.pickMedian(values);\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/data-services/PrimaryProdDataServiceConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"../core/RedstoneConsumerNumericBase.sol\";\n\ncontract PrimaryProdDataServiceConsumerBase is RedstoneConsumerNumericBase {\n  function getDataServiceId() public view virtual override returns (string memory) {\n    return \"redstone-primary-prod\";\n  }\n\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 3;\n  }\n\n  function getAuthorisedSignerIndex(\n    address signerAddress\n  ) public view virtual override returns (uint8) {\n    if (signerAddress == 0x8BB8F32Df04c8b654987DAaeD53D6B6091e3B774) {\n      return 0;\n    } else if (signerAddress == 0xdEB22f54738d54976C4c0fe5ce6d408E40d88499) {\n      return 1;\n    } else if (signerAddress == 0x51Ce04Be4b3E32572C4Ec9135221d0691Ba7d202) {\n      return 2;\n    } else if (signerAddress == 0xDD682daEC5A90dD295d14DA4b0bec9281017b5bE) {\n      return 3;\n    } else if (signerAddress == 0x9c5AE89C4Af6aA32cE58588DBaF90d18a855B6de) {\n      return 4;\n    } else {\n      revert SignerNotAuthorised(signerAddress);\n    }\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/libs/BitmapLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nlibrary BitmapLib {\n  function setBitInBitmap(uint256 bitmap, uint256 bitIndex) internal pure returns (uint256) {\n    return bitmap | (1 << bitIndex);\n  }\n\n  function getBitFromBitmap(uint256 bitmap, uint256 bitIndex) internal pure returns (bool) {\n    uint256 bitAtIndex = bitmap & (1 << bitIndex);\n    return bitAtIndex > 0;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/libs/NumericArrayLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nlibrary NumericArrayLib {\n  // This function sort array in memory using bubble sort algorithm,\n  // which performs even better than quick sort for small arrays\n\n  uint256 constant BYTES_ARR_LEN_VAR_BS = 32;\n  uint256 constant UINT256_VALUE_BS = 32;\n\n  error CanNotPickMedianOfEmptyArray();\n\n  // This function modifies the array\n  function pickMedian(uint256[] memory arr) internal pure returns (uint256) {\n    if (arr.length == 2) {\n      return (arr[0] + arr[1]) / 2;\n    }\n    if (arr.length == 0) {\n      revert CanNotPickMedianOfEmptyArray();\n    }\n    sort(arr);\n    uint256 middleIndex = arr.length / 2;\n    if (arr.length % 2 == 0) {\n      uint256 sum = arr[middleIndex - 1] + arr[middleIndex];\n      return sum / 2;\n    } else {\n      return arr[middleIndex];\n    }\n  }\n\n  function sort(uint256[] memory arr) internal pure {\n    assembly {\n      let arrLength := mload(arr)\n      let valuesPtr := add(arr, BYTES_ARR_LEN_VAR_BS)\n      let endPtr := add(valuesPtr, mul(arrLength, UINT256_VALUE_BS))\n      for {\n        let arrIPtr := valuesPtr\n      } lt(arrIPtr, endPtr) {\n        arrIPtr := add(arrIPtr, UINT256_VALUE_BS) // arrIPtr += 32\n      } {\n        for {\n          let arrJPtr := valuesPtr\n        } lt(arrJPtr, arrIPtr) {\n          arrJPtr := add(arrJPtr, UINT256_VALUE_BS) // arrJPtr += 32\n        } {\n          let arrI := mload(arrIPtr)\n          let arrJ := mload(arrJPtr)\n          if lt(arrI, arrJ) {\n            mstore(arrIPtr, arrJ)\n            mstore(arrJPtr, arrI)\n          }\n        }\n      }\n    }\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/libs/SignatureLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nlibrary SignatureLib {\n  uint256 constant ECDSA_SIG_R_BS = 32;\n  uint256 constant ECDSA_SIG_S_BS = 32;\n\n  function recoverSignerAddress(bytes32 signedHash, uint256 signatureCalldataNegativeOffset)\n    internal\n    pure\n    returns (address)\n  {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n    assembly {\n      let signatureCalldataStartPos := sub(calldatasize(), signatureCalldataNegativeOffset)\n      r := calldataload(signatureCalldataStartPos)\n      signatureCalldataStartPos := add(signatureCalldataStartPos, ECDSA_SIG_R_BS)\n      s := calldataload(signatureCalldataStartPos)\n      signatureCalldataStartPos := add(signatureCalldataStartPos, ECDSA_SIG_S_BS)\n      v := byte(0, calldataload(signatureCalldataStartPos)) // last byte of the signature memory array\n    }\n    return ecrecover(signedHash, v, r, s);\n  }\n}\n"
    },
    "@umb-network/toolbox/dist/contracts/IChain.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.8;\npragma abicoder v2;\n\ninterface IChain {\n  struct Block {\n    bytes32 root;\n    uint32 dataTimestamp;\n  }\n\n  struct FirstClassData {\n    uint224 value;\n    uint32 dataTimestamp;\n  }\n\n  function isForeign() external pure returns (bool);\n\n  function blocks(uint256) external view returns (Block memory);\n\n  function fcds(bytes32) external view returns (FirstClassData memory);\n\n  function blocksCount() external view returns (uint32);\n\n  function blocksCountOffset() external view returns (uint32);\n\n  function padding() external view returns (uint16);\n\n  function getName() external pure returns (bytes32);\n\n  function recoverSigner(bytes32 affidavit, uint8 _v, bytes32 _r, bytes32 _s) external pure returns (address);\n\n  function getStatus() external view returns(\n    uint256 blockNumber,\n    uint16 timePadding,\n    uint32 lastDataTimestamp,\n    uint32 lastBlockId,\n    address nextLeader,\n    uint32 nextBlockId,\n    address[] memory validators,\n    uint256[] memory powers,\n    string[] memory locations,\n    uint256 staked\n  );\n\n  function getBlockId() external view returns (uint32);\n\n  // this function does not works for past timestamps\n  function getBlockIdAtTimestamp(uint256 _timestamp) external view returns (uint32);\n\n  function getLatestBlockId() external view returns (uint32);\n\n  function getLeaderIndex(uint256 _numberOfValidators, uint256 _timestamp) external view returns (uint256);\n\n  function getNextLeaderAddress() external view returns (address);\n\n  function getLeaderAddress() external view returns (address);\n\n  function getLeaderAddressAtTime(uint232 _timestamp) external view returns (address);\n\n  function hashLeaf(bytes calldata _key, bytes calldata _value) external pure returns (bytes32);\n\n  function verifyProof(bytes32[] calldata _proof, bytes32 _root, bytes32 _leaf) external pure returns (bool);\n\n  function verifyProofForBlock(\n    uint256 _blockId,\n    bytes32[] calldata _proof,\n    bytes calldata _key,\n    bytes calldata _value\n  ) external view returns (bool);\n\n  function bytesToBytes32Array(\n    bytes calldata _data,\n    uint256 _offset,\n    uint256 _items\n  ) external pure returns (bytes32[] memory);\n\n  function verifyProofs(\n    uint32[] memory _blockIds,\n    bytes memory _proofs,\n    uint256[] memory _proofItemsCounter,\n    bytes32[] memory _leaves\n  ) external view returns (bool[] memory results);\n  \n  function getBlockRoot(uint256 _blockId) external view returns (bytes32);\n\n  function getBlockTimestamp(uint32 _blockId) external view returns (uint32);\n\n  function getCurrentValues(bytes32[] calldata _keys)\n  external view returns (uint256[] memory values, uint32[] memory timestamps);\n\n  function getCurrentValue(bytes32 _key) external view returns (uint256 value, uint256 timestamp);\n}\n"
    },
    "@umb-network/toolbox/dist/contracts/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.8;\n\ninterface IRegistry {\n  function registry(bytes32 _name) external view returns (address);\n\n  function requireAndGetAddress(bytes32 _name) external view returns (address);\n\n  function getAddress(bytes32 _bytes) external view returns (address);\n\n  function getAddressByString(string memory _name) external view returns (address);\n\n  function stringToBytes32(string memory _string) external pure returns (bytes32);\n}\n"
    },
    "@uniswap/lib/contracts/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n        // else z = 0\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\nimport './Babylonian.sol';\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n    uint private constant Q112 = uint(1) << RESOLUTION;\n    uint private constant Q224 = Q112 << RESOLUTION;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\n        return uq112x112(self._x / uint224(x));\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\n        uint z;\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\n        return uq144x112(z);\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // equivalent to encode(numerator).div(denominator)\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n\n    // take the reciprocal of a UQ112x112\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        require(self._x != 0, 'FixedPoint: ZERO_RECIPROCAL');\n        return uq112x112(uint224(Q224 / self._x));\n    }\n\n    // square root of a UQ112x112\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x)) << 56));\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol": {
      "content": "pragma solidity >=0.5.0;\n\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport '@uniswap/lib/contracts/libraries/FixedPoint.sol';\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n    using FixedPoint for *;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2 ** 32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(\n        address pair\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n            // counterfactual\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n        }\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
    },
    "contracts/access/Governable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/core/IAddressProvider.sol\";\n\n/**\n * @notice Contract module which provides access control mechanism, where\n * the governor account is granted with exclusive access to specific functions.\n * @dev Uses the AddressProvider to get the governor\n */\nabstract contract Governable {\n    IAddressProvider public constant addressProvider = IAddressProvider(0xfbA0816A81bcAbBf3829bED28618177a2bf0e82A);\n\n    /// @dev Throws if called by any account other than the governor.\n    modifier onlyGovernor() {\n        require(msg.sender == addressProvider.governor(), \"not-governor\");\n        _;\n    }\n}\n"
    },
    "contracts/core/ChainlinkBasePriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./ChainlinkPriceProvider.sol\";\n\n/**\n * @title Chainlink's price provider for optimism network\n */\ncontract ChainlinkBasePriceProvider is ChainlinkPriceProvider {\n    constructor() {\n        // optimism aggregators: https://docs.chain.link/data-feeds/price-feeds/addresses?network=base\n        // Note: These are NOT all available aggregators, not adding them all to avoid too expensive deployment cost\n        _setAggregator(0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913, AggregatorV3Interface(0x7e860098F58bBFC8648a4311b374B1D669a2bc6B)); // USDC\n        _setAggregator(0x3932FBCB64859BA68cD3eA5B2a2694Fe1daF4F03, AggregatorV3Interface(0xCCADC697c55bbB68dc5bCdf8d3CBe83CdD4E071E)); // WBTC\n        _setAggregator(0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb, AggregatorV3Interface(0x591e79239a7d679378eC8c847e5038150364C78F)); // DAI\n        _setAggregator(0x4200000000000000000000000000000000000006, AggregatorV3Interface(0x71041dddad3595F9CEd3DcCFBe3D1F4b0a16Bb70)); // WETH               \n    }\n}\n"
    },
    "contracts/core/ChainlinkFeedPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol\";\nimport \"./ChainlinkPriceProvider.sol\";\nimport \"../libraries/OracleHelpers.sol\";\n\n/**\n * @title ChainLink's price provider that uses price feed (only available on Mainnet currently)\n * @dev This contract is more expensive (+ ~1.3k) than others contracts (that don't use feed)\n * because they get decimals during aggregator addition\n */\ncontract ChainlinkFeedPriceProvider is ChainlinkPriceProvider {\n    using SafeCast for int256;\n    using OracleHelpers for uint256;\n\n    address public constant USD = address(840); // Chainlink follows https://en.wikipedia.org/wiki/ISO_4217\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant BTC = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\n    FeedRegistryInterface public constant PRICE_FEED =\n        FeedRegistryInterface(0x47Fb2585D2C56Fe188D0E6ec628a38b74fCeeeDf);\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(address token_) public view override returns (uint256 _priceInUsd, uint256 _lastUpdatedAt) {\n        int256 _price;\n\n        AggregatorV3Interface _aggregator = aggregators[token_];\n        if (address(_aggregator) != address(0)) {\n            (, _price, , _lastUpdatedAt, ) = _aggregator.latestRoundData();\n            return (_price.toUint256() * TO_SCALE, _lastUpdatedAt);\n        }\n\n        if (token_ == WETH) {\n            token_ = ETH;\n        } else if (token_ == WBTC) {\n            token_ = BTC;\n        }\n        (, _price, , _lastUpdatedAt, ) = PRICE_FEED.latestRoundData(token_, USD);\n        _priceInUsd = _price.toUint256().scaleDecimal(PRICE_FEED.decimals(token_, USD), USD_DECIMALS);\n    }\n}\n"
    },
    "contracts/core/ChainlinkMainnetPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol\";\nimport \"./ChainlinkPriceProvider.sol\";\nimport \"../libraries/OracleHelpers.sol\";\n\n/**\n * @title Chainlink's price provider for Mainnet network\n * @dev Not uses price feed in order to save gas\n */\ncontract ChainlinkMainnetPriceProvider is ChainlinkPriceProvider {\n    constructor() {\n        // Mainnet's aggregators: https://docs.chain.link/docs/ethereum-addresses/\n        // Note: These are NOT all available aggregators, not adding them all to avoid too expensive deployment cost\n        _setAggregator(0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9, AggregatorV3Interface(0x547a514d5e3769680Ce22B2361c10Ea13619e8a9)); // AAVE\n        _setAggregator(0x85f138bfEE4ef8e540890CFb48F620571d67Eda3, AggregatorV3Interface(0xFF3EEb22B5E3dE6e705b44749C2559d704923FD7)); // WAVAX\n        _setAggregator(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599, AggregatorV3Interface(0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c)); // WBTC\n        _setAggregator(0xc00e94Cb662C3520282E6f5717214004A7f26888, AggregatorV3Interface(0xdbd020CAeF83eFd542f4De03e3cF0C28A4428bd5)); // COMP\n        _setAggregator(0xD533a949740bb3306d119CC777fa900bA034cd52, AggregatorV3Interface(0xCd627aA160A6fA45Eb793D19Ef54f5062F20f33f)); // CRV\n        _setAggregator(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B, AggregatorV3Interface(0xd962fC30A72A84cE50161031391756Bf2876Af5D)); // CVX\n        _setAggregator(0x6B175474E89094C44Da98b954EedeAC495271d0F, AggregatorV3Interface(0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9)); // DAI\n        _setAggregator(0x1494CA1F11D487c2bBe4543E90080AeBa4BA3C2b, AggregatorV3Interface(0xD2A593BF7594aCE1faD597adb697b5645d5edDB2)); // DPI\n        _setAggregator(0xC18360217D8F7Ab5e7c516566761Ea12Ce7F9D72, AggregatorV3Interface(0x5C00128d4d1c2F4f652C267d7bcdD7aC99C16E16)); // ENS\n        _setAggregator(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419)); // WETH\n        _setAggregator(0x853d955aCEf822Db058eb8505911ED77F175b99e, AggregatorV3Interface(0xB9E1E3A9feFf48998E45Fa90847ed4D467E8BcfD)); // FRAX\n        _setAggregator(0xc944E90C64B2c07662A292be6244BDf05Cda44a7, AggregatorV3Interface(0x86cF33a451dE9dc61a2862FD94FF4ad4Bd65A5d2)); // GRT\n        _setAggregator(0x514910771AF9Ca656af840dff83E8264EcF986CA, AggregatorV3Interface(0x2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c)); // LINK\n        _setAggregator(0x7c9f4C87d911613Fe9ca58b579f737911AAD2D43, AggregatorV3Interface(0x7bAC85A8a13A4BcD8abb3eB7d6b4d632c5a57676)); // WMATIC\n        _setAggregator(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3, AggregatorV3Interface(0x7A364e8770418566e3eb2001A96116E6138Eb32F)); // MIM\n        _setAggregator(0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2, AggregatorV3Interface(0xec1D1B3b0443256cc3860e24a46F108e699484Aa)); // MKR\n        _setAggregator(0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F, AggregatorV3Interface(0xDC3EA94CD0AC27d9A86C180091e7f78C683d3699)); // SNX\n        _setAggregator(0x090185f2135308BaD17527004364eBcC2D37e5F6, AggregatorV3Interface(0x8c110B94C5f1d347fAcF5E1E938AB2db60E3c9a8)); // SPELL\n        _setAggregator(0x6B3595068778DD592e39A122f4f5a5cF09C90fE2, AggregatorV3Interface(0xCc70F09A6CC17553b2E31954cD36E4A2d89501f7)); // SUSHI\n        _setAggregator(0x0000000000085d4780B73119b644AE5ecd22b376, AggregatorV3Interface(0xec746eCF986E2927Abd291a2A1716c940100f8Ba)); // TUSD\n        _setAggregator(0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984, AggregatorV3Interface(0x553303d460EE0afB37EdFf9bE42922D8FF63220e)); // UNI\n        _setAggregator(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, AggregatorV3Interface(0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6)); // USDC\n        _setAggregator(0xdAC17F958D2ee523a2206206994597C13D831ec7, AggregatorV3Interface(0x3E7d1eAB13ad0104d2750B8863b489D65364e32D)); // USDT\n        _setAggregator(0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e, AggregatorV3Interface(0xA027702dbb89fbd58938e4324ac03B58d812b0E1)); // YFI\n    }\n}\n"
    },
    "contracts/core/ChainlinkOptimismPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./ChainlinkPriceProvider.sol\";\n\n/**\n * @title Chainlink's price provider for optimism network\n */\ncontract ChainlinkOptimismPriceProvider is ChainlinkPriceProvider {\n    constructor() {\n        // optimism aggregators: https://docs.chain.link/data-feeds/price-feeds/addresses?network=optimism\n        // Note: These are NOT all available aggregators, not adding them all to avoid too expensive deployment cost\n        _setAggregator(0x7F5c764cBc14f9669B88837ca1490cCa17c31607, AggregatorV3Interface(0x16a9FA2FDa030272Ce99B29CF780dFA30361E0f3)); // USDC\n        _setAggregator(0x68f180fcCe6836688e9084f035309E29Bf0A2095, AggregatorV3Interface(0x718A5788b89454aAE3A028AE9c111A29Be6c2a6F)); // WBTC\n        _setAggregator(0x4200000000000000000000000000000000000042, AggregatorV3Interface(0x0D276FC14719f9292D5C1eA2198673d1f4269246)); // OP\n        _setAggregator(0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1, AggregatorV3Interface(0x8dBa75e83DA73cc766A7e5a0ee71F656BAb470d6)); // DAI\n        _setAggregator(0x4200000000000000000000000000000000000006, AggregatorV3Interface(0x13e3Ee699D1909E989722E753853AE30b17e08c5)); // WETH               \n    }\n}\n"
    },
    "contracts/core/ChainlinkPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../interfaces/core/IChainlinkPriceProvider.sol\";\nimport \"./PriceProvider.sol\";\nimport \"../access/Governable.sol\";\n\n/**\n * @title ChainLink's price provider\n * @dev This contract wraps chainlink aggregators\n */\ncontract ChainlinkPriceProvider is IChainlinkPriceProvider, PriceProvider, Governable {\n    using SafeCast for int256;\n\n    uint256 public constant CHAINLINK_DECIMALS = 8;\n    uint256 public constant TO_SCALE = 10**(USD_DECIMALS - CHAINLINK_DECIMALS);\n\n    /**\n     * @notice Aggregators map (token => aggregator)\n     */\n    mapping(address => AggregatorV3Interface) public aggregators;\n\n    /// Emitted when an aggregator is updated\n    event AggregatorUpdated(address token, AggregatorV3Interface oldAggregator, AggregatorV3Interface newAggregator);\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(address token_)\n        public\n        view\n        virtual\n        override(IPriceProvider, PriceProvider)\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        AggregatorV3Interface _aggregator = aggregators[token_];\n        require(address(_aggregator) != address(0), \"token-without-aggregator\");\n        int256 _price;\n        (, _price, , _lastUpdatedAt, ) = _aggregator.latestRoundData();\n        return (_price.toUint256() * TO_SCALE, _lastUpdatedAt);\n    }\n\n    /// @inheritdoc IChainlinkPriceProvider\n    function updateAggregator(address token_, AggregatorV3Interface aggregator_) external override onlyGovernor {\n        require(token_ != address(0), \"token-is-null\");\n        AggregatorV3Interface _current = aggregators[token_];\n        require(aggregator_ != _current, \"same-as-current\");\n        _setAggregator(token_, aggregator_);\n        emit AggregatorUpdated(token_, _current, aggregator_);\n    }\n\n    function _setAggregator(address token_, AggregatorV3Interface aggregator_) internal {\n        require(address(aggregator_) == address(0) || aggregator_.decimals() == CHAINLINK_DECIMALS, \"invalid-decimals\");\n        aggregators[token_] = aggregator_;\n    }\n}\n"
    },
    "contracts/core/PriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../interfaces/core/IPriceProvider.sol\";\n\n/**\n * @title Price providers' super class that implements common functions\n */\nabstract contract PriceProvider is IPriceProvider {\n    uint256 public constant USD_DECIMALS = 18;\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(address token_) public view virtual returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /// @inheritdoc IPriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        view\n        virtual\n        override\n        returns (uint256 _amountOut, uint256 _tokenInLastUpdatedAt, uint256 _tokenOutLastUpdatedAt)\n    {\n        uint256 _amountInUsd;\n        (_amountInUsd, _tokenInLastUpdatedAt) = quoteTokenToUsd(tokenIn_, amountIn_);\n        (_amountOut, _tokenOutLastUpdatedAt) = quoteUsdToToken(tokenOut_, _amountInUsd);\n    }\n\n    /// @inheritdoc IPriceProvider\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        uint256 _price;\n        (_price, _lastUpdatedAt) = getPriceInUsd(token_);\n        _amountOut = (amountIn_ * _price) / 10 ** IERC20Metadata(token_).decimals();\n    }\n\n    /// @inheritdoc IPriceProvider\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        uint256 _price;\n        (_price, _lastUpdatedAt) = getPriceInUsd(token_);\n        if (_price == 0) {\n            return (0, 0);\n        }\n        _amountOut = (amountIn_ * 10 ** IERC20Metadata(token_).decimals()) / _price;\n    }\n}\n"
    },
    "contracts/core/PriceProvidersAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../interfaces/core/IPriceProvidersAggregator.sol\";\nimport \"../access/Governable.sol\";\n\n/**\n * @title Price Providers Aggregator\n */\ncontract PriceProvidersAggregator is IPriceProvidersAggregator, Governable {\n    /**\n     * The native token (usually the most liquid asset in the chain)\n     * @dev Is used when getting quote from two price providers\n     */\n    address public immutable nativeToken;\n\n    /**\n     * @notice Price providers map\n     */\n    mapping(DataTypes.Provider => IPriceProvider) public override priceProviders;\n\n    /// Emitted when an price provider is updated\n    event PriceProviderUpdated(\n        DataTypes.Provider provider,\n        IPriceProvider oldPriceProvider,\n        IPriceProvider newPriceProvider\n    );\n\n    constructor(address nativeToken_) {\n        require(nativeToken_ != address(0), \"native-token-is-null\");\n        nativeToken = nativeToken_;\n    }\n\n    /// @inheritdoc IPriceProvidersAggregator\n    function getPriceInUsd(DataTypes.Provider provider_, address token_)\n        external\n        view\n        override\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        IPriceProvider _provider = priceProviders[provider_];\n        require(address(_provider) != address(0), \"provider-not-set\");\n        return _provider.getPriceInUsd(token_);\n    }\n\n    /// @inheritdoc IPriceProvidersAggregator\n    function quote(\n        DataTypes.Provider provider_,\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        view\n        override\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        IPriceProvider _provider = priceProviders[provider_];\n        require(address(_provider) != address(0), \"provider-not-set\");\n        return _provider.quote(tokenIn_, tokenOut_, amountIn_);\n    }\n\n    /// @inheritdoc IPriceProvidersAggregator\n    function quote(\n        DataTypes.Provider providerIn_,\n        address tokenIn_,\n        DataTypes.Provider providerOut_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        public\n        view\n        override\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _nativeTokenLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        IPriceProvider _providerIn = priceProviders[providerIn_];\n        require(address(_providerIn) != address(0), \"provider-in-not-set\");\n\n        if (providerIn_ == providerOut_) {\n            (_amountOut, _tokenInLastUpdatedAt, _tokenOutLastUpdatedAt) = _providerIn.quote(\n                tokenIn_,\n                tokenOut_,\n                amountIn_\n            );\n            _nativeTokenLastUpdatedAt = block.timestamp;\n            return (_amountOut, _tokenInLastUpdatedAt, _nativeTokenLastUpdatedAt, _tokenOutLastUpdatedAt);\n        }\n\n        IPriceProvider _providerOut = priceProviders[providerOut_];\n        require(address(_providerOut) != address(0), \"provider-out-not-set\");\n\n        uint256 _nativeTokenLastUpdatedAt0;\n        uint256 _nativeTokenLastUpdatedAt1;\n        (_amountOut, _tokenInLastUpdatedAt, _nativeTokenLastUpdatedAt0) = _providerIn.quote(\n            tokenIn_,\n            nativeToken,\n            amountIn_\n        );\n        (_amountOut, _nativeTokenLastUpdatedAt1, _tokenOutLastUpdatedAt) = _providerOut.quote(\n            nativeToken,\n            tokenOut_,\n            _amountOut\n        );\n        _nativeTokenLastUpdatedAt = Math.min(_nativeTokenLastUpdatedAt0, _nativeTokenLastUpdatedAt1);\n    }\n\n    /// @inheritdoc IPriceProvidersAggregator\n    function quoteTokenToUsd(\n        DataTypes.Provider provider_,\n        address token_,\n        uint256 amountIn_\n    ) external view override returns (uint256 amountOut_, uint256 _lastUpdatedAt) {\n        IPriceProvider _provider = priceProviders[provider_];\n        require(address(_provider) != address(0), \"provider-not-set\");\n        return _provider.quoteTokenToUsd(token_, amountIn_);\n    }\n\n    /// @inheritdoc IPriceProvidersAggregator\n    function quoteUsdToToken(\n        DataTypes.Provider provider_,\n        address token_,\n        uint256 amountIn_\n    ) external view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        IPriceProvider _provider = priceProviders[provider_];\n        require(address(_provider) != address(0), \"provider-not-set\");\n        return _provider.quoteUsdToToken(token_, amountIn_);\n    }\n\n    /// @inheritdoc IPriceProvidersAggregator\n    function setPriceProvider(DataTypes.Provider provider_, IPriceProvider priceProvider_)\n        external\n        override\n        onlyGovernor\n    {\n        require(provider_ != DataTypes.Provider.NONE, \"invalid-provider\");\n        IPriceProvider _current = priceProviders[provider_];\n        require(priceProvider_ != _current, \"same-as-current\");\n\n        emit PriceProviderUpdated(provider_, _current, priceProvider_);\n\n        priceProviders[provider_] = priceProvider_;\n    }\n}\n"
    },
    "contracts/core/PythMainnetPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./PythPriceProvider.sol\";\n\n/**\n * @title Pyth's price provider with Mainnet pre-setup\n */\ncontract PythMainnetPriceProvider is PythPriceProvider {\n    constructor(IPyth pyth_) PythPriceProvider(pyth_) {\n        feedIds[0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48] = 0xeaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a; // USDC\n        feedIds[0x6B175474E89094C44Da98b954EedeAC495271d0F] = 0xb0948a5e5313200c632b51bb5ca32f6de0d36e9950a942d19751e833f70dabfd; // DAI\n        feedIds[0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2] = 0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace; // WETH\n        feedIds[0x64351fC9810aDAd17A690E4e1717Df5e7e085160] = 0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace; // msETH\n        feedIds[0x853d955aCEf822Db058eb8505911ED77F175b99e] = 0xc3d5d8d6d17081b3d0bbca6e2fa3a6704bb9a9561d9f9e1dc52db47629f862ad; // FRAX\n        feedIds[0xac3E018457B222d93114458476f3E3416Abbe38F] = 0xb2bb466ff5386a63c18aa7c3bc953cb540c755e2aa99dafb13bc4c177692bed0; // sfrxETH\n        feedIds[0xae78736Cd615f374D3085123A210448E74Fc6393] = 0xa0255134973f4fdf2f8f7808354274a3b1ebc6ee438be898d045e8b56ba1fe13; // rETH\n        feedIds[0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84] = 0x846ae1bdb6300b817cee5fdee2a6da192775030db5615b94a465f53bd40850b5; // stETH\n        feedIds[0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599] = 0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43; // WBTC\n        feedIds[0x8b4F8aD3801B4015Dea6DA1D36f063Cbf4e231c7] = 0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43; // msBTC\n        feedIds[0xBe9895146f7AF43049ca1c1AE358B0541Ea49704] = 0x15ecddd26d49e1a8f1de9376ebebc03916ede873447c1255d2d5891b92ce5717; // cbETH\n    }\n}\n"
    },
    "contracts/core/PythPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IPyth} from \"@pythnetwork/pyth-sdk-solidity/IPyth.sol\";\nimport {PythStructs} from \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {IPythPriceProvider} from \"../interfaces/core/IPythPriceProvider.sol\";\nimport {IPriceProvider, PriceProvider} from \"./PriceProvider.sol\";\nimport {Governable} from \"../access/Governable.sol\";\n\n/**\n * @title Pyth's price provider\n * @dev This contract wraps Pyth contract\n */\ncontract PythPriceProvider is IPythPriceProvider, PriceProvider, Governable {\n    using SafeCast for int256;\n    using Address for address payable;\n\n    int256 internal constant MIN_EXPONENT = -18;\n    int256 internal constant MAX_EXPONENT = 0;\n    uint256 internal constant MAX_TIME_TOLERANCE = 1 minutes;\n\n    /// @notice Pyth main contract\n    IPyth public immutable pyth;\n\n    /// @notice Feed ids map (token => feedId)\n    mapping(address => bytes32) public feedIds;\n\n    /// @notice Emitted when an aggregator is updated\n    event FeedIdUpdated(address token, bytes32 feedId);\n\n    constructor(IPyth pyth_) {\n        pyth = pyth_;\n    }\n\n    /// @notice Get update fee (native coin)\n    function getUpdateFee(bytes[] calldata updateData_) external view returns (uint _feeAmount) {\n        return pyth.getUpdateFee(updateData_);\n    }\n\n    /// @notice Update Pyth's prices\n    function updatePrice(bytes[] calldata updateData_) external payable {\n        uint256 _fee = pyth.getUpdateFee(updateData_);\n        require(msg.value >= _fee, \"value-too-low\");\n\n        pyth.updatePriceFeeds{value: _fee}(updateData_);\n\n        if (msg.value > _fee) {\n            payable(msg.sender).sendValue(msg.value - _fee);\n        }\n    }\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(\n        address token_\n    )\n        public\n        view\n        virtual\n        override(IPriceProvider, PriceProvider)\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        bytes32 _feedId = feedIds[token_];\n\n        if (_feedId == bytes32(0)) {\n            return (0, 0);\n        }\n\n        PythStructs.Price memory _p = pyth.getPriceUnsafe(_feedId);\n        _lastUpdatedAt = _p.publishTime;\n\n        if (_lastUpdatedAt < block.timestamp && block.timestamp - _lastUpdatedAt > MAX_TIME_TOLERANCE) {\n            return (0, 0);\n        }\n\n        if (_lastUpdatedAt > block.timestamp && _lastUpdatedAt - block.timestamp > MAX_TIME_TOLERANCE) {\n            return (0, 0);\n        }\n\n        if (_p.price == 0) {\n            return (0, 0);\n        }\n\n        if (_p.expo < MIN_EXPONENT || _p.expo > MAX_EXPONENT) {\n            return (0, 0);\n        }\n\n        uint256 _toScale = (10 ** int256(18 + _p.expo).toUint256());\n        _priceInUsd = int256(_p.price).toUint256() * _toScale;\n    }\n\n    /// @inheritdoc IPythPriceProvider\n    function updateFeedId(address token_, bytes32 feedId_) external override onlyGovernor {\n        require(token_ != address(0), \"token-is-null\");\n\n        feedIds[token_] = feedId_;\n\n        emit FeedIdUpdated(token_, feedId_);\n    }\n}\n"
    },
    "contracts/core/RedstoneHemiPushPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./ChainlinkPriceProvider.sol\";\n\n/**\n * @title Redstone's push price provider for Hemi network. Redstone push price feed is 100% compatible with Chainlink.\n */\ncontract RedstoneHemiPushPriceProvider is ChainlinkPriceProvider {\n    constructor() {\n        _setAggregator(0x824D8FcDC36E81618377D140BEC12c3B7E4e4cbA, AggregatorV3Interface(0x31a36CdF4465ba61ce78F5CDbA26FDF8ec361803)); // USDC\n        _setAggregator(0xbbA60da06c2c5424f03f7434542280FCAd453d10, AggregatorV3Interface(0xe8D9FbC10e00ecc9f0694617075fDAF657a76FB2)); // USDT\n        _setAggregator(0x03C7054BCB39f7b2e5B2c7AcB37583e32D70Cfa3, AggregatorV3Interface(0xE23eCA12D7D2ED3829499556F6dCE06642AFd990)); // WBTC\n        _setAggregator(0x4200000000000000000000000000000000000006, AggregatorV3Interface(0xb9D0073aCb296719C26a8BF156e4b599174fe1d5)); // WETH\n    }\n}\n"
    },
    "contracts/core/RedstoneMainnetPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./RedstonePriceProvider.sol\";\n\n/**\n * @title Redstone's price provider with Mainnet pre-setup\n */\ncontract RedstoneMainnetPriceProvider is RedstonePriceProvider {\n    constructor() {\n        feeds[bytes32(\"USDC\")].push(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n        feeds[bytes32(\"DAI\")].push(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n        feeds[bytes32(\"ETH\")].push(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH\n        feeds[bytes32(\"ETH\")].push(0x64351fC9810aDAd17A690E4e1717Df5e7e085160); // msETH\n        feeds[bytes32(\"FRAX\")].push(0x853d955aCEf822Db058eb8505911ED77F175b99e);\n        feeds[bytes32(\"sfrxETH\")].push(0xac3E018457B222d93114458476f3E3416Abbe38F);\n        feeds[bytes32(\"rETH\")].push(0xae78736Cd615f374D3085123A210448E74Fc6393);\n        feeds[bytes32(\"stETH\")].push(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);\n        feeds[bytes32(\"BTC\")].push(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599); // WBTC\n        feeds[bytes32(\"BTC\")].push(0x8b4F8aD3801B4015Dea6DA1D36f063Cbf4e231c7); // msBTC\n    }\n}\n"
    },
    "contracts/core/RedstonePriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {PrimaryProdDataServiceConsumerBase} from \"@redstone-finance/evm-connector/contracts/data-services/PrimaryProdDataServiceConsumerBase.sol\";\nimport {IRedstonePriceProvider} from \"../interfaces/core/IRedstonePriceProvider.sol\";\nimport {IPriceProvider, PriceProvider} from \"./PriceProvider.sol\";\nimport {Governable} from \"../access/Governable.sol\";\n\n/**\n * @title Redstone's price provider\n */\ncontract RedstonePriceProvider is\n    IRedstonePriceProvider,\n    PrimaryProdDataServiceConsumerBase,\n    PriceProvider,\n    Governable\n{\n    uint256 public constant REDSTONE_DECIMALS = 8;\n    uint256 public constant TO_SCALE = 10 ** (USD_DECIMALS - REDSTONE_DECIMALS);\n    uint256 internal constant MAX_TIME_TOLERANCE = 1 minutes;\n\n    struct Cache {\n        uint256 price;\n        uint256 priceTimestamp;\n    }\n\n    /// @notice Feed ids (feedId => token)\n    mapping(bytes32 => address[]) internal feeds;\n\n    /// @notice Price cache\n    mapping(address => Cache) internal cache;\n\n    /// @notice Emitted when an feed id is updated\n    event FeedIdUpdated(bytes32 feedId, address[] tokens);\n\n    /// @notice The cache timestamp was updated.\n    /// @param price The Redstone price.\n    /// @param priceTimestamp The timestamp contained within the price data packages.\n    event CacheUpdated(uint256 price, uint256 priceTimestamp);\n\n    /// @notice Get tokens of a feed\n    function tokensOf(bytes32 feedId_) external view returns (address[] memory tokens_) {\n        return feeds[feedId_];\n    }\n\n    /// @notice Update price for the tokens related to the `dataFeedIds_`\n    function updatePrice(bytes32[] memory dataFeedIds_) external {\n        (uint256[] memory _values, uint256 _timestamp) = _securelyExtractOracleValuesAndTimestampFromTxMsg(\n            dataFeedIds_\n        );\n\n        uint256 _valuesLength = _values.length;\n        require(_valuesLength == dataFeedIds_.length, \"invalid-data\");\n\n        _timestamp /= 1000; // Redstone uses milliseconds\n\n        for (uint256 i; i < _valuesLength; ++i) {\n            address[] memory _tokens = feeds[dataFeedIds_[i]];\n            uint256 _tokensLength = _tokens.length;\n            for (uint j; j < _tokensLength; ++j) {\n                address _token = _tokens[j];\n                require(_token != address(0), \"feed-unknown\");\n                if (_timestamp != cache[_token].priceTimestamp) {\n                    cache[_token] = Cache({price: _values[i] * TO_SCALE, priceTimestamp: _timestamp});\n                }\n            }\n        }\n    }\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(\n        address token_\n    )\n        public\n        view\n        virtual\n        override(IPriceProvider, PriceProvider)\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        Cache memory _cache = cache[token_];\n        _lastUpdatedAt = _cache.priceTimestamp;\n        _priceInUsd = _cache.price;\n\n        if (_lastUpdatedAt == 0) {\n            return (0, 0);\n        }\n\n        if (_lastUpdatedAt < block.timestamp && block.timestamp - _lastUpdatedAt > MAX_TIME_TOLERANCE) {\n            return (0, 0);\n        }\n\n        if (_lastUpdatedAt > block.timestamp && _lastUpdatedAt - block.timestamp > MAX_TIME_TOLERANCE) {\n            return (0, 0);\n        }\n    }\n\n    /// @inheritdoc IRedstonePriceProvider\n    /// @dev The feed should be denominated in USD\n    function updateFeed(bytes32 feedId_, address[] memory tokens_) external override onlyGovernor {\n        require(feedId_ != bytes32(0), \"id-is-null\");\n\n        feeds[feedId_] = tokens_;\n\n        emit FeedIdUpdated(feedId_, tokens_);\n    }\n}\n"
    },
    "contracts/core/StableCoinProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../libraries/OracleHelpers.sol\";\nimport \"../interfaces/core/IStableCoinProvider.sol\";\nimport \"../features/UsingStalePeriod.sol\";\nimport \"../features/UsingMaxDeviation.sol\";\n\n/**\n * @title Provide pegged stable coin, useful for getting USD prices reference from DEXes\n * @dev This contract mitigates a de-peg scenario by checking price against two stable coins that should be around 1\n */\ncontract StableCoinProvider is IStableCoinProvider, UsingStalePeriod, UsingMaxDeviation {\n    using OracleHelpers for uint256;\n\n    uint256 public constant USD_DECIMALS = 18;\n    uint256 public constant ONE_USD = 10**USD_DECIMALS;\n\n    /**\n     * @notice A stable coin to use as USD price reference\n     * @dev Should not be called directly from other contracts, must use `getStableCoinIfPegged`\n     */\n    address public primaryStableCoin;\n    uint8 private __primaryStableCoinDecimals;\n\n    /**\n     * @notice A secondary stable coin used to check USD-peg against primary\n     * @dev Should not be called directly from other contracts, must use `getStableCoinIfPegged`\n     */\n    address public secondaryStableCoin;\n    uint8 private __secondaryStableCoinDecimals;\n\n    /// @notice Emitted when stable coin is updated\n    event StableCoinsUpdated(\n        address oldPrimaryStableCoin,\n        address oldSecondaryStableCoin,\n        address newPrimaryStableCoin,\n        address newSecondaryStableCoin\n    );\n\n    constructor(\n        address primaryStableCoin_,\n        address secondaryStableCoin_,\n        uint256 stalePeriod_,\n        uint256 maxDeviation_\n    ) UsingStalePeriod(stalePeriod_) UsingMaxDeviation(maxDeviation_) {\n        _updateStableCoins(primaryStableCoin_, secondaryStableCoin_);\n    }\n\n    /// @inheritdoc IStableCoinProvider\n    function getStableCoinIfPegged() external view returns (address _stableCoin) {\n        // Note: Chainlink supports DAI/USDC/USDT on all chains that we're using\n        IPriceProvider _chainlink = addressProvider.providersAggregator().priceProviders(DataTypes.Provider.CHAINLINK);\n\n        (uint256 _priceInUsd, uint256 _lastUpdatedAt) = _chainlink.getPriceInUsd(primaryStableCoin);\n\n        if (!_priceIsStale(primaryStableCoin, _lastUpdatedAt) && _isDeviationOK(_priceInUsd, ONE_USD)) {\n            return primaryStableCoin;\n        }\n\n        (_priceInUsd, _lastUpdatedAt) = _chainlink.getPriceInUsd(secondaryStableCoin);\n\n        require(\n            !_priceIsStale(secondaryStableCoin, _lastUpdatedAt) && _isDeviationOK(_priceInUsd, ONE_USD),\n            \"stable-prices-invalid\"\n        );\n\n        return secondaryStableCoin;\n    }\n\n    /// @inheritdoc IStableCoinProvider\n    function toUsdRepresentation(uint256 stableCoinAmount_) external view returns (uint256 _usdAmount) {\n        uint256 _stableCoinDecimals = __primaryStableCoinDecimals;\n        if (_stableCoinDecimals == USD_DECIMALS) {\n            return stableCoinAmount_;\n        }\n        _usdAmount = stableCoinAmount_.scaleDecimal(_stableCoinDecimals, USD_DECIMALS);\n    }\n\n    /**\n     * @notice Update the stable coin keeping correct decimals value\n     * @dev Must have both as set or null\n     */\n    function _updateStableCoins(address primaryStableCoin_, address secondaryStableCoin_) private {\n        require(primaryStableCoin_ != address(0) && secondaryStableCoin_ != address(0), \"stable-coins-are-null\");\n        require(primaryStableCoin_ != secondaryStableCoin_, \"stable-coins-are-the-same\");\n\n        // Update both\n        primaryStableCoin = primaryStableCoin_;\n        secondaryStableCoin = secondaryStableCoin_;\n        __primaryStableCoinDecimals = IERC20Metadata(primaryStableCoin_).decimals();\n        __secondaryStableCoinDecimals = IERC20Metadata(secondaryStableCoin_).decimals();\n    }\n\n    /**\n     * @notice Update stable coin\n     * @dev Used externally by the governor\n     */\n    function updateStableCoins(address primaryStableCoin_, address secondaryStableCoin_) external onlyGovernor {\n        emit StableCoinsUpdated(primaryStableCoin, secondaryStableCoin, primaryStableCoin_, secondaryStableCoin_);\n        _updateStableCoins(primaryStableCoin_, secondaryStableCoin_);\n    }\n}\n"
    },
    "contracts/core/UmbrellaPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@umb-network/toolbox/dist/contracts/IChain.sol\";\nimport \"@umb-network/toolbox/dist/contracts/IRegistry.sol\";\nimport \"../access/Governable.sol\";\nimport \"../interfaces/core/IUmbrellaPriceProvider.sol\";\nimport \"./PriceProvider.sol\";\n\n/**\n * @notice Umbrella's price provider\n */\ncontract UmbrellaPriceProvider is IUmbrellaPriceProvider, PriceProvider, Governable {\n    bytes32 private constant CHAIN = bytes32(\"Chain\");\n\n    /**\n     * @notice token => Umbrella's key mapping (e.g. WBTC => \"BTC-USD\")\n     */\n    mapping(address => bytes32) public keyOfToken;\n\n    /**\n     * @notice Umbrella's Registry\n     * @dev Stores the other Umbrella's contracts' addresses\n     */\n    IRegistry public immutable registry;\n\n    event KeyOfTokenUpdated(address indexed token, bytes32 oldKey, bytes32 newKey);\n\n    constructor(IRegistry registry_) {\n        require(address(registry_) != address(0), \"registry-is-null\");\n        registry = registry_;\n    }\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(address token_)\n        public\n        view\n        virtual\n        override(IPriceProvider, PriceProvider)\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        (_priceInUsd, _lastUpdatedAt) = _chain().getCurrentValue(keyOfToken[token_]);\n        require(_lastUpdatedAt > 0, \"invalid-quote\");\n    }\n\n    /**\n     * @notice Get Umbrella's main contract\n     */\n    function _chain() internal view returns (IChain umbChain) {\n        umbChain = IChain(registry.getAddress(CHAIN));\n    }\n\n    /**\n     * @notice Build key from quote/base string in bytes format\n     * @dev The standard parser `bytes32(bytes)` will right pad with zeros\n     * but Umbrella expects left padded bytes as key\n     * @dev See if there is a simpler way to do the same as this function\n     */\n    function _toKey(bytes memory quotePairAsBytes_) private pure returns (bytes32) {\n        bytes memory _aux = new bytes(32);\n        uint256 _len = quotePairAsBytes_.length;\n        for (uint256 i; i < _len; ++i) {\n            uint256 _idx = 32 - _len + i;\n            _aux[_idx] = quotePairAsBytes_[i];\n        }\n        return bytes32(_aux);\n    }\n\n    /**\n     * @notice Update Umbrella's key of a token\n     * Use `BASE-QUOTE` format (e.g. BTC-USD, ETH-USD, etc)\n     */\n    function updateKeyOfToken(address token_, string memory quotePair_) external onlyGovernor {\n        require(token_ != address(0), \"address-is-null\");\n        bytes32 _currentKey = keyOfToken[token_];\n        bytes32 _newKey = _toKey(bytes(quotePair_));\n        keyOfToken[token_] = _newKey;\n        emit KeyOfTokenUpdated(token_, _currentKey, _newKey);\n    }\n}\n"
    },
    "contracts/core/UniswapV2LikePriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@uniswap/lib/contracts/libraries/FixedPoint.sol\";\nimport \"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"../access/Governable.sol\";\nimport \"../interfaces/core/IUniswapV2LikePriceProvider.sol\";\nimport \"./PriceProvider.sol\";\n\n/**\n * @title UniswapV2 (and forks) TWAP Oracle implementation\n * Based on https://github.com/Uniswap/v2-periphery/blob/master/contracts/examples/ExampleOracleSimple.sol\n */\ncontract UniswapV2LikePriceProvider is IUniswapV2LikePriceProvider, Governable, PriceProvider {\n    using FixedPoint for *;\n\n    /**\n     * @notice The UniswapV2-like factory's address\n     */\n    address public immutable factory;\n\n    /**\n     * @notice The native wrapped token (e.g. WETH, WAVAX, WMATIC, etc)\n     */\n    address public immutable nativeToken;\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    uint256 public override defaultTwapPeriod;\n\n    struct Oracle {\n        address token0;\n        address token1;\n        uint256 price0CumulativeLast;\n        uint256 price1CumulativeLast;\n        uint32 blockTimestampLast;\n        FixedPoint.uq112x112 price0Average;\n        FixedPoint.uq112x112 price1Average;\n    }\n\n    /**\n     * @notice Oracles'\n     * @dev pair => twapPeriod => oracle\n     */\n    mapping(IUniswapV2Pair => mapping(uint256 => Oracle)) public oracles;\n\n    /// @notice Emitted when default TWAP period is updated\n    event DefaultTwapPeriodUpdated(uint256 oldTwapPeriod, uint256 newTwapPeriod);\n\n    constructor(\n        address factory_,\n        uint256 defaultTwapPeriod_,\n        address nativeToken_\n    ) {\n        require(factory_ != address(0), \"factory-is-null\");\n        defaultTwapPeriod = defaultTwapPeriod_;\n        factory = factory_;\n        nativeToken = nativeToken_;\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function hasOracle(IUniswapV2Pair pair_) external view override returns (bool) {\n        return hasOracle(pair_, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function hasOracle(IUniswapV2Pair pair_, uint256 twapPeriod_) public view override returns (bool) {\n        return oracles[pair_][twapPeriod_].blockTimestampLast > 0;\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function pairFor(address token0_, address token1_) public view override returns (IUniswapV2Pair _pair) {\n        _pair = IUniswapV2Pair(IUniswapV2Factory(factory).getPair(token0_, token1_));\n    }\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(address token_)\n        public\n        view\n        override(IPriceProvider, PriceProvider)\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        return getPriceInUsd(token_, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function getPriceInUsd(address token_, uint256 twapPeriod_)\n        public\n        view\n        override\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        IStableCoinProvider _stableCoinProvider = addressProvider.stableCoinProvider();\n        require(address(_stableCoinProvider) != address(0), \"stable-coin-not-supported\");\n\n        uint256 _stableCoinAmount;\n        (_stableCoinAmount, _lastUpdatedAt, ) = quote(\n            token_,\n            _stableCoinProvider.getStableCoinIfPegged(),\n            twapPeriod_,\n            10**IERC20Metadata(token_).decimals() // ONE\n        );\n        _priceInUsd = _stableCoinProvider.toUsdRepresentation(_stableCoinAmount);\n    }\n\n    /// @inheritdoc IPriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        view\n        override(IPriceProvider, PriceProvider)\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        return quote(tokenIn_, tokenOut_, defaultTwapPeriod, amountIn_);\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_,\n        uint256 amountIn_\n    )\n        public\n        view\n        override\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        if (tokenIn_ == tokenOut_) {\n            return (amountIn_, block.timestamp, block.timestamp);\n        }\n\n        if (hasOracle(pairFor(tokenIn_, tokenOut_), twapPeriod_)) {\n            (_amountOut, _tokenInLastUpdatedAt) = _getAmountOut(tokenIn_, tokenOut_, twapPeriod_, amountIn_);\n            _tokenOutLastUpdatedAt = _tokenInLastUpdatedAt;\n        } else {\n            (_amountOut, _tokenInLastUpdatedAt) = _getAmountOut(tokenIn_, nativeToken, twapPeriod_, amountIn_);\n            (_amountOut, _tokenOutLastUpdatedAt) = _getAmountOut(nativeToken, tokenOut_, twapPeriod_, _amountOut);\n        }\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint256 twapPeriod_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        uint256 _price;\n        (_price, _lastUpdatedAt) = getPriceInUsd(token_, twapPeriod_);\n        _amountOut = (amountIn_ * _price) / 10**IERC20Metadata(token_).decimals();\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint256 twapPeriod_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        uint256 _price;\n        (_price, _lastUpdatedAt) = getPriceInUsd(token_, twapPeriod_);\n        _amountOut = (amountIn_ * 10**IERC20Metadata(token_).decimals()) / _price;\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function updateAndQuote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        override\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        return updateAndQuote(tokenIn_, tokenOut_, defaultTwapPeriod, amountIn_);\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function updateAndQuote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_,\n        uint256 amountIn_\n    )\n        public\n        override\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        updateOrAdd(tokenIn_, tokenOut_, twapPeriod_);\n        return quote(tokenIn_, tokenOut_, twapPeriod_, amountIn_);\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function updateOrAdd(address tokenIn_, address tokenOut_) external override {\n        updateOrAdd(tokenIn_, tokenOut_, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function updateOrAdd(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_\n    ) public override {\n        IUniswapV2Pair _pair = pairFor(tokenIn_, tokenOut_);\n        if (!hasOracle(_pair, twapPeriod_)) {\n            _addOracleFor(_pair, twapPeriod_);\n        }\n        _updateIfNeeded(_pair, twapPeriod_);\n    }\n\n    /**\n     * @notice Create new oracle\n     * @param pair_ The pair to get prices from\n     * @param twapPeriod_ The TWAP period\n     */\n    function _addOracleFor(IUniswapV2Pair pair_, uint256 twapPeriod_) private {\n        require(address(pair_) != address(0), \"invalid-pair\");\n\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = pair_.getReserves();\n\n        require(_reserve0 != 0 && _reserve1 != 0, \"no-reserves\");\n\n        oracles[pair_][twapPeriod_] = Oracle({\n            token0: pair_.token0(),\n            token1: pair_.token1(),\n            price0CumulativeLast: pair_.price0CumulativeLast(),\n            price1CumulativeLast: pair_.price1CumulativeLast(),\n            blockTimestampLast: _blockTimestampLast,\n            price0Average: uint112(0).encode(),\n            price1Average: uint112(0).encode()\n        });\n    }\n\n    /**\n     * @notice Get the output amount for a given oracle\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param twapPeriod_ The TWAP period\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function _getAmountOut(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_,\n        uint256 amountIn_\n    ) private view returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        Oracle memory _oracle = oracles[pairFor(tokenIn_, tokenOut_)][twapPeriod_];\n        if (tokenIn_ == _oracle.token0) {\n            _amountOut = _oracle.price0Average.mul(amountIn_).decode144();\n        } else {\n            _amountOut = _oracle.price1Average.mul(amountIn_).decode144();\n        }\n        _lastUpdatedAt = _oracle.blockTimestampLast;\n    }\n\n    /**\n     * @notice Update an oracle\n     * @param pair_ The pair to update\n     * @param twapPeriod_ The TWAP period\n     * @return True if updated was performed\n     */\n    function _updateIfNeeded(IUniswapV2Pair pair_, uint256 twapPeriod_) private returns (bool) {\n        Oracle storage _oracle = oracles[pair_][twapPeriod_];\n\n        (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) = UniswapV2OracleLibrary\n            .currentCumulativePrices(address(pair_));\n        uint32 timeElapsed;\n        unchecked {\n            timeElapsed = blockTimestamp - _oracle.blockTimestampLast; // overflow is desired\n        }\n        // ensure that at least one full period has passed since the last update\n        if (timeElapsed < twapPeriod_) return false;\n\n        uint256 price0new;\n        uint256 price1new;\n\n        unchecked {\n            price0new = price0Cumulative - _oracle.price0CumulativeLast;\n            price1new = price1Cumulative - _oracle.price1CumulativeLast;\n        }\n\n        // overflow is desired, casting never truncates\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\n        _oracle.price0Average = FixedPoint.uq112x112(uint224(price0new / timeElapsed));\n        _oracle.price1Average = FixedPoint.uq112x112(uint224(price1new / timeElapsed));\n        _oracle.price0CumulativeLast = price0Cumulative;\n        _oracle.price1CumulativeLast = price1Cumulative;\n        _oracle.blockTimestampLast = blockTimestamp;\n        return true;\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function updateDefaultTwapPeriod(uint256 newDefaultTwapPeriod_) external override onlyGovernor {\n        emit DefaultTwapPeriodUpdated(defaultTwapPeriod, newDefaultTwapPeriod_);\n        defaultTwapPeriod = newDefaultTwapPeriod_;\n    }\n}\n"
    },
    "contracts/core/UniswapV3PriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../access/Governable.sol\";\nimport \"../interfaces/utils/IUniswapV3CrossPoolOracle.sol\";\nimport \"../interfaces/core/IUniswapV3PriceProvider.sol\";\nimport \"./PriceProvider.sol\";\n\ncontract UniswapV3PriceProvider is IUniswapV3PriceProvider, Governable, PriceProvider {\n    /**\n     * @notice The UniswapV3CrossPoolOracle contract\n     * @dev This contract encapsulates UniswapV3 oracle logic\n     */\n    IUniswapV3CrossPoolOracle public immutable crossPoolOracle;\n\n    /**\n     * @notice The time-weighted average price (TWAP) period\n     * @dev See more: https://docs.uniswap.org/protocol/concepts/V3-overview/oracle\n     */\n    uint32 public override defaultTwapPeriod;\n\n    /**\n     * @notice The default pool fee to use\n     * @dev Use 1e6 for 100% (e.g 3000 is 0.3%)\n     */\n    uint24 public defaultPoolFee;\n\n    /// @notice Emitted when the default TWAP period is updated\n    event DefaultTwapPeriodUpdated(uint32 oldDefaultTwapPeriod, uint32 newDefaultTwapPeriod);\n\n    /// @notice Emitted when the default pool fee updated\n    event DefaultPoolFeeUpdated(uint24 oldDefaultPoolFee, uint24 newDefaultPoolFee);\n\n    constructor(\n        IUniswapV3CrossPoolOracle crossPoolOracle_,\n        uint32 defaultTwapPeriod_,\n        uint24 defaultFee_\n    ) {\n        require(address(crossPoolOracle_) != address(0), \"cross-pool-is-null\");\n        crossPoolOracle = crossPoolOracle_;\n        defaultTwapPeriod = defaultTwapPeriod_;\n        defaultPoolFee = defaultFee_;\n    }\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(address token_)\n        public\n        view\n        override(IPriceProvider, PriceProvider)\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        return getPriceInUsd(token_, defaultPoolFee, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function getPriceInUsd(address token_, uint32 twapPeriod_)\n        public\n        view\n        override\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        return getPriceInUsd(token_, defaultPoolFee, twapPeriod_);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function getPriceInUsd(address token_, uint24 poolFee_)\n        public\n        view\n        override\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        return getPriceInUsd(token_, poolFee_, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function getPriceInUsd(\n        address token_,\n        uint24 poolFee_,\n        uint32 twapPeriod_\n    ) public view override returns (uint256 _priceInUsd, uint256 _lastUpdatedAt) {\n        IStableCoinProvider _stableCoinProvider = addressProvider.stableCoinProvider();\n        require(address(_stableCoinProvider) != address(0), \"stable-coin-not-supported\");\n\n        uint256 _stableCoinAmount;\n        (_stableCoinAmount, _lastUpdatedAt, ) = quote(\n            token_,\n            _stableCoinProvider.getStableCoinIfPegged(),\n            poolFee_,\n            twapPeriod_,\n            10**IERC20Metadata(token_).decimals() // ONE\n        );\n\n        _priceInUsd = _stableCoinProvider.toUsdRepresentation(_stableCoinAmount);\n    }\n\n    /// @inheritdoc IPriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        view\n        override(IPriceProvider, PriceProvider)\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        return quote(tokenIn_, tokenOut_, defaultPoolFee, defaultTwapPeriod, amountIn_);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint32 twapPeriod_,\n        uint256 amountIn_\n    )\n        external\n        view\n        override\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        return quote(tokenIn_, tokenOut_, defaultPoolFee, twapPeriod_, amountIn_);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint24 poolFee_,\n        uint256 amountIn_\n    )\n        external\n        view\n        override\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        return quote(tokenIn_, tokenOut_, poolFee_, defaultTwapPeriod, amountIn_);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint24 poolFee_,\n        uint32 twapPeriod_,\n        uint256 amountIn_\n    )\n        public\n        view\n        override\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        if (tokenIn_ == tokenOut_) {\n            return (amountIn_, block.timestamp, block.timestamp);\n        }\n\n        if (tokenIn_ == crossPoolOracle.nativeToken()) {\n            _amountOut = crossPoolOracle.ethToAsset(amountIn_, tokenOut_, poolFee_, twapPeriod_);\n        } else if (tokenOut_ == crossPoolOracle.nativeToken()) {\n            _amountOut = crossPoolOracle.assetToEth(tokenIn_, amountIn_, poolFee_, twapPeriod_);\n        } else {\n            _amountOut = crossPoolOracle.assetToAsset(tokenIn_, amountIn_, tokenOut_, poolFee_, twapPeriod_);\n        }\n        _tokenInLastUpdatedAt = block.timestamp;\n        _tokenOutLastUpdatedAt = block.timestamp;\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        return quoteTokenToUsd(token_, amountIn_, poolFee_, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint32 twapPeriod_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        return quoteTokenToUsd(token_, amountIn_, defaultPoolFee, twapPeriod_);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_,\n        uint32 twapPeriod_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        uint256 _price;\n        (_price, _lastUpdatedAt) = getPriceInUsd(token_, poolFee_, twapPeriod_);\n        _amountOut = (amountIn_ * _price) / 10**IERC20Metadata(token_).decimals();\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        return quoteUsdToToken(token_, amountIn_, poolFee_, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint32 twapPeriod_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        return quoteUsdToToken(token_, amountIn_, defaultPoolFee, twapPeriod_);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_,\n        uint32 twapPeriod_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        uint256 _price;\n        (_price, _lastUpdatedAt) = getPriceInUsd(token_, poolFee_, twapPeriod_);\n        _amountOut = (amountIn_ * 10**IERC20Metadata(token_).decimals()) / _price;\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function updateDefaultTwapPeriod(uint32 newDefaultTwapPeriod_) external onlyGovernor {\n        emit DefaultTwapPeriodUpdated(defaultTwapPeriod, newDefaultTwapPeriod_);\n        defaultTwapPeriod = newDefaultTwapPeriod_;\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function updateDefaultPoolFee(uint24 newDefaultPoolFee_) external onlyGovernor {\n        emit DefaultPoolFeeUpdated(defaultPoolFee, newDefaultPoolFee_);\n        defaultPoolFee = newDefaultPoolFee_;\n    }\n}\n"
    },
    "contracts/dependencies/@umb-network/IChain.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IChain {\n  struct Block {\n    bytes32 root;\n    uint32 dataTimestamp;\n  }\n\n  struct FirstClassData {\n    uint224 value;\n    uint32 dataTimestamp;\n  }\n\n  function isForeign() external pure returns (bool);\n\n  function blocks(uint256) external view returns (Block memory);\n\n  function fcds(bytes32) external view returns (FirstClassData memory);\n\n  function blocksCount() external view returns (uint32);\n\n  function blocksCountOffset() external view returns (uint32);\n\n  function padding() external view returns (uint16);\n\n  function getName() external pure returns (bytes32);\n\n  function recoverSigner(bytes32 affidavit, uint8 _v, bytes32 _r, bytes32 _s) external pure returns (address);\n\n  function getStatus() external view returns(\n    uint256 blockNumber,\n    uint16 timePadding,\n    uint32 lastDataTimestamp,\n    uint32 lastBlockId,\n    address nextLeader,\n    uint32 nextBlockId,\n    address[] memory validators,\n    uint256[] memory powers,\n    string[] memory locations,\n    uint256 staked\n  );\n\n  function getBlockId() external view returns (uint32);\n\n  // this function does not works for past timestamps\n  function getBlockIdAtTimestamp(uint256 _timestamp) external view returns (uint32);\n\n  function getLatestBlockId() external view returns (uint32);\n\n  function getLeaderIndex(uint256 _numberOfValidators, uint256 _timestamp) external view returns (uint256);\n\n  function getNextLeaderAddress() external view returns (address);\n\n  function getLeaderAddress() external view returns (address);\n\n  function getLeaderAddressAtTime(uint232 _timestamp) external view returns (address);\n\n  function hashLeaf(bytes calldata _key, bytes calldata _value) external pure returns (bytes32);\n\n  function verifyProof(bytes32[] calldata _proof, bytes32 _root, bytes32 _leaf) external pure returns (bool);\n\n  function verifyProofForBlock(\n    uint256 _blockId,\n    bytes32[] calldata _proof,\n    bytes calldata _key,\n    bytes calldata _value\n  ) external view returns (bool);\n\n  function bytesToBytes32Array(\n    bytes calldata _data,\n    uint256 _offset,\n    uint256 _items\n  ) external pure returns (bytes32[] memory);\n\n  function verifyProofs(\n    uint32[] memory _blockIds,\n    bytes memory _proofs,\n    uint256[] memory _proofItemsCounter,\n    bytes32[] memory _leaves\n  ) external view returns (bool[] memory results);\n\n  function getBlockRoot(uint256 _blockId) external view returns (bytes32);\n\n  function getBlockTimestamp(uint32 _blockId) external view returns (uint32);\n\n  function getCurrentValues(bytes32[] calldata _keys)\n  external view returns (uint256[] memory values, uint32[] memory timestamps);\n\n  function getCurrentValue(bytes32 _key) external view returns (uint256 value, uint256 timestamp);\n}\n"
    },
    "contracts/dependencies/@umb-network/interfaces/IDatumReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../lib/PassportStructs.sol\";\n\ninterface IDatumReceiver {\n  /// @notice This function will hold the parameters or business rules that consumer\n  /// wants to do with the received data structure, here called Pallet.\n  /// @param _pallet the structure sent by DatumRegistry, containing proof, key and value\n  function receivePallet(Pallet calldata _pallet) external;\n\n  /// @notice This function holds rules that consumer may need to check before accepting\n  /// the Pallet. Rules like how old is the block, or how many blocks have passed since\n  /// last storage. Deliverer will check if approvePallet reverted this call or returned true.\n  /// @param _pallet The exact same Pallet that will arrive at the receivePallet endpoint.\n  /// @return true if wants pallet or should REVERT if Contract does not want the pallet.\n  /// @dev DO NOT RETURN false.\n  function approvePallet(Pallet calldata _pallet) external view returns (bool);\n}\n"
    },
    "contracts/dependencies/@umb-network/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IRegistry {\n  function registry(bytes32 _name) external view returns (address);\n\n  function requireAndGetAddress(bytes32 _name) external view returns (address);\n\n  function getAddress(bytes32 _bytes) external view returns (address);\n\n  function getAddressByString(string memory _name) external view returns (address);\n\n  function stringToBytes32(string memory _string) external pure returns (bytes32);\n}\n"
    },
    "contracts/dependencies/@umb-network/lib/PassportStructs.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nstruct Datum {\n  address receiver;\n  bytes32[] keys;\n  address funder;\n  uint128 balance;\n  bool enabled;\n}\n\nstruct Pallet {\n  uint32 blockId;\n  bytes32 key;\n  bytes32 value;\n  bytes32[] proof;\n}\n\nstruct Delivery {\n  bytes32 datumId;\n  uint256[] indexes;\n}\n"
    },
    "contracts/dependencies/@umb-network/lib/ValueDecoder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nlibrary ValueDecoder {\n  function toUint(bytes memory _bytes) internal pure returns (uint256 value) {\n    assembly {\n      value := mload(add(_bytes, 32))\n    }\n  }\n\n  function toUint(bytes32 _bytes) internal pure returns (uint256 value) {\n    assembly {\n      value := _bytes\n    }\n  }\n\n  function toInt(uint224 u) internal pure returns (int256) {\n    int224 i;\n    uint224 max = type(uint224).max;\n\n    if (u <= (max - 1) / 2) { // positive values\n      assembly {\n        i := add(u, 0)\n      }\n\n      return i;\n    } else { // negative values\n      assembly {\n        i := sub(sub(u, max), 1)\n      }\n    }\n\n    return i;\n  }\n}\n\n"
    },
    "contracts/features/UsingMaxDeviation.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../access/Governable.sol\";\n\n/**\n * @title Deviation check feature, useful when checking prices from different providers for the same asset\n */\nabstract contract UsingMaxDeviation is Governable {\n    /**\n     * @notice The max acceptable deviation\n     * @dev 18-decimals scale (e.g 1e17 = 10%)\n     */\n    uint256 public maxDeviation;\n\n    /// @notice Emitted when max deviation is updated\n    event MaxDeviationUpdated(uint256 oldMaxDeviation, uint256 newMaxDeviation);\n\n    constructor(uint256 maxDeviation_) {\n        maxDeviation = maxDeviation_;\n    }\n\n    /**\n     * @notice Update max deviation\n     */\n    function updateMaxDeviation(uint256 maxDeviation_) external onlyGovernor {\n        emit MaxDeviationUpdated(maxDeviation, maxDeviation_);\n        maxDeviation = maxDeviation_;\n    }\n\n    /**\n     * @notice Check if two numbers deviation is acceptable\n     */\n    function _isDeviationOK(uint256 a_, uint256 b_) internal view returns (bool) {\n        uint256 _deviation = a_ > b_ ? ((a_ - b_) * 1e18) / a_ : ((b_ - a_) * 1e18) / b_;\n        return _deviation <= maxDeviation;\n    }\n}\n"
    },
    "contracts/features/UsingStalePeriod.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../access/Governable.sol\";\n\n/**\n * @title Stale price check feature, useful when checking if prices are fresh enough\n */\nabstract contract UsingStalePeriod is Governable {\n    /// @notice The default stale period. It's used to determine if a price is invalid (i.e. outdated)\n    uint256 public defaultStalePeriod;\n\n    /// @notice Custom stale period, used for token that has different stale window (e.g. some stable coins have 24h window)\n    mapping(address => uint256) customStalePeriod;\n\n    /// @notice Emitted when custom stale period is updated\n    event CustomStalePeriodUpdated(address token, uint256 oldStalePeriod, uint256 newStalePeriod);\n\n    /// @notice Emitted when default stale period is updated\n    event DefaultStalePeriodUpdated(uint256 oldStalePeriod, uint256 newStalePeriod);\n\n    constructor(uint256 defaultStalePeriod_) {\n        defaultStalePeriod = defaultStalePeriod_;\n    }\n\n    /**\n     * @notice Get stale period of a token\n     */\n    function stalePeriodOf(address token_) public view returns (uint256 _stalePeriod) {\n        _stalePeriod = customStalePeriod[token_];\n        if (_stalePeriod == 0) {\n            _stalePeriod = defaultStalePeriod;\n        }\n    }\n\n    /**\n     * @notice Check if a price timestamp is outdated\n     * @dev Uses default stale period\n     * @param timeOfLastUpdate_ The price timestamp\n     * @return true if price is stale (outdated)\n     */\n    function _priceIsStale(address token_, uint256 timeOfLastUpdate_) internal view returns (bool) {\n        return _priceIsStale(timeOfLastUpdate_, stalePeriodOf(token_));\n    }\n\n    /**\n     * @notice Check if a price timestamp is outdated\n     * @param timeOfLastUpdate_ The price timestamp\n     * @param stalePeriod_ The maximum acceptable outdated period\n     * @return true if price is stale (outdated)\n     */\n    function _priceIsStale(uint256 timeOfLastUpdate_, uint256 stalePeriod_) internal view returns (bool) {\n        return block.timestamp - timeOfLastUpdate_ > stalePeriod_;\n    }\n\n    /**\n     * @notice Update custom stale period\n     * @dev Use `0` as `stalePeriod_` to remove custom stale period\n     */\n    function updateCustomStalePeriod(address token_, uint256 stalePeriod_) external onlyGovernor {\n        require(token_ != address(0), \"token-is-null\");\n        emit CustomStalePeriodUpdated(token_, customStalePeriod[token_], stalePeriod_);\n        if (stalePeriod_ > 0) {\n            customStalePeriod[token_] = stalePeriod_;\n        } else {\n            delete customStalePeriod[token_];\n        }\n    }\n\n    /**\n     * @notice Update default stale period\n     */\n    function updateDefaultStalePeriod(uint256 stalePeriod_) external onlyGovernor {\n        emit DefaultStalePeriodUpdated(defaultStalePeriod, stalePeriod_);\n        defaultStalePeriod = stalePeriod_;\n    }\n}\n"
    },
    "contracts/interfaces/core/IAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./IStableCoinProvider.sol\";\nimport \"./IPriceProvidersAggregator.sol\";\n\ninterface IAddressProvider {\n    function governor() external view returns (address);\n\n    function providersAggregator() external view returns (IPriceProvidersAggregator);\n\n    function stableCoinProvider() external view returns (IStableCoinProvider);\n\n    function updateProvidersAggregator(IPriceProvidersAggregator providersAggregator_) external;\n}\n"
    },
    "contracts/interfaces/core/IChainlinkPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./IPriceProvider.sol\";\n\ninterface IChainlinkPriceProvider is IPriceProvider {\n    /**\n     * @notice Update token's aggregator\n     */\n    function updateAggregator(address token_, AggregatorV3Interface aggregator_) external;\n}\n"
    },
    "contracts/interfaces/core/IPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IPriceProvider {\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of asset\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(address token_) external view returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(address token_, uint256 amountIn_)\n        external\n        view\n        returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetOut\n     * @param amountIn_ Input amount in USD\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(address token_, uint256 amountIn_)\n        external\n        view\n        returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n}\n"
    },
    "contracts/interfaces/core/IPriceProvidersAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../libraries/DataTypes.sol\";\nimport \"./IPriceProvider.sol\";\n\n/**\n * @notice PriceProvidersAggregator interface\n * @dev Worth noting that the `_lastUpdatedAt` logic depends on the underlying price provider. In summary:\n * ChainLink: returns the last updated date from the aggregator\n * UniswapV2: returns the date of the latest pair oracle update\n * UniswapV3: assumes that the price is always updated (returns block.timestamp)\n * Umbrella (FCD): returns the last updated date returned from their oracle contract\n * Umbrella (Passport): returns the date of the latest pallet submission\n * Anytime that a quote performs more than one query, it uses the oldest date as the `_lastUpdatedAt`.\n * See more: https://github.com/bloqpriv/one-oracle/issues/64\n */\ninterface IPriceProvidersAggregator {\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param provider_ The price provider to get quote from\n     * @param token_ The address of asset\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(\n        DataTypes.Provider provider_,\n        address token_\n    ) external view returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Provider Providers' mapping\n     */\n    function priceProviders(DataTypes.Provider provider_) external view returns (IPriceProvider _priceProvider);\n\n    /**\n     * @notice Get quote\n     * @param provider_ The price provider to get quote from\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        DataTypes.Provider provider_,\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external view returns (uint256 _amountOut, uint256 _tokenInLastUpdatedAt, uint256 _tokenOutLastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @dev If providers aren't the same, uses native token as \"bridge\"\n     * @param providerIn_ The price provider to get quote for the tokenIn\n     * @param tokenIn_ The address of assetIn\n     * @param providerOut_ The price provider to get quote for the tokenOut\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _nativeTokenLastUpdatedAt Last updated timestamp of native token (i.e. WETH) used when providers aren't the same\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        DataTypes.Provider providerIn_,\n        address tokenIn_,\n        DataTypes.Provider providerOut_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _nativeTokenLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param provider_ The price provider to get quote from\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(\n        DataTypes.Provider provider_,\n        address token_,\n        uint256 amountIn_\n    ) external view returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param provider_ The price provider to get quote from\n     * @param token_ The address of assetOut\n     * @param amountIn_ Input amount in USD\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(\n        DataTypes.Provider provider_,\n        address token_,\n        uint256 amountIn_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Set a price provider\n     * @dev Administrative function\n     * @param provider_ The provider (from enum)\n     * @param priceProvider_ The price provider contract\n     */\n    function setPriceProvider(DataTypes.Provider provider_, IPriceProvider priceProvider_) external;\n}\n"
    },
    "contracts/interfaces/core/IPythPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./IPriceProvider.sol\";\n\ninterface IPythPriceProvider is IPriceProvider {\n    /**\n     * @notice Update token's feed id\n     */\n    function updateFeedId(address token_, bytes32 feedId_) external;\n}\n"
    },
    "contracts/interfaces/core/IRedstonePriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./IPriceProvider.sol\";\n\ninterface IRedstonePriceProvider is IPriceProvider {\n    /**\n     * @notice Update feed id\n     */\n    function updateFeed(bytes32 feedId_, address[] memory tokens_) external;\n}\n"
    },
    "contracts/interfaces/core/IStableCoinProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IStableCoinProvider {\n    /**\n     * @notice Return the stable coin if pegged\n     * @dev Check price relation between both stable coins and revert if peg is too loose\n     * @return _stableCoin The primary stable coin if pass all checks\n     */\n    function getStableCoinIfPegged() external view returns (address _stableCoin);\n\n    /**\n     * @notice Convert given amount of stable coin to USD representation (18 decimals)\n     */\n    function toUsdRepresentation(uint256 stableCoinAmount_) external view returns (uint256 _usdAmount);\n}\n"
    },
    "contracts/interfaces/core/IUmbrellaPassportPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../dependencies/@umb-network/interfaces/IDatumReceiver.sol\";\nimport \"./IUmbrellaPriceProvider.sol\";\n\ninterface IUmbrellaPassportPriceProvider is IUmbrellaPriceProvider, IDatumReceiver {\n    /**\n     * @notice Updates heartbeat\n     */\n    function updateHeartbeatTimestamp(uint128 heartbeatTimestamp_) external;\n\n    /**\n     * @notice Updates deviation threshold\n     */\n    function updateDeviationThreshold(uint128 deviationThreshold_) external;\n}\n"
    },
    "contracts/interfaces/core/IUmbrellaPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./IPriceProvider.sol\";\n\ninterface IUmbrellaPriceProvider is IPriceProvider {}\n"
    },
    "contracts/interfaces/core/IUniswapV2LikePriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"./IPriceProvider.sol\";\n\ninterface IUniswapV2LikePriceProvider is IPriceProvider {\n    /**\n     * @notice The default time-weighted average price (TWAP) period\n     * Used when a period isn't specified\n     * @dev See more: https://docs.uniswap.org/protocol/concepts/V3-overview/oracle\n     */\n    function defaultTwapPeriod() external view returns (uint256);\n\n    /**\n     * @notice Check if there is an oracle for the PAIR-TWAP key\n     * @param pair_ The pair\n     * @param twapPeriod_ The TWAP period\n     * @return True if exists\n     */\n    function hasOracle(IUniswapV2Pair pair_, uint256 twapPeriod_) external view returns (bool);\n\n    /**\n     * @notice Check if there is an oracle for the PAIR-TWAP key\n     * @dev Uses `defaultTwapPeriod`\n     * @param pair_ The pair\n     * @return True if exists\n     */\n    function hasOracle(IUniswapV2Pair pair_) external view returns (bool);\n\n    /**\n     * @notice Returns the pair's contract\n     */\n    function pairFor(address token0_, address token1_) external view returns (IUniswapV2Pair _pair);\n\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of assetIn\n     * @param twapPeriod_ The TWAP period\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(address token_, uint256 twapPeriod_)\n        external\n        view\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param twapPeriod_ The TWAP period\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_,\n        uint256 amountIn_\n    )\n        external\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @param twapPeriod_ The TWAP period\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint256 twapPeriod_\n    ) external view returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetIn\n     * @param amountIn_ Input amount in USD\n     * @param twapPeriod_ The TWAP period\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint256 twapPeriod_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @dev Will update the oracle if needed before getting quote\n     * @dev Uses `defaultTwapPeriod`\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function updateAndQuote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote\n     * @dev Will update the oracle if needed before getting quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param twapPeriod_ The TWAP period\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function updateAndQuote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_,\n        uint256 amountIn_\n    )\n        external\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Update the default TWAP period\n     * @dev Administrative function\n     * @param newDefaultTwapPeriod_ The new default period\n     */\n    function updateDefaultTwapPeriod(uint256 newDefaultTwapPeriod_) external;\n\n    /**\n     * @notice Update cumulative and average price of pair\n     * @dev Will create the pair if it doesn't exist\n     * @dev Uses `defaultTwapPeriod`\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     */\n    function updateOrAdd(address tokenIn_, address tokenOut_) external;\n\n    /**\n     * @notice Update cumulative and average price of pair\n     * @dev Will create the pair if it doesn't exist\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param twapPeriod_ The TWAP period\n     */\n    function updateOrAdd(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_\n    ) external;\n}\n"
    },
    "contracts/interfaces/core/IUniswapV3PriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./IPriceProvider.sol\";\n\ninterface IUniswapV3PriceProvider is IPriceProvider {\n    /**\n     * @notice The default time-weighted average price (TWAP) period\n     * Used when a period isn't specified\n     * @dev See more: https://docs.uniswap.org/protocol/concepts/V3-overview/oracle\n     */\n    function defaultTwapPeriod() external view returns (uint32);\n\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of assetIn\n     * @param poolFee_ The pools' fees\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(address token_, uint24 poolFee_)\n        external\n        view\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of assetIn\n     * @param twapPeriod_ The TWAP period\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(address token_, uint32 twapPeriod_)\n        external\n        view\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of assetIn\n     * @param poolFee_ The pools' fees\n     * @param twapPeriod_ The TWAP period\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(\n        address token_,\n        uint24 poolFee_,\n        uint32 twapPeriod_\n    ) external view returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param twapPeriod_ The TWAP period\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint32 twapPeriod_,\n        uint256 amountIn_\n    )\n        external\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param poolFee_ The pools' fees\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint24 poolFee_,\n        uint256 amountIn_\n    )\n        external\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param poolFee_ The pools' fees\n     * @param twapPeriod_ The TWAP period\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint24 poolFee_,\n        uint32 twapPeriod_,\n        uint256 amountIn_\n    )\n        external\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @param poolFee_ The pools' fees\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_\n    ) external view returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @param twapPeriod_ The TWAP period\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint32 twapPeriod_\n    ) external view returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @param poolFee_ The pools' fees\n     * @param twapPeriod_ The TWAP period\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_,\n        uint32 twapPeriod_\n    ) external view returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetIn\n     * @param amountIn_ Input amount in USD\n     * @param poolFee_ The TWAP period\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetIn\n     * @param amountIn_ Input amount in USD\n     * @param twapPeriod_ The TWAP period\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint32 twapPeriod_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetIn\n     * @param amountIn_ Input amount in USD\n     * @param poolFee_ The TWAP period\n     * @param twapPeriod_ The TWAP period\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_,\n        uint32 twapPeriod_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Update the default TWAP period\n     * @dev Administrative function\n     * @param newDefaultTwapPeriod_ The new default period\n     */\n    function updateDefaultTwapPeriod(uint32 newDefaultTwapPeriod_) external;\n\n    /**\n     * @notice Update the default pool fee\n     * @dev Administrative function\n     * @param newDefaultPoolFee_ The new default period\n     */\n    function updateDefaultPoolFee(uint24 newDefaultPoolFee_) external;\n}\n"
    },
    "contracts/interfaces/external/aave/IAToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IAToken is IERC20 {\n    function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n}\n"
    },
    "contracts/interfaces/external/badger/IXToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IXToken {\n    function pricePerShare() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/bloom/IBloomPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ninterface IBloomPool is IERC20Metadata {\n    enum State {\n        Other,\n        Commit,\n        ReadyPreHoldSwap,\n        PendingPreHoldSwap,\n        Holding,\n        ReadyPostHoldSwap,\n        PendingPostHoldSwap,\n        EmergencyExit,\n        FinalWithdraw\n    }\n\n    function POOL_PHASE_END() external view returns (uint256);\n\n    function state() external view returns (State);\n\n    function getDistributionInfo()\n        external\n        view\n        returns (\n            uint128 borrowerDistribution,\n            uint128 totalBorrowerShares,\n            uint128 lenderDistribution,\n            uint128 totalLenderShares\n        );\n\n    function UNDERLYING_TOKEN() external view returns (IERC20Metadata);\n}\n"
    },
    "contracts/interfaces/external/bloom/IExchangeRateRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IExchangeRateRegistry {\n    function getExchangeRate(address token) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/compound/ICToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ICToken {\n    function exchangeRateStored() external view returns (uint256);\n\n    function underlying() external view returns (address);\n}\n"
    },
    "contracts/interfaces/external/curve/ICurveAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ICurveAddressProvider {\n    function get_registry() external view returns (address);\n\n    function get_address(uint256 i) external view returns (address);\n}\n"
    },
    "contracts/interfaces/external/curve/ICurveFactoryRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ICurveFactoryRegistry {\n    function get_n_coins(address lp) external view returns (uint256);\n\n    function get_coins(address pool) external view returns (address[4] memory);\n\n    function get_meta_n_coins(address pool) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/interfaces/external/curve/ICurveMetaRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ICurveMetaRegistry {\n    function get_lp_token(address _pool) external view returns (address);\n\n    function get_n_underlying_coins(address _pool) external view returns (uint256);\n\n    function get_pool_from_lp_token(address _token) external view returns (address);\n\n    function get_underlying_coins(address _pool) external view returns (address[8] memory);\n}\n"
    },
    "contracts/interfaces/external/curve/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ICurvePool {\n    function get_virtual_price() external view returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy\n    ) external payable;\n}\n"
    },
    "contracts/interfaces/external/curve/ICurveRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ICurveRegistry {\n    function get_n_coins(address lp) external view returns (uint256);\n\n    function get_coins(address pool) external view returns (address[8] memory);\n\n    function get_underlying_coins(address pool) external view returns (address[8] memory);\n\n    function get_pool_from_lp_token(address lp) external view returns (address);\n\n    function is_meta(address pool) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/external/curve/ICurveSwaps.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ICurveSwaps {\n    /* solhint-disable */\n    function get_best_rate(address _from, address _to, uint256 _amount) external view returns (address, uint256);\n\n    function get_exchange_amount(\n        address _pool,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external view returns (uint256);\n\n    function exchange(\n        address _pool,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint256 _expected,\n        address _receiver\n    ) external payable returns (uint256);\n\n    /**\n     @notice This function queries the exchange rate for every pool where a swap between _to and _from is possible.\n     For pairs that can be swapped in many pools this will result in very significant gas costs!\n     */\n    function exchange_with_best_rate(\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint256 _expected,\n        address _receiver\n    ) external payable returns (uint256);\n\n    function get_exchange_multiple_amount(\n        address[9] calldata _route,\n        uint256[3][4] calldata _swap_params,\n        uint256 _amount\n    ) external view returns (uint256);\n\n    function exchange_multiple(\n        address[9] calldata _route,\n        uint256[3][4] calldata _swap_params,\n        uint256 _amount,\n        uint256 _expected,\n        address[4] calldata _pools,\n        address _receiver\n    ) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/curve/IFrxEthStableSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./ICurvePool.sol\";\n\ninterface IFrxEthStableSwap is ICurvePool {\n    function price_oracle() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/frax/ISFrxEth.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Note: This file generated from sfrxEth contract at https://etherscan.io/address/0xac3e018457b222d93114458476f3e3416abbe38f#code\ninterface ISFrxEth is IERC20 {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function asset() external view returns (address);\n\n    function convertToAssets(uint256 shares) external view returns (uint256);\n\n    function convertToShares(uint256 assets) external view returns (uint256);\n\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    function depositWithSignature(\n        uint256 assets,\n        address receiver,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 shares);\n\n    function lastRewardAmount() external view returns (uint192);\n\n    function lastSync() external view returns (uint32);\n\n    function maxDeposit(address) external view returns (uint256);\n\n    function maxMint(address) external view returns (uint256);\n\n    function maxRedeem(address owner) external view returns (uint256);\n\n    function maxWithdraw(address owner) external view returns (uint256);\n\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    function nonces(address) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function previewDeposit(uint256 assets) external view returns (uint256);\n\n    function previewMint(uint256 shares) external view returns (uint256);\n\n    function previewRedeem(uint256 shares) external view returns (uint256);\n\n    function previewWithdraw(uint256 assets) external view returns (uint256);\n\n    function pricePerShare() external view returns (uint256);\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n\n    function rewardsCycleEnd() external view returns (uint32);\n\n    function rewardsCycleLength() external view returns (uint32);\n\n    function syncRewards() external;\n\n    function totalAssets() external view returns (uint256);\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n}\n"
    },
    "contracts/interfaces/external/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ninterface IERC4626 is IERC20Metadata {\n    function asset() external view returns (address);\n\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n}\n"
    },
    "contracts/interfaces/external/mstable/IMasset.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./MassetStructs.sol\";\n\ninterface IMasset is IERC20, MassetStructs {\n    // Mint\n    function mint(\n        address _input,\n        uint256 _inputQuantity,\n        uint256 _minOutputQuantity,\n        address _recipient\n    ) external returns (uint256 mintOutput);\n\n    function mintMulti(\n        address[] calldata _inputs,\n        uint256[] calldata _inputQuantities,\n        uint256 _minOutputQuantity,\n        address _recipient\n    ) external returns (uint256 mintOutput);\n\n    function getMintOutput(address _input, uint256 _inputQuantity) external view returns (uint256 mintOutput);\n\n    function getMintMultiOutput(address[] calldata _inputs, uint256[] calldata _inputQuantities)\n        external\n        view\n        returns (uint256 mintOutput);\n\n    // Swaps\n    function swap(\n        address _input,\n        address _output,\n        uint256 _inputQuantity,\n        uint256 _minOutputQuantity,\n        address _recipient\n    ) external returns (uint256 swapOutput);\n\n    function getSwapOutput(\n        address _input,\n        address _output,\n        uint256 _inputQuantity\n    ) external view returns (uint256 swapOutput);\n\n    // Redemption\n    function redeem(\n        address _output,\n        uint256 _mAssetQuantity,\n        uint256 _minOutputQuantity,\n        address _recipient\n    ) external returns (uint256 outputQuantity);\n\n    function redeemMasset(\n        uint256 _mAssetQuantity,\n        uint256[] calldata _minOutputQuantities,\n        address _recipient\n    ) external returns (uint256[] memory outputQuantities);\n\n    function redeemExactBassets(\n        address[] calldata _outputs,\n        uint256[] calldata _outputQuantities,\n        uint256 _maxMassetQuantity,\n        address _recipient\n    ) external returns (uint256 mAssetRedeemed);\n\n    function getRedeemOutput(address _output, uint256 _mAssetQuantity) external view returns (uint256 bAssetOutput);\n\n    function getRedeemExactBassetsOutput(address[] calldata _outputs, uint256[] calldata _outputQuantities)\n        external\n        view\n        returns (uint256 mAssetAmount);\n\n    // Views\n    function getBasket() external view returns (bool, bool);\n\n    function getBasset(address _token) external view returns (BassetPersonal memory personal, BassetData memory data);\n\n    function getBassets() external view returns (BassetPersonal[] memory personal, BassetData[] memory data);\n\n    function bAssetIndexes(address) external view returns (uint8);\n\n    // SavingsManager\n    function collectInterest() external returns (uint256 swapFeesGained, uint256 newSupply);\n\n    function collectPlatformInterest() external returns (uint256 mintAmount, uint256 newSupply);\n\n    // Admin\n    function setCacheSize(uint256 _cacheSize) external;\n\n    function upgradeForgeValidator(address _newForgeValidator) external;\n\n    function setFees(uint256 _swapFee, uint256 _redemptionFee) external;\n\n    function setTransferFeesFlag(address _bAsset, bool _flag) external;\n\n    function migrateBassets(address[] calldata _bAssets, address _newIntegration) external;\n}\n"
    },
    "contracts/interfaces/external/mstable/ISavingsContractV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ISavingsContractV2 {\n    function redeemCredits(uint256 _amount) external returns (uint256 underlyingReturned); // V2\n\n    function exchangeRate() external view returns (uint256); // V1 & V2\n}\n"
    },
    "contracts/interfaces/external/mstable/MassetStructs.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface MassetStructs {\n    struct BassetPersonal {\n        // Address of the bAsset\n        address addr;\n        // Address of the bAsset\n        address integrator;\n        // An ERC20 can charge transfer fee, for example USDT, DGX tokens.\n        bool hasTxFee; // takes a byte in storage\n        // Status of the bAsset\n        BassetStatus status;\n    }\n\n    struct BassetData {\n        // 1 Basset * ratio / ratioScale == x Masset (relative value)\n        // If ratio == 10e8 then 1 bAsset = 10 mAssets\n        // A ratio is divised as 10^(18-tokenDecimals) * measurementMultiple(relative value of 1 base unit)\n        uint128 ratio;\n        // Amount of the Basset that is held in Collateral\n        uint128 vaultBalance;\n    }\n\n    // Status of the Basset - has it broken its peg?\n    enum BassetStatus {\n        Default,\n        Normal,\n        BrokenBelowPeg,\n        BrokenAbovePeg,\n        Blacklisted,\n        Liquidating,\n        Liquidated,\n        Failed\n    }\n\n    struct BasketState {\n        bool undergoingRecol;\n        bool failed;\n    }\n\n    struct InvariantConfig {\n        uint256 a;\n        WeightLimits limits;\n    }\n\n    struct WeightLimits {\n        uint128 min;\n        uint128 max;\n    }\n\n    struct AmpData {\n        uint64 initialA;\n        uint64 targetA;\n        uint64 rampStartTime;\n        uint64 rampEndTime;\n    }\n}\n"
    },
    "contracts/interfaces/external/vesper/IVesperPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IVesperPool is IERC20 {\n    function pricePerShare() external view returns (uint256);\n\n    function token() external view returns (address);\n}\n"
    },
    "contracts/interfaces/external/yearn/IYearn.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IYearn {\n    function decimals() external view returns (uint8);\n\n    function getPricePerFullShare() external view returns (uint256);\n\n    function token() external view returns (address);\n}\n"
    },
    "contracts/interfaces/periphery/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IOracle {\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of asset\n     * @return _priceInUsd The USD price\n     */\n    function getPriceInUsd(address token_) external view returns (uint256 _priceInUsd);\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external view returns (uint256 _amountOut);\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     */\n    function quoteTokenToUsd(address token_, uint256 amountIn_) external view returns (uint256 amountOut_);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetOut\n     * @param amountIn_ Input amount in USD\n     * @return _amountOut Output amount of token\n     */\n    function quoteUsdToToken(address token_, uint256 amountIn_) external view returns (uint256 _amountOut);\n}\n"
    },
    "contracts/interfaces/periphery/ITokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ITokenOracle {\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of asset\n     * @return _priceInUsd The USD price\n     */\n    function getPriceInUsd(address token_) external view returns (uint256 _priceInUsd);\n}\n"
    },
    "contracts/interfaces/periphery/IUpdatableOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./ITokenOracle.sol\";\n\ninterface IUpdatableOracle is ITokenOracle {\n    /**\n     * @notice Update underlying price providers (i.e. UniswapV2-Like)\n     */\n    function update() external;\n}\n"
    },
    "contracts/interfaces/utils/IUniswapV3CrossPoolOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/**\n * @title UniswapV3 oracle with ability to query across an intermediate liquidity pool\n */\ninterface IUniswapV3CrossPoolOracle {\n    function nativeToken() external view returns (address);\n\n    function assetToEth(\n        address _tokenIn,\n        uint256 _amountIn,\n        uint24 _fee,\n        uint32 _twapPeriod\n    ) external view returns (uint256 ethAmountOut);\n\n    function ethToAsset(\n        uint256 _ethAmountIn,\n        address _tokenOut,\n        uint24 _fee,\n        uint32 _twapPeriod\n    ) external view returns (uint256 amountOut);\n\n    function assetToAsset(\n        address _tokenIn,\n        uint256 _amountIn,\n        address _tokenOut,\n        uint24 _fee,\n        uint32 _twapPeriod\n    ) external view returns (uint256 amountOut);\n\n    function assetToAssetThruRoute(\n        address _tokenIn,\n        uint256 _amountIn,\n        address _tokenOut,\n        uint32 _twapPeriod,\n        address _routeThruToken,\n        uint24[2] memory _poolFees\n    ) external view returns (uint256 amountOut);\n}\n"
    },
    "contracts/libraries/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nlibrary DataTypes {\n    /**\n     * @notice Price providers enumeration\n     */\n    enum Provider {\n        NONE,\n        CHAINLINK,\n        UNISWAP_V3,\n        UNISWAP_V2,\n        SUSHISWAP,\n        TRADERJOE,\n        PANGOLIN,\n        QUICKSWAP,\n        UMBRELLA_FIRST_CLASS,\n        UMBRELLA_PASSPORT\n    }\n}\n"
    },
    "contracts/libraries/OracleHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2;\n\nlibrary OracleHelpers {\n    function scaleDecimal(\n        uint256 amount,\n        uint256 _fromDecimal,\n        uint256 _toDecimal\n    ) internal pure returns (uint256) {\n        if (_fromDecimal > _toDecimal) {\n            return amount / (10**(_fromDecimal - _toDecimal));\n        } else if (_fromDecimal < _toDecimal) {\n            return amount * (10**(_toDecimal - _fromDecimal));\n        }\n        return amount;\n    }\n}\n"
    },
    "contracts/libraries/SafeUint128.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6;\n\n/// @title Safe uint128 casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeUint128 {\n    /// @notice Cast a uint256 to a uint128, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint128\n    function toUint128(uint256 y) internal pure returns (uint128 z) {\n        require((z = uint128(y)) == y, \"error-when-casting\");\n    }\n}\n"
    },
    "contracts/mock/AddressProviderMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../interfaces/core/IAddressProvider.sol\";\n\ncontract AddressProviderMock is IAddressProvider, Initializable {\n    /// @notice The governor account\n    address public governor;\n\n    /// @notice The proposed governor account. Becomes the new governor after acceptance\n    address public proposedGovernor;\n\n    /// @notice The PriceProvidersAggregator contract\n    IPriceProvidersAggregator public override providersAggregator;\n\n    /// @notice The StableCoinProvider contract\n    IStableCoinProvider public override stableCoinProvider;\n\n    /// @notice Emitted when providers aggregator is updated\n    event ProvidersAggregatorUpdated(\n        IPriceProvidersAggregator oldProvidersAggregator,\n        IPriceProvidersAggregator newProvidersAggregator\n    );\n\n    /// @notice Emitted when stable coin provider is updated\n    event StableCoinProviderUpdated(\n        IStableCoinProvider oldStableCoinProvider,\n        IStableCoinProvider newStableCoinProvider\n    );\n\n    /// @notice Emitted when governor is updated\n    event UpdatedGovernor(address indexed previousGovernor, address indexed proposedGovernor);\n\n    /**\n     * @dev Throws if called by any account other than the governor.\n     */\n    modifier onlyGovernor() {\n        require(governor == msg.sender, \"not-governor\");\n        _;\n    }\n\n    function initialize(address governor_) external initializer {\n        governor = governor_;\n        emit UpdatedGovernor(address(0), governor_);\n    }\n\n    /**\n     * @dev Allows new governor to accept governorship of the contract.\n     */\n    function acceptGovernorship() external {\n        require(msg.sender == proposedGovernor, \"not-the-proposed-governor\");\n        emit UpdatedGovernor(governor, proposedGovernor);\n        governor = proposedGovernor;\n        proposedGovernor = address(0);\n    }\n\n    /**\n     * @dev Transfers governorship of the contract to a new account (`proposedGovernor`).\n     * Can only be called by the current owner.\n     */\n    function transferGovernorship(address _proposedGovernor) external onlyGovernor {\n        require(_proposedGovernor != address(0), \"proposed-governor-is-zero\");\n        proposedGovernor = _proposedGovernor;\n    }\n\n    /**\n     * @notice Update PriceProvidersAggregator contract\n     */\n    function updateProvidersAggregator(IPriceProvidersAggregator providersAggregator_) external onlyGovernor {\n        require(address(providersAggregator_) != address(0), \"address-is-null\");\n        emit ProvidersAggregatorUpdated(providersAggregator, providersAggregator_);\n        providersAggregator = providersAggregator_;\n    }\n\n    /**\n     * @notice Update StableCoinProvider contract\n     */\n    function updateStableCoinProvider(IStableCoinProvider stableCoinProvider_) external onlyGovernor {\n        emit StableCoinProviderUpdated(stableCoinProvider, stableCoinProvider_);\n        stableCoinProvider = stableCoinProvider_;\n    }\n}\n"
    },
    "contracts/mock/ChainlinkOracleMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../interfaces/core/IChainlinkPriceProvider.sol\";\nimport \"../interfaces/periphery/IOracle.sol\";\n\ncontract ChainlinkOracleMock is IOracle {\n    IChainlinkPriceProvider public immutable chainlink;\n\n    constructor(IChainlinkPriceProvider chainlink_) {\n        chainlink = chainlink_;\n    }\n\n    function getPriceInUsd(address asset_) public view override returns (uint256 _priceInUsd) {\n        (_priceInUsd, ) = chainlink.getPriceInUsd(asset_);\n    }\n\n    function quote(\n        address, /*tokenIn_*/\n        address, /*tokenOut_*/\n        uint256 /*amountIn_*/\n    )\n        external\n        pure\n        returns (\n            uint256 /*_amountOut*/\n        )\n    {\n        revert(\"not-implemented\");\n    }\n\n    function quoteTokenToUsd(\n        address, /*token_*/\n        uint256 /*amountIn_*/\n    )\n        external\n        pure\n        returns (\n            uint256 /*amountOut_*/\n        )\n    {\n        revert(\"not-implemented\");\n    }\n\n    function quoteUsdToToken(\n        address, /*token_*/\n        uint256 /*amountIn_*/\n    )\n        external\n        pure\n        returns (\n            uint256 /*_amountOut*/\n        )\n    {\n        revert(\"not-implemented\");\n    }\n}\n"
    },
    "contracts/mock/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ERC20Mock is ERC20 {\n    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {\n        _mint(msg.sender, 1_000_000 * 1e18);\n    }\n}\n"
    },
    "contracts/mock/Import.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\n\n// solhint-disable\ncontract Import {\n\n}\n"
    },
    "contracts/mock/PriceProviderMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../core/PriceProvider.sol\";\n\ncontract PriceProviderMock is PriceProvider {\n    mapping(address => uint256) public priceInUsd;\n\n    function setPriceInUsd(address token_, uint256 priceInUsd_) public {\n        priceInUsd[token_] = priceInUsd_;\n    }\n\n    function getPriceInUsd(address token_) public view override returns (uint256 _priceInUsd, uint256 _lastUpdatedAt) {\n        _priceInUsd = priceInUsd[token_];\n        _lastUpdatedAt = block.timestamp;\n    }\n\n    function checkGasOfQuote(\n        IPriceProvider _pp,\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        public\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        return _pp.quote(tokenIn_, tokenOut_, amountIn_);\n    }\n}\n"
    },
    "contracts/mock/UsingMaxDeviationMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../features/UsingMaxDeviation.sol\";\n\ncontract UsingMaxDeviationMock is UsingMaxDeviation {\n    constructor(uint256 maxDeviation_) UsingMaxDeviation(maxDeviation_) {}\n\n    function isDeviationOK(uint256 a_, uint256 b_) external view returns (bool) {\n        return _isDeviationOK(a_, b_);\n    }\n}\n"
    },
    "contracts/mock/UsingStalePeriodMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../features/UsingStalePeriod.sol\";\n\ncontract UsingStalePeriodMock is UsingStalePeriod {\n    constructor(uint256 stalePeriod_) UsingStalePeriod(stalePeriod_) {}\n\n    function priceIsStale(uint256 timeOfLastUpdate_, uint256 stalePeriod_) external view returns (bool) {\n        return _priceIsStale(timeOfLastUpdate_, stalePeriod_);\n    }\n}\n"
    },
    "contracts/periphery/ChainlinkAndFallbacksOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../interfaces/core/IPriceProvidersAggregator.sol\";\nimport \"../interfaces/periphery/IOracle.sol\";\nimport \"../features/UsingMaxDeviation.sol\";\nimport \"../features/UsingStalePeriod.sol\";\n\n/**\n * @title Chainlink and Fallbacks oracle\n * @dev Uses chainlink as primary oracle, if it doesn't support the asset(s), get price from fallback providers\n */\ncontract ChainlinkAndFallbacksOracle is IOracle, UsingMaxDeviation, UsingStalePeriod {\n    /// @notice The fallback provider A. It's used when Chainlink isn't available\n    DataTypes.Provider public fallbackProviderA;\n\n    /// @notice The fallback provider B. It's used when Chainlink isn't available\n    /// @dev This is optional\n    DataTypes.Provider public fallbackProviderB;\n\n    /// @notice Emitted when fallback providers are updated\n    event FallbackProvidersUpdated(\n        DataTypes.Provider oldFallbackProviderA,\n        DataTypes.Provider newFallbackProviderA,\n        DataTypes.Provider oldFallbackProviderB,\n        DataTypes.Provider newFallbackProviderB\n    );\n\n    constructor(\n        uint256 maxDeviation_,\n        uint256 stalePeriod_,\n        DataTypes.Provider fallbackProviderA_,\n        DataTypes.Provider fallbackProviderB_\n    ) UsingMaxDeviation(maxDeviation_) UsingStalePeriod(stalePeriod_) {\n        require(fallbackProviderA_ != DataTypes.Provider.NONE, \"fallback-provider-not-set\");\n        fallbackProviderA = fallbackProviderA_;\n        fallbackProviderB = fallbackProviderB_;\n    }\n\n    /// @inheritdoc IOracle\n    function getPriceInUsd(address _asset) public view virtual returns (uint256 _priceInUsd) {\n        // 1. Get price from chainlink\n        uint256 _lastUpdatedAt;\n        (_priceInUsd, _lastUpdatedAt) = _getPriceInUsd(DataTypes.Provider.CHAINLINK, _asset);\n        uint256 _stalePeriod = stalePeriodOf(_asset);\n\n        // 2. If price from chainlink is OK return it\n        if (_priceInUsd > 0 && !_priceIsStale(_lastUpdatedAt, _stalePeriod)) {\n            return _priceInUsd;\n        }\n\n        // 3. Get price from fallback A\n        (uint256 _amountOutA, uint256 _lastUpdatedAtA) = _getPriceInUsd(fallbackProviderA, _asset);\n\n        // 4. If price from fallback A is OK and there isn't a fallback B, return price from fallback A\n        bool _aPriceOK = _amountOutA > 0 && !_priceIsStale(_lastUpdatedAtA, _stalePeriod);\n        if (fallbackProviderB == DataTypes.Provider.NONE) {\n            require(_aPriceOK, \"fallback-a-failed\");\n            return _amountOutA;\n        }\n\n        // 5. Get price from fallback B\n        (uint256 _amountOutB, uint256 _lastUpdatedAtB) = _getPriceInUsd(fallbackProviderB, _asset);\n\n        // 6. If only one price from fallbacks is valid, return it\n        bool _bPriceOK = _amountOutB > 0 && !_priceIsStale(_lastUpdatedAtB, _stalePeriod);\n        if (!_bPriceOK && _aPriceOK) {\n            return _amountOutA;\n        } else if (_bPriceOK && !_aPriceOK) {\n            return _amountOutB;\n        }\n\n        // 7. Check fallback prices deviation\n        require(_aPriceOK && _bPriceOK, \"fallbacks-failed\");\n        require(_isDeviationOK(_amountOutA, _amountOutB), \"prices-deviation-too-high\");\n\n        // 8. If deviation is OK, return price from fallback A\n        return _amountOutA;\n    }\n\n    /// @inheritdoc IOracle\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) public view virtual returns (uint256 _amountOut) {\n        // 1. Get price from chainlink\n        uint256 _tokenInLastUpdatedAt;\n        uint256 _tokenOutLastUpdatedAt;\n        (_amountOut, _tokenInLastUpdatedAt, _tokenOutLastUpdatedAt) = _quote(\n            DataTypes.Provider.CHAINLINK,\n            tokenIn_,\n            tokenOut_,\n            amountIn_\n        );\n\n        // 2. If price from chainlink is OK return it\n        if (\n            _amountOut > 0 &&\n            !_priceIsStale(tokenIn_, _tokenInLastUpdatedAt) &&\n            !_priceIsStale(tokenOut_, _tokenOutLastUpdatedAt)\n        ) {\n            return _amountOut;\n        }\n\n        // 3. Get price from fallback A\n        (uint256 _amountOutA, uint256 _tokenInLastUpdatedAtA, uint256 _tokenOutLastUpdatedAtA) = _quote(\n            fallbackProviderA,\n            tokenIn_,\n            tokenOut_,\n            amountIn_\n        );\n\n        // 4. If price from fallback A is OK and there isn't a fallback B, return price from fallback A\n        bool _aPriceOK = _amountOutA > 0 &&\n            !_priceIsStale(tokenIn_, _tokenInLastUpdatedAtA) &&\n            !_priceIsStale(tokenOut_, _tokenOutLastUpdatedAtA);\n        if (fallbackProviderB == DataTypes.Provider.NONE) {\n            require(_aPriceOK, \"fallback-a-failed\");\n            return _amountOutA;\n        }\n\n        // 5. Get price from fallback B\n        (uint256 _amountOutB, uint256 _tokenInLastUpdatedAtB, uint256 _tokenOutLastUpdatedAtB) = _quote(\n            fallbackProviderB,\n            tokenIn_,\n            tokenOut_,\n            amountIn_\n        );\n\n        // 6. If only one price from fallbacks is valid, return it\n        bool _bPriceOK = _amountOutB > 0 &&\n            !_priceIsStale(tokenIn_, _tokenInLastUpdatedAtB) &&\n            !_priceIsStale(tokenOut_, _tokenOutLastUpdatedAtB);\n        if (!_bPriceOK && _aPriceOK) {\n            return _amountOutA;\n        } else if (_bPriceOK && !_aPriceOK) {\n            return _amountOutB;\n        }\n\n        // 7. Check fallback prices deviation\n        require(_aPriceOK && _bPriceOK, \"fallbacks-failed\");\n        require(_isDeviationOK(_amountOutA, _amountOutB), \"prices-deviation-too-high\");\n\n        // 8. If deviation is OK, return price from fallback A\n        return _amountOutA;\n    }\n\n    /// @inheritdoc IOracle\n    function quoteTokenToUsd(address token_, uint256 amountIn_) public view virtual returns (uint256 _amountOut) {\n        // 1. Get price from chainlink\n        uint256 _lastUpdatedAt;\n        (_amountOut, _lastUpdatedAt) = _quoteTokenToUsd(DataTypes.Provider.CHAINLINK, token_, amountIn_);\n        uint256 _stalePeriod = stalePeriodOf(token_);\n\n        // 2. If price from chainlink is OK return it\n        if (_amountOut > 0 && !_priceIsStale(_lastUpdatedAt, _stalePeriod)) {\n            return _amountOut;\n        }\n\n        // 3. Get price from fallback A\n        (uint256 _amountOutA, uint256 _lastUpdatedAtA) = _quoteTokenToUsd(fallbackProviderA, token_, amountIn_);\n\n        // 4. If price from fallback A is OK and there isn't a fallback B, return price from fallback A\n        bool _aPriceOK = _amountOutA > 0 && !_priceIsStale(_lastUpdatedAtA, _stalePeriod);\n        if (fallbackProviderB == DataTypes.Provider.NONE) {\n            require(_aPriceOK, \"fallback-a-failed\");\n            return _amountOutA;\n        }\n\n        // 5. Get price from fallback B\n        (uint256 _amountOutB, uint256 _lastUpdatedAtB) = _quoteTokenToUsd(fallbackProviderB, token_, amountIn_);\n\n        // 6. If only one price from fallbacks is valid, return it\n        bool _bPriceOK = _amountOutB > 0 && !_priceIsStale(_lastUpdatedAtB, _stalePeriod);\n        if (!_bPriceOK && _aPriceOK) {\n            return _amountOutA;\n        } else if (_bPriceOK && !_aPriceOK) {\n            return _amountOutB;\n        }\n\n        // 7. Check fallback prices deviation\n        require(_aPriceOK && _bPriceOK, \"fallbacks-failed\");\n        require(_isDeviationOK(_amountOutA, _amountOutB), \"prices-deviation-too-high\");\n\n        // 8. If deviation is OK, return price from fallback A\n        return _amountOutA;\n    }\n\n    /// @inheritdoc IOracle\n    function quoteUsdToToken(address token_, uint256 amountIn_) public view virtual returns (uint256 _amountOut) {\n        // 1. Get price from chainlink\n        uint256 _lastUpdatedAt;\n        (_amountOut, _lastUpdatedAt) = _quoteUsdToToken(DataTypes.Provider.CHAINLINK, token_, amountIn_);\n        uint256 _stalePeriod = stalePeriodOf(token_);\n\n        // 2. If price from chainlink is OK return it\n        if (_amountOut > 0 && !_priceIsStale(_lastUpdatedAt, _stalePeriod)) {\n            return _amountOut;\n        }\n\n        // 3. Get price from fallback A\n        (uint256 _amountOutA, uint256 _lastUpdatedAtA) = _quoteUsdToToken(fallbackProviderA, token_, amountIn_);\n\n        // 4. If price from fallback A is OK and there isn't a fallback B, return price from fallback A\n        bool _aPriceOK = _amountOutA > 0 && !_priceIsStale(_lastUpdatedAtA, _stalePeriod);\n        if (fallbackProviderB == DataTypes.Provider.NONE) {\n            require(_aPriceOK, \"fallback-a-failed\");\n            return _amountOutA;\n        }\n\n        // 5. Get price from fallback B\n        (uint256 _amountOutB, uint256 _lastUpdatedAtB) = _quoteUsdToToken(fallbackProviderB, token_, amountIn_);\n\n        // 6. If only one price from fallbacks is valid, return it\n        bool _bPriceOK = _amountOutB > 0 && !_priceIsStale(_lastUpdatedAtB, _stalePeriod);\n        if (!_bPriceOK && _aPriceOK) {\n            return _amountOutA;\n        } else if (_bPriceOK && !_aPriceOK) {\n            return _amountOutB;\n        }\n\n        // 7. Check fallback prices deviation\n        require(_aPriceOK && _bPriceOK, \"fallbacks-failed\");\n        require(_isDeviationOK(_amountOutA, _amountOutB), \"prices-deviation-too-high\");\n\n        // 8. If deviation is OK, return price from fallback A\n        return _amountOutA;\n    }\n\n    /**\n     * @notice Wrapped `getPriceInUsd` function\n     * @dev Return [0,0] (i.e. invalid quote) if the call reverts\n     */\n    function _getPriceInUsd(DataTypes.Provider provider_, address token_)\n        private\n        view\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        try addressProvider.providersAggregator().getPriceInUsd(provider_, token_) returns (\n            uint256 __priceInUsd,\n            uint256 __lastUpdatedAt\n        ) {\n            _priceInUsd = __priceInUsd;\n            _lastUpdatedAt = __lastUpdatedAt;\n        } catch {}\n    }\n\n    /**\n     * @notice Wrapped providers aggregator's `quote` function\n     * @dev Return [0,0] (i.e. invalid quote) if the call reverts\n     */\n    function _quote(\n        DataTypes.Provider provider_,\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        private\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        try addressProvider.providersAggregator().quote(provider_, tokenIn_, tokenOut_, amountIn_) returns (\n            uint256 __amountOut,\n            uint256 __tokenInLastUpdatedAt,\n            uint256 __tokenOutLastUpdatedAt\n        ) {\n            _amountOut = __amountOut;\n\n            _tokenInLastUpdatedAt = __tokenInLastUpdatedAt;\n            _tokenOutLastUpdatedAt = __tokenOutLastUpdatedAt;\n        } catch {}\n    }\n\n    /**\n     * @notice Wrapped providers aggregator's `quoteTokenToUsd` function\n     * @dev Return [0,0] (i.e. invalid quote) if the call reverts\n     */\n    function _quoteTokenToUsd(\n        DataTypes.Provider provider_,\n        address token_,\n        uint256 amountIn_\n    ) private view returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        try addressProvider.providersAggregator().quoteTokenToUsd(provider_, token_, amountIn_) returns (\n            uint256 __amountOut,\n            uint256 __lastUpdatedAt\n        ) {\n            _amountOut = __amountOut;\n            _lastUpdatedAt = __lastUpdatedAt;\n        } catch {}\n    }\n\n    /**\n     * @notice Wrapped providers aggregator's `quoteUsdToToken` function\n     * @dev Return [0,0] (i.e. invalid quote) if the call reverts\n     */\n    function _quoteUsdToToken(\n        DataTypes.Provider provider_,\n        address token_,\n        uint256 amountIn_\n    ) private view returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        try addressProvider.providersAggregator().quoteUsdToToken(provider_, token_, amountIn_) returns (\n            uint256 __amountOut,\n            uint256 __lastUpdatedAt\n        ) {\n            _amountOut = __amountOut;\n            _lastUpdatedAt = __lastUpdatedAt;\n        } catch {}\n    }\n\n    /**\n     * @notice Update fallback providers\n     * @dev The fallback provider B is optional\n     */\n    function updateFallbackProviders(DataTypes.Provider fallbackProviderA_, DataTypes.Provider fallbackProviderB_)\n        external\n        onlyGovernor\n    {\n        require(fallbackProviderA_ != DataTypes.Provider.NONE, \"fallback-a-is-null\");\n        emit FallbackProvidersUpdated(fallbackProviderA, fallbackProviderA_, fallbackProviderB, fallbackProviderB_);\n        fallbackProviderA = fallbackProviderA_;\n        fallbackProviderB = fallbackProviderB_;\n    }\n}\n"
    },
    "contracts/periphery/ChainlinkOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../interfaces/periphery/IOracle.sol\";\nimport \"../features/UsingStalePeriod.sol\";\n\n/**\n * @title Chainlink oracle\n */\ncontract ChainlinkOracle is IOracle, UsingStalePeriod {\n    constructor(uint256 stalePeriod_) UsingStalePeriod(stalePeriod_) {}\n\n    /// @inheritdoc IOracle\n    function getPriceInUsd(address token_) public view virtual returns (uint256 _priceInUsd) {\n        uint256 _lastUpdatedAt;\n        (_priceInUsd, _lastUpdatedAt) = addressProvider.providersAggregator().getPriceInUsd(\n            DataTypes.Provider.CHAINLINK,\n            token_\n        );\n        require(_priceInUsd > 0 && !_priceIsStale(token_, _lastUpdatedAt), \"price-invalid\");\n    }\n\n    /// @inheritdoc IOracle\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) public view virtual returns (uint256 _amountOut) {\n        uint256 _tokenInLastUpdatedAt;\n        uint256 _tokenOutLastUpdatedAt;\n        (_amountOut, _tokenInLastUpdatedAt, _tokenOutLastUpdatedAt) = addressProvider.providersAggregator().quote(\n            DataTypes.Provider.CHAINLINK,\n            tokenIn_,\n            tokenOut_,\n            amountIn_\n        );\n\n        require(\n            _amountOut > 0 &&\n                !_priceIsStale(tokenIn_, _tokenInLastUpdatedAt) &&\n                !_priceIsStale(tokenOut_, _tokenOutLastUpdatedAt),\n            \"price-invalid\"\n        );\n    }\n\n    /// @inheritdoc IOracle\n    function quoteTokenToUsd(address token_, uint256 amountIn_) public view virtual returns (uint256 _amountOut) {\n        uint256 _lastUpdatedAt;\n        (_amountOut, _lastUpdatedAt) = addressProvider.providersAggregator().quoteTokenToUsd(\n            DataTypes.Provider.CHAINLINK,\n            token_,\n            amountIn_\n        );\n        require(_amountOut > 0 && !_priceIsStale(token_, _lastUpdatedAt), \"price-invalid\");\n    }\n\n    /// @inheritdoc IOracle\n    function quoteUsdToToken(address token_, uint256 amountIn_) public view virtual returns (uint256 _amountOut) {\n        uint256 _lastUpdatedAt;\n        (_amountOut, _lastUpdatedAt) = addressProvider.providersAggregator().quoteUsdToToken(\n            DataTypes.Provider.CHAINLINK,\n            token_,\n            amountIn_\n        );\n        require(_amountOut > 0 && !_priceIsStale(token_, _lastUpdatedAt), \"price-invalid\");\n    }\n}\n"
    },
    "contracts/periphery/MainAndFallbackOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IOracle} from \"../interfaces/periphery/IOracle.sol\";\nimport {IPriceProvider} from \"../interfaces/core/IPriceProvider.sol\";\nimport {UsingStalePeriod} from \"../features/UsingStalePeriod.sol\";\n\n/**\n * @title Main and Fallback oracle\n * @dev Uses a primary oracle, if it doesn't support the asset, or price is staled, try getting price from the fallback.\n */\ncontract MainAndFallbackOracle is IOracle, UsingStalePeriod {\n    IPriceProvider public immutable mainProvider;\n    IPriceProvider public immutable fallbackProvider;\n\n    constructor(\n        IPriceProvider mainProvider_,\n        IPriceProvider fallbackProvider_,\n        uint256 stalePeriod_\n    ) UsingStalePeriod(stalePeriod_) {\n        require(address(mainProvider_) != address(0), \"main-is-null\");\n        require(address(fallbackProvider_) != address(0), \"fallback-is-null\");\n        mainProvider = mainProvider_;\n        fallbackProvider = fallbackProvider_;\n    }\n\n    /// @inheritdoc IOracle\n    function getPriceInUsd(address _asset) public view virtual returns (uint256) {\n        uint256 _stalePeriod = stalePeriodOf(_asset);\n\n        // 1. Check main provider\n        (uint256 _priceInUsd, uint256 _lastUpdatedAt) = mainProvider.getPriceInUsd(_asset);\n\n        if (_priceInUsd > 0 && !_priceIsStale(_lastUpdatedAt, _stalePeriod)) {\n            return _priceInUsd;\n        }\n\n        // 2. Check fallback provider\n        (_priceInUsd, _lastUpdatedAt) = fallbackProvider.getPriceInUsd(_asset);\n\n        if (_priceInUsd > 0 && !_priceIsStale(_lastUpdatedAt, _stalePeriod)) {\n            return _priceInUsd;\n        }\n\n        revert(\"both-providers-failed\");\n    }\n\n    /// @inheritdoc IOracle\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) public view virtual returns (uint256 _amountOut) {\n        _amountOut = quoteUsdToToken({token_: tokenOut_, amountIn_: quoteTokenToUsd(tokenIn_, amountIn_)});\n    }\n\n    /// @inheritdoc IOracle\n    function quoteTokenToUsd(address token_, uint256 amountIn_) public view virtual returns (uint256) {\n        uint256 _stalePeriod = stalePeriodOf(token_);\n\n        // 1. Check main provider\n        (uint256 _amountOut, uint256 _lastUpdatedAt) = mainProvider.quoteTokenToUsd(token_, amountIn_);\n\n        if (_amountOut > 0 && !_priceIsStale(_lastUpdatedAt, _stalePeriod)) {\n            return _amountOut;\n        }\n\n        // 2. Check fallback provider\n        (_amountOut, _lastUpdatedAt) = fallbackProvider.quoteTokenToUsd(token_, amountIn_);\n\n        if (_amountOut > 0 && !_priceIsStale(_lastUpdatedAt, _stalePeriod)) {\n            return _amountOut;\n        }\n\n        revert(\"both-providers-failed\");\n    }\n\n    /// @inheritdoc IOracle\n    function quoteUsdToToken(address token_, uint256 amountIn_) public view virtual returns (uint256) {\n        uint256 _stalePeriod = stalePeriodOf(token_);\n\n        // 1. Check main provider\n        (uint256 _amountOut, uint256 _lastUpdatedAt) = mainProvider.quoteUsdToToken(token_, amountIn_);\n\n        if (_amountOut > 0 && !_priceIsStale(_lastUpdatedAt, _stalePeriod)) {\n            return _amountOut;\n        }\n\n        // 2. Check fallback provider\n        (_amountOut, _lastUpdatedAt) = fallbackProvider.quoteUsdToToken(token_, amountIn_);\n\n        if (_amountOut > 0 && !_priceIsStale(_lastUpdatedAt, _stalePeriod)) {\n            return _amountOut;\n        }\n\n        revert(\"both-providers-failed\");\n    }\n}\n"
    },
    "contracts/periphery/MainOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IOracle} from \"../interfaces/periphery/IOracle.sol\";\nimport {IPriceProvider} from \"../interfaces/core/IPriceProvider.sol\";\nimport {UsingStalePeriod} from \"../features/UsingStalePeriod.sol\";\n\n/**\n * @title Main oracle\n * @dev In most cases this will wrap the Chainlink price provider\n */\ncontract MainOracle is IOracle, UsingStalePeriod {\n    IPriceProvider public immutable provider;\n\n    constructor(IPriceProvider provider_, uint256 stalePeriod_) UsingStalePeriod(stalePeriod_) {\n        provider = provider_;\n    }\n\n    /// @inheritdoc IOracle\n    function getPriceInUsd(address token_) public view virtual returns (uint256 _priceInUsd) {\n        uint256 _lastUpdatedAt;\n        (_priceInUsd, _lastUpdatedAt) = provider.getPriceInUsd(token_);\n        require(_priceInUsd > 0 && !_priceIsStale(token_, _lastUpdatedAt), \"price-invalid\");\n    }\n\n    /// @inheritdoc IOracle\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) public view virtual returns (uint256 _amountOut) {\n        uint256 _tokenInLastUpdatedAt;\n        uint256 _tokenOutLastUpdatedAt;\n        (_amountOut, _tokenInLastUpdatedAt, _tokenOutLastUpdatedAt) = provider.quote(tokenIn_, tokenOut_, amountIn_);\n\n        require(\n            _amountOut > 0 &&\n                !_priceIsStale(tokenIn_, _tokenInLastUpdatedAt) &&\n                !_priceIsStale(tokenOut_, _tokenOutLastUpdatedAt),\n            \"price-invalid\"\n        );\n    }\n\n    /// @inheritdoc IOracle\n    function quoteTokenToUsd(address token_, uint256 amountIn_) public view virtual returns (uint256 _amountOut) {\n        uint256 _lastUpdatedAt;\n        (_amountOut, _lastUpdatedAt) = provider.quoteTokenToUsd(token_, amountIn_);\n        require(_amountOut > 0 && !_priceIsStale(token_, _lastUpdatedAt), \"price-invalid\");\n    }\n\n    /// @inheritdoc IOracle\n    function quoteUsdToToken(address token_, uint256 amountIn_) public view virtual returns (uint256 _amountOut) {\n        uint256 _lastUpdatedAt;\n        (_amountOut, _lastUpdatedAt) = provider.quoteUsdToToken(token_, amountIn_);\n        require(_amountOut > 0 && !_priceIsStale(token_, _lastUpdatedAt), \"price-invalid\");\n    }\n}\n"
    },
    "contracts/periphery/MasterOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../interfaces/periphery/IOracle.sol\";\nimport \"../access/Governable.sol\";\n\n/**\n * @title MasterOracle\n */\ncontract MasterOracle is IOracle, Governable {\n    /**\n     * @notice Default oracle to use when token hasn't custom oracle\n     */\n    IOracle public defaultOracle;\n\n    /**\n     * @notice Custom tokens' oracles\n     * @dev Useful when dealing with special tokens (e.g. LP, IB, etc)\n     */\n    mapping(address => IOracle) public oracles;\n\n    /// @notice Emitted when a token's oracle is set\n    event TokenOracleUpdated(address indexed token, IOracle indexed oracle);\n\n    /// @notice Emitted when the default oracle is updated\n    event DefaultOracleUpdated(IOracle indexed defaultOracle);\n\n    constructor(IOracle defaultOracle_) {\n        defaultOracle = defaultOracle_;\n    }\n\n    /// @inheritdoc IOracle\n    function getPriceInUsd(address token_) public view override returns (uint256 _priceInUsd) {\n        IOracle _oracle = oracles[token_];\n\n        if (address(_oracle) != address(0)) {\n            _priceInUsd = _oracle.getPriceInUsd(token_);\n        } else if (address(defaultOracle) != address(0)) {\n            _priceInUsd = defaultOracle.getPriceInUsd(token_);\n        } else {\n            revert(\"token-without-oracle\");\n        }\n\n        require(_priceInUsd > 0, \"invalid-token-price\");\n    }\n\n    /// @inheritdoc IOracle\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external view virtual override returns (uint256 _amountOut) {\n        _amountOut = quoteUsdToToken(tokenOut_, quoteTokenToUsd(tokenIn_, amountIn_));\n    }\n\n    /// @inheritdoc IOracle\n    function quoteTokenToUsd(address token_, uint256 amountIn_) public view override returns (uint256 _amountOut) {\n        _amountOut = (amountIn_ * getPriceInUsd(token_)) / 10**IERC20Metadata(token_).decimals();\n    }\n\n    /// @inheritdoc IOracle\n    function quoteUsdToToken(address token_, uint256 amountIn_) public view override returns (uint256 _amountOut) {\n        _amountOut = (amountIn_ * 10**IERC20Metadata(token_).decimals()) / getPriceInUsd(token_);\n    }\n\n    /// @notice Set custom oracle for a token\n    function _updateTokenOracle(address token_, IOracle oracle_) private {\n        oracles[token_] = oracle_;\n        emit TokenOracleUpdated(token_, oracle_);\n    }\n\n    /// @notice Update the default oracle\n    function updateDefaultOracle(IOracle defaultOracle_) external onlyGovernor {\n        defaultOracle = defaultOracle_;\n        emit DefaultOracleUpdated(defaultOracle_);\n    }\n\n    /// @notice Set custom oracle for a token\n    function updateTokenOracle(address token_, IOracle oracle_) external onlyGovernor {\n        _updateTokenOracle(token_, oracle_);\n    }\n\n    /**\n     * @notice Set custom oracles for a set of tokens\n     * @dev We allow null address inside of the `oracles_` array in order to turn off oracle for a given asset\n     */\n    function updateTokenOracles(address[] calldata tokens_, IOracle[] calldata oracles_) external onlyGovernor {\n        uint256 _tokensLength = tokens_.length;\n        require(_tokensLength > 0 && _tokensLength == oracles_.length, \"invalid-arrays-length\");\n\n        for (uint256 i; i < _tokensLength; ++i) {\n            address _token = tokens_[i];\n            require(_token != address(0), \"a-token-has-null-address\");\n            _updateTokenOracle(_token, oracles_[i]);\n        }\n    }\n}\n"
    },
    "contracts/periphery/PullOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IOracle} from \"../interfaces/periphery/IOracle.sol\";\nimport {IPriceProvider} from \"../interfaces/core/IPriceProvider.sol\";\n\n/**\n * @title Pull oracle\n * @dev This is the same as `MainOracle` but without stale period check because pull-oracle providers already do that\n */\ncontract PullOracle is IOracle {\n    IPriceProvider public immutable provider;\n\n    constructor(IPriceProvider provider_) {\n        provider = provider_;\n    }\n\n    /// @inheritdoc IOracle\n    function getPriceInUsd(address token_) public view virtual returns (uint256 _priceInUsd) {\n        (_priceInUsd, ) = provider.getPriceInUsd(token_);\n    }\n\n    /// @inheritdoc IOracle\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) public view virtual returns (uint256 _amountOut) {\n        (_amountOut, , ) = provider.quote(tokenIn_, tokenOut_, amountIn_);\n    }\n\n    /// @inheritdoc IOracle\n    function quoteTokenToUsd(address token_, uint256 amountIn_) public view virtual returns (uint256 _amountOut) {\n        (_amountOut, ) = provider.quoteTokenToUsd(token_, amountIn_);\n    }\n\n    /// @inheritdoc IOracle\n    function quoteUsdToToken(address token_, uint256 amountIn_) public view virtual returns (uint256 _amountOut) {\n        (_amountOut, ) = provider.quoteUsdToToken(token_, amountIn_);\n    }\n}\n"
    },
    "contracts/periphery/tokens/AlusdTokenMainnetOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../../features/UsingMaxDeviation.sol\";\nimport \"../../features/UsingStalePeriod.sol\";\nimport \"../../interfaces/periphery/IUpdatableOracle.sol\";\nimport \"../../interfaces/core/IUniswapV2LikePriceProvider.sol\";\n\n/**\n * @title alUSD Oracle (mainnet-only)\n */\ncontract AlusdTokenMainnetOracle is IUpdatableOracle, UsingStalePeriod {\n    uint256 public constant ONE_ALUSD = 1e18;\n    address public constant ALUSD_ADDRESS = 0xBC6DA0FE9aD5f3b0d58160288917AA56653660E9;\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    constructor(uint256 stalePeriod_) UsingStalePeriod(stalePeriod_) {}\n\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address _asset) external view returns (uint256 _priceInUsd) {\n        require(address(_asset) == ALUSD_ADDRESS, \"invalid-token\");\n\n        uint256 _lastUpdatedAt;\n        (_priceInUsd, _lastUpdatedAt) = addressProvider.providersAggregator().quoteTokenToUsd(\n            DataTypes.Provider.SUSHISWAP,\n            ALUSD_ADDRESS,\n            ONE_ALUSD\n        );\n\n        require(_priceInUsd > 0 && !_priceIsStale(_lastUpdatedAt, defaultStalePeriod), \"price-invalid\");\n    }\n\n    /// @inheritdoc IUpdatableOracle\n    function update() external override {\n        IAddressProvider _addressProvider = addressProvider;\n        IUniswapV2LikePriceProvider _sushiswap = IUniswapV2LikePriceProvider(\n            address(_addressProvider.providersAggregator().priceProviders(DataTypes.Provider.SUSHISWAP))\n        );\n        _sushiswap.updateOrAdd(ALUSD_ADDRESS, WETH_ADDRESS);\n        _sushiswap.updateOrAdd(WETH_ADDRESS, _addressProvider.stableCoinProvider().getStableCoinIfPegged());\n    }\n}\n"
    },
    "contracts/periphery/tokens/ATokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../interfaces/external/aave/IAToken.sol\";\nimport \"../../interfaces/periphery/IOracle.sol\";\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\n\n/**\n * @title Oracle for `ATokens`\n */\ncontract ATokenOracle is ITokenOracle {\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address _asset) external view returns (uint256 _priceInUsd) {\n        // Note: `msg.sender` is the `MasterOracle` contract\n        return IOracle(msg.sender).getPriceInUsd(IAToken(_asset).UNDERLYING_ASSET_ADDRESS());\n    }\n}\n"
    },
    "contracts/periphery/tokens/BTCPeggedTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\nimport \"../../features/UsingStalePeriod.sol\";\n\n/**\n * @title Oracle for BTC-pegged tokens that uses Chainlink's BTC/USD feed\n */\ncontract BTCPeggedTokenOracle is ITokenOracle, UsingStalePeriod {\n    using SafeCast for int256;\n\n    /// @notice Chainlink BTC/USD aggregator\n    AggregatorV3Interface public immutable btcAggregator;\n\n    constructor(AggregatorV3Interface btcAggregator_, uint256 stalePeriod_) UsingStalePeriod(stalePeriod_) {\n        btcAggregator = btcAggregator_;\n    }\n\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address) external view override returns (uint256 _priceInUsd) {\n        (, int256 _price, , uint256 _lastUpdatedAt, ) = btcAggregator.latestRoundData();\n        require(!_priceIsStale(_lastUpdatedAt, defaultStalePeriod), \"stale-price\");\n        return _price.toUint256() * 1e10; // To 18 decimals\n    }\n}\n"
    },
    "contracts/periphery/tokens/ChainlinkEthOnlyTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"../../interfaces/periphery/IOracle.sol\";\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\nimport \"../../features/UsingStalePeriod.sol\";\n\n/**\n * @title Chainlink Oracle for token with ETH-only price feed\n */\ncontract ChainlinkEthOnlyTokenOracle is ITokenOracle, UsingStalePeriod {\n    using SafeCast for int256;\n\n    address public immutable WETH;\n\n    mapping(address => AggregatorV3Interface) public ethFeedOf;\n\n    event EthFeedUpdated(address indexed token, AggregatorV3Interface ethFeed);\n\n    constructor(address weth_) UsingStalePeriod(24 hours) {\n        WETH = weth_;\n    }\n\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address token_) external view override returns (uint256 _priceInUsd) {\n        // TOKEN/ETH price from Chainlink\n        (, int256 _price, , uint256 _lastUpdatedAt, ) = ethFeedOf[token_].latestRoundData();\n        require(_price > 0 && !_priceIsStale(token_, _lastUpdatedAt), \"price-invalid\");\n        uint256 _priceInEth = _price.toUint256();\n\n        // ETH/USD price from Chainlink\n        uint256 _ethPriceInUsd = IOracle(msg.sender).getPriceInUsd(WETH);\n\n        // TOKEN/USD price\n        return (_priceInEth * _ethPriceInUsd) / (1e18);\n    }\n\n    /**\n     * @notice Update default stale period\n     */\n    function updateEthFeed(address token_, AggregatorV3Interface ethFeed_) external onlyGovernor {\n        emit EthFeedUpdated(token_, ethFeed_);\n        ethFeedOf[token_] = ethFeed_;\n    }\n}\n"
    },
    "contracts/periphery/tokens/CTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../interfaces/external/compound/ICToken.sol\";\nimport \"../../interfaces/periphery/IOracle.sol\";\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\n\n/**\n * @title Oracle for `CTokens`\n */\ncontract CTokenOracle is ITokenOracle {\n    uint256 public constant ONE_CTOKEN = 1e8;\n\n    /**\n     * @notice The address of the `CEther` underlying (Usually WETH)\n     */\n    address public immutable wethLike;\n\n    constructor(address _wethLike) {\n        require(_wethLike != address(0), \"weth-like-null\");\n        wethLike = _wethLike;\n    }\n\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address _asset) external view returns (uint256 _priceInUsd) {\n        address _underlyingAddress;\n        // Note: Compound's `CEther` hasn't the `underlying()` function, forks may return `address(0)` (e.g. RariFuse)\n        try ICToken(_asset).underlying() returns (address _underlying) {\n            _underlyingAddress = _underlying;\n        } catch {}\n\n        if (_underlyingAddress == address(0)) {\n            _underlyingAddress = wethLike;\n        }\n        uint256 _underlyingPriceInUsd = IOracle(msg.sender).getPriceInUsd(_underlyingAddress);\n        uint256 _underlyingAmount = (ONE_CTOKEN * ICToken(_asset).exchangeRateStored()) / 1e18;\n        _priceInUsd = (_underlyingPriceInUsd * _underlyingAmount) / 10**IERC20Metadata(_underlyingAddress).decimals();\n    }\n}\n"
    },
    "contracts/periphery/tokens/CurveFactoryLpTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\nimport \"../../interfaces/external/curve/ICurveAddressProvider.sol\";\nimport \"../../interfaces/external/curve/ICurveFactoryRegistry.sol\";\nimport \"../../interfaces/external/curve/ICurvePool.sol\";\nimport \"../../interfaces/periphery/IOracle.sol\";\n\n/**\n * @title Oracle for Curve LP tokens (Factory Pools)\n */\ncontract CurveFactoryLpTokenOracle is ITokenOracle {\n    /// @dev Same address for all chains\n    ICurveAddressProvider public constant addressProvider =\n        ICurveAddressProvider(0x0000000022D53366457F9d5E68Ec105046FC4383);\n\n    /// @notice Factory Registry contract\n    ICurveFactoryRegistry public immutable registry;\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    address private immutable weth;\n\n    /// @notice LP token => coins mapping\n    mapping(address => address[]) public underlyingTokens;\n\n    /// @notice Emitted when a token is registered\n    event LpRegistered(address indexed lpToken);\n\n    constructor(address weth_) {\n        require(weth_ != address(0), \"null-weth\");\n        weth = weth_;\n        registry = ICurveFactoryRegistry(addressProvider.get_address(3));\n    }\n\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address lpToken_) public view override returns (uint256 _priceInUsd) {\n        address[] memory _tokens = underlyingTokens[lpToken_];\n        require(_tokens.length > 0, \"lp-is-not-registered\");\n        uint256 _min = type(uint256).max;\n        uint256 _n = _tokens.length;\n\n        for (uint256 i; i < _n; i++) {\n            uint256 _price = IOracle(msg.sender).getPriceInUsd(_tokens[i]);\n            if (_price < _min) _min = _price;\n        }\n\n        require(_min < type(uint256).max, \"no-min-underlying-price-found\");\n        require(_min > 0, \"invalid-min-price\");\n\n        return (_min * ICurvePool(lpToken_).get_virtual_price()) / 1e18;\n    }\n\n    /// @notice Check if a token is already registered\n    function isLpRegistered(address lpToken_) public view returns (bool) {\n        return underlyingTokens[lpToken_].length > 0;\n    }\n\n    /// @notice Register LP token data\n    /// @dev For factory pools, the LP and pool addresses are the same\n    function registerLp(address lpToken_) external {\n        require(!isLpRegistered(lpToken_), \"lp-already-registered\");\n\n        uint256 _n = registry.get_n_coins(lpToken_);\n        if (_n == 0) (_n, ) = registry.get_meta_n_coins(lpToken_);\n        require(_n > 0, \"invalid-factory-lp-token\");\n\n        address[4] memory _tokens = registry.get_coins(lpToken_);\n        for (uint256 i; i < _n; i++) {\n            if (_tokens[i] == ETH) {\n                underlyingTokens[lpToken_].push(weth);\n            } else {\n                underlyingTokens[lpToken_].push(_tokens[i]);\n            }\n        }\n\n        emit LpRegistered(lpToken_);\n    }\n}\n"
    },
    "contracts/periphery/tokens/CurveLpTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\nimport \"../../interfaces/external/curve/ICurveAddressProvider.sol\";\nimport \"../../interfaces/external/curve/ICurveRegistry.sol\";\nimport \"../../interfaces/external/curve/ICurvePool.sol\";\nimport \"../../interfaces/periphery/IOracle.sol\";\nimport \"../../access/Governable.sol\";\n\n/**\n * @title Oracle for Curve LP tokens\n */\ncontract CurveLpTokenOracle is ITokenOracle, Governable {\n    ICurveAddressProvider public immutable curveAddressProvider;\n\n    /// @notice Registry contract\n    address public immutable registry;\n\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    address internal immutable weth;\n\n    /// @notice LP token => coins mapping\n    mapping(address => address[]) public underlyingTokens;\n\n    /// @notice LP token => pool\n    mapping(address => address) public poolOf;\n\n    /// @notice Emitted when a token is registered\n    event LpRegistered(address indexed lpToken, bool isLending);\n\n    constructor(ICurveAddressProvider curveAddressProvider_, address weth_) {\n        require(address(curveAddressProvider_) != address(0), \"null-address-provider\");\n        require(weth_ != address(0), \"null-weth\");\n        curveAddressProvider = curveAddressProvider_;\n        registry = curveAddressProvider.get_registry();\n        weth = weth_;\n    }\n\n    /// @inheritdoc ITokenOracle\n    /// @dev This function is supposed to be called from `MasterOracle` only\n    function getPriceInUsd(address lpToken_) public view override returns (uint256 _priceInUsd) {\n        address _pool = poolOf[lpToken_];\n        require(_pool != address(0), \"lp-is-not-registered\");\n        address[] memory _tokens = underlyingTokens[lpToken_];\n        uint256 _min = type(uint256).max;\n        uint256 _n = _tokens.length;\n\n        for (uint256 i; i < _n; i++) {\n            // Note: `msg.sender` is the `MasterOracle` contract\n            uint256 _price = IOracle(msg.sender).getPriceInUsd(_tokens[i]);\n            if (_price < _min) _min = _price;\n        }\n\n        require(_min < type(uint256).max, \"no-min-underlying-price-found\");\n        require(_min > 0, \"invalid-min-price\");\n\n        return (_min * ICurvePool(_pool).get_virtual_price()) / 1e18;\n    }\n\n    /// @notice Check if a token is already registered\n    function isLpRegistered(address lpToken_) public view returns (bool) {\n        return underlyingTokens[lpToken_].length > 0;\n    }\n\n    /// @notice Register LP token data\n    function registerLp(address lpToken_) external onlyGovernor {\n        _registerLp(lpToken_, false);\n    }\n\n    /// @notice Register LP token data\n    function registerLendingLp(address lpToken_) external onlyGovernor {\n        _registerLp(lpToken_, true);\n    }\n\n    /// @notice Register LP token data\n    function _registerLp(address lpToken_, bool isLending_) internal virtual {\n        require(!isLpRegistered(lpToken_), \"lp-already-registered\");\n        ICurveRegistry _registry = ICurveRegistry(registry);\n        address _pool = _registry.get_pool_from_lp_token(lpToken_);\n        require(_pool != address(0), \"invalid-non-factory-lp\");\n\n        address[8] memory _tokens;\n        if (isLending_) {\n            _tokens = _registry.get_underlying_coins(_pool);\n        } else {\n            _tokens = _registry.get_coins(_pool);\n        }\n\n        if (poolOf[lpToken_] != address(0)) {\n            // Clean current tokens if LP exists\n            delete underlyingTokens[lpToken_];\n        }\n\n        poolOf[lpToken_] = _pool;\n\n        uint256 _n = _registry.get_n_coins(_pool);\n        for (uint256 i; i < _n; i++) {\n            if (_tokens[i] == ETH) {\n                underlyingTokens[lpToken_].push(weth);\n            } else {\n                underlyingTokens[lpToken_].push(_tokens[i]);\n            }\n        }\n\n        emit LpRegistered(lpToken_, isLending_);\n    }\n}\n"
    },
    "contracts/periphery/tokens/CurveLpTokenOracleV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\nimport \"../../interfaces/external/curve/ICurveAddressProvider.sol\";\nimport \"../../interfaces/external/curve/ICurveMetaRegistry.sol\";\nimport \"../../interfaces/external/curve/ICurvePool.sol\";\nimport \"../../interfaces/periphery/IOracle.sol\";\nimport \"../../access/Governable.sol\";\n\n/**\n * @title Oracle for Curve LP tokens\n */\ncontract CurveLpTokenOracleV2 is ITokenOracle, Governable {\n    /// @dev Same address for all chains\n    ICurveAddressProvider public constant curveAddressProvider =\n        ICurveAddressProvider(0x0000000022D53366457F9d5E68Ec105046FC4383);\n\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    address internal immutable weth;\n\n    uint256 private constant META_REGISTRY_ADDRESS_ID = 7;\n\n    /// @notice LP token => coins mapping\n    mapping(address => address[]) public underlyingTokens;\n\n    /// @notice LP token => pool\n    mapping(address => address) public poolOf;\n\n    /// @notice Emitted when a LP token is registered\n    event LpRegistered(address indexed lpToken);\n\n    constructor(address weth_) {\n        require(weth_ != address(0), \"null-weth\");\n        weth = weth_;\n    }\n\n    /// @inheritdoc ITokenOracle\n    /// @dev This function is supposed to be called from `MasterOracle` only\n    function getPriceInUsd(address lpToken_) external view override returns (uint256 _priceInUsd) {\n        address _pool = poolOf[lpToken_];\n        require(_pool != address(0), \"lp-is-not-registered\");\n        address[] memory _tokens = underlyingTokens[lpToken_];\n        uint256 _min = type(uint256).max;\n        uint256 _n = _tokens.length;\n\n        for (uint256 i; i < _n; i++) {\n            // Note: `msg.sender` is the `MasterOracle` contract\n            uint256 _price = IOracle(msg.sender).getPriceInUsd(_tokens[i]);\n            if (_price < _min) _min = _price;\n        }\n\n        require(_min < type(uint256).max, \"no-min-underlying-price-found\");\n        require(_min > 0, \"invalid-min-price\");\n\n        return (_min * ICurvePool(_pool).get_virtual_price()) / 1e18;\n    }\n\n    /// @notice Check if a token is already registered\n    function isLpRegistered(address lpToken_) public view returns (bool) {\n        return underlyingTokens[lpToken_].length > 0;\n    }\n\n    /// @notice Register LP token data\n    function registerLp(address lpToken_) external onlyGovernor {\n        require(!isLpRegistered(lpToken_), \"lp-already-registered\");\n\n        ICurveMetaRegistry _registry = ICurveMetaRegistry(curveAddressProvider.get_address(META_REGISTRY_ADDRESS_ID));\n\n        address _pool = _registry.get_pool_from_lp_token(lpToken_);\n        require(_pool != address(0), \"invalid-lp-token\");\n\n        if (poolOf[lpToken_] != address(0)) {\n            // Clean current tokens if LP exists\n            delete underlyingTokens[lpToken_];\n        }\n        poolOf[lpToken_] = _pool;\n\n        address[8] memory _tokens = _registry.get_underlying_coins(_pool);\n\n        // Due to issue here https://github.com/curvefi/metaregistry/issues/25\n        // we are using address(0) check to break out and not using below line to get exact coin count.\n        // uint256 _noOfCoins = _registry.get_n_underlying_coins(_pool);\n        for (uint256 i; i < 8; i++) {\n            if (_tokens[i] == address(0)) {\n                break;\n            }\n            if (_tokens[i] == ETH) {\n                underlyingTokens[lpToken_].push(weth);\n            } else {\n                underlyingTokens[lpToken_].push(_tokens[i]);\n            }\n        }\n\n        emit LpRegistered(lpToken_);\n    }\n}\n"
    },
    "contracts/periphery/tokens/ERC4626TokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../interfaces/periphery/IOracle.sol\";\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\nimport \"../../interfaces/external/IERC4626.sol\";\n\n/**\n * @title Oracle for ERC-4626 token\n */\ncontract ERC4626TokenOracle is ITokenOracle {\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address token_) external view override returns (uint256 _priceInUsd) {\n        IERC4626 _vault = IERC4626(token_);\n\n        _priceInUsd = IOracle(msg.sender).quoteTokenToUsd(\n            _vault.asset(),\n            _vault.convertToAssets(10 ** _vault.decimals())\n        );\n    }\n}\n"
    },
    "contracts/periphery/tokens/IbBtcTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../interfaces/periphery/IOracle.sol\";\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\nimport \"../../interfaces/external/badger/IXToken.sol\";\n\n/**\n * @title Oracle for ibBTC token\n */\ncontract IbBtcTokenOracle is ITokenOracle {\n    IXToken public constant IBBTC = IXToken(0xc4E15973E6fF2A35cC804c2CF9D2a1b817a8b40F);\n    IXToken public constant WIBBTC = IXToken(0x8751D4196027d4e6DA63716fA7786B5174F04C15);\n\n    /// @notice BTC/USD oracle\n    ITokenOracle public immutable btcOracle;\n\n    constructor(ITokenOracle btcOracle_) {\n        btcOracle = btcOracle_;\n    }\n\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address token_) external view override returns (uint256 _priceInUsd) {\n        if (token_ == address(IBBTC)) {\n            return (btcOracle.getPriceInUsd(address(0)) * IBBTC.pricePerShare()) / 1e18;\n        }\n        if (token_ == address(WIBBTC)) {\n            return (btcOracle.getPriceInUsd(address(0)) * IBBTC.pricePerShare()) / WIBBTC.pricePerShare();\n        }\n\n        revert(\"invalid-ibbtc-related-token\");\n    }\n}\n"
    },
    "contracts/periphery/tokens/MStableTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../interfaces/external/mstable/IMasset.sol\";\nimport \"../../interfaces/external/mstable/ISavingsContractV2.sol\";\nimport \"../../interfaces/periphery/IOracle.sol\";\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\n\n/**\n * @title mStable's tokens oracle\n */\ncontract MStableTokenOracle is ITokenOracle {\n    uint256 private constant RATIO_DENOMINATOR = 1e8;\n\n    IMasset public constant MUSD = IMasset(0xe2f2a5C287993345a840Db3B0845fbC70f5935a5);\n    ISavingsContractV2 public constant IMUSD = ISavingsContractV2(0x30647a72Dc82d7Fbb1123EA74716aB8A317Eac19);\n    IMasset public constant MBTC = IMasset(0x945Facb997494CC2570096c74b5F66A3507330a1);\n    ISavingsContractV2 public constant IMBTC = ISavingsContractV2(0x17d8CBB6Bce8cEE970a4027d1198F6700A7a6c24);\n\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address mAsset_) external view returns (uint256) {\n        if (mAsset_ == address(MUSD)) return _mAssetUsdPrice(MUSD);\n        if (mAsset_ == address(IMUSD)) return (IMUSD.exchangeRate() * _mAssetUsdPrice(MUSD)) / 1e18;\n        if (mAsset_ == address(MBTC)) return _mAssetUsdPrice(MBTC);\n        if (mAsset_ == address(IMBTC)) return (IMBTC.exchangeRate() * _mAssetUsdPrice(MBTC)) / 1e18;\n\n        revert(\"invalid-token\");\n    }\n\n    /// @notice Return mAsset price\n    /// @dev Uses the `MasterOracle` (msg.sender) to get underlying assets' prices\n    function _mAssetUsdPrice(IMasset mAsset_) private view returns (uint256) {\n        (IMasset.BassetPersonal[] memory bAssetPersonal, IMasset.BassetData[] memory bAssetData) = mAsset_.getBassets();\n        uint256 _totalValue;\n        uint256 _len = bAssetData.length;\n        for (uint256 i; i < _len; i++) {\n            _totalValue +=\n                ((uint256(bAssetData[i].vaultBalance * bAssetData[i].ratio)) / RATIO_DENOMINATOR) *\n                // Note: `msg.sender` is the `MasterOracle` contract\n                IOracle(msg.sender).getPriceInUsd(bAssetPersonal[i].addr);\n        }\n\n        return _totalValue / mAsset_.totalSupply();\n    }\n}\n"
    },
    "contracts/periphery/tokens/RedstoneUsdcOnlyTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"../../interfaces/periphery/IOracle.sol\";\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\nimport \"../../features/UsingStalePeriod.sol\";\n\n/**\n * @title Redstone Oracle for token with USDC-only price feed\n * @dev Redstone uses the same interface but asset decimals aren't the same as Chainlink\n */\ncontract RedstoneUsdcOnlyTokenOracle is ITokenOracle, UsingStalePeriod {\n    using SafeCast for int256;\n\n    uint256 constant USDC_FEED_DECIMALS = 8;\n\n    address public immutable USDC;\n\n    mapping(address => AggregatorV3Interface) public usdcFeedOf;\n\n    event UsdcFeedUpdated(address indexed token, AggregatorV3Interface usdcFeed);\n\n    constructor(address usdc_) UsingStalePeriod(24 hours) {\n        USDC = usdc_;\n    }\n\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address token_) external view override returns (uint256 _priceInUsd) {\n        // TOKEN/USDC price from Redstone\n        (, int256 _price, , uint256 _lastUpdatedAt, ) = usdcFeedOf[token_].latestRoundData();\n        require(_price > 0 && !_priceIsStale(token_, _lastUpdatedAt), \"price-invalid\");\n        uint256 _priceInUsdc = _price.toUint256();\n\n        // USDC/USD price from Redstone\n        uint256 _usdcPriceInUsd = IOracle(msg.sender).getPriceInUsd(USDC);\n\n        // TOKEN/USD price\n        return (_priceInUsdc * _usdcPriceInUsd) / 10 ** USDC_FEED_DECIMALS;\n    }\n\n    /**\n     * @notice Update default stale period\n     */\n    function updateUsdcFeed(address token_, AggregatorV3Interface usdcFeed_) external onlyGovernor {\n        emit UsdcFeedUpdated(token_, usdcFeed_);\n        usdcFeedOf[token_] = usdcFeed_;\n    }\n}\n"
    },
    "contracts/periphery/tokens/SFraxEthTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../interfaces/external/frax/ISFrxEth.sol\";\nimport \"../../interfaces/external/curve/IFrxEthStableSwap.sol\";\nimport \"../../interfaces/periphery/IOracle.sol\";\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\n\n/**\n * @title Oracle for `sFraxEthToken`\n * @dev Based on https://etherscan.deth.net/address/0x27942aFe4EcB7F9945168094e0749CAC749aC97B#code\n * @dev `WETH/FRXETH` Curve pool's oracle is safer than `ETH/FRXETH`\n */\ncontract SFraxEthTokenOracle is ITokenOracle {\n    uint256 public constant MAX_FRXETH_PRICE = 1e18;\n    uint256 public constant MIN_FRXETH_PRICE = 0.9e18;\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    IFrxEthStableSwap public constant WETH_FRXETH_CURVE_POOL =\n        IFrxEthStableSwap(0x9c3B46C0Ceb5B9e304FCd6D88Fc50f7DD24B31Bc);\n    ISFrxEth public constant SFRXETH = ISFrxEth(0xac3E018457B222d93114458476f3E3416Abbe38F);\n\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address) external view override returns (uint256 _priceInUsd) {\n        // ETH/USD price from Chainlink\n        uint256 _ethPriceInUsd = IOracle(msg.sender).getPriceInUsd(WETH);\n\n        // FrxETH/ETH price\n        uint256 _frxEthPriceInEth = WETH_FRXETH_CURVE_POOL.price_oracle();\n\n        if (_frxEthPriceInEth > MAX_FRXETH_PRICE) {\n            _frxEthPriceInEth = MAX_FRXETH_PRICE;\n        } else if (_frxEthPriceInEth < MIN_FRXETH_PRICE) {\n            _frxEthPriceInEth = MIN_FRXETH_PRICE;\n        }\n\n        // sFrxETH/FrxETH price from `pricePerShare`\n        return ((SFRXETH.pricePerShare() * _frxEthPriceInEth * _ethPriceInUsd) / (1e36));\n    }\n}\n"
    },
    "contracts/periphery/tokens/TBYOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\nimport \"../../interfaces/periphery/IOracle.sol\";\nimport \"../../interfaces/external/bloom/IBloomPool.sol\";\nimport \"../../interfaces/external/bloom/IExchangeRateRegistry.sol\";\n\n/**\n * @title Oracle for TBY tokens\n */\ncontract TBYOracle is ITokenOracle {\n    uint256 public constant ONE_USD = 1e18;\n\n    IExchangeRateRegistry public immutable exchangeRateRegistry;\n\n    constructor(IExchangeRateRegistry exchangeRateRegistry_) {\n        exchangeRateRegistry = exchangeRateRegistry_;\n    }\n\n    /**\n     * Note: Until the maturity, we use the exchange rate to calculate TBY price\n     * When it enters the withdraw phase, exchange rate isn't accurate because:\n     * 1) Interest rate may vary and that could impact TBY price even after the maturity\n     * 2) After the maturity the actual TBY price is the redeemable USDC amount\n     */\n    function getPriceInUsd(address token_) external view returns (uint256) {\n        IBloomPool _tby = IBloomPool(token_);\n        IERC20Metadata _underlying = _tby.UNDERLYING_TOKEN(); // i.e., USDC\n        IOracle _masterOracle = IOracle(msg.sender);\n        uint256 _underlyingPrice = _masterOracle.getPriceInUsd(address(_underlying));\n\n        if (_tby.state() == IBloomPool.State.FinalWithdraw) {\n            (, , uint128 lenderDistribution, uint128 totalLenderShares) = _tby.getDistributionInfo();\n            uint256 _oneShare = 10 ** _tby.decimals();\n            uint256 _underlyingAmountPerShare = (_oneShare * lenderDistribution) / totalLenderShares;\n            return (_underlyingPrice * _underlyingAmountPerShare) / _underlying.decimals();\n        }\n\n        return (_underlyingPrice * exchangeRateRegistry.getExchangeRate(token_)) / ONE_USD;\n    }\n}\n"
    },
    "contracts/periphery/tokens/UniswapV2LikeLpTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@prb/math/contracts/PRBMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"../../interfaces/periphery/IOracle.sol\";\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\nimport \"../../libraries/OracleHelpers.sol\";\n\n/**\n * @title Oracle for UniswapV2-Like liquidity pair tokens\n * @dev See more: https://blog.alphaventuredao.io/fair-lp-token-pricing/\n */\ncontract UniswapV2LikeLpTokenOracle is ITokenOracle {\n    using OracleHelpers for uint256;\n    using PRBMath for uint256;\n\n    /**\n     * @notice The oracle that resolves the price of underlying token\n     */\n    IOracle public immutable underlyingOracle;\n\n    constructor(IOracle _underlyingOracle) {\n        require(address(_underlyingOracle) != address(0), \"underlying-oracle-null\");\n        underlyingOracle = _underlyingOracle;\n    }\n\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address _asset) external view returns (uint256 _priceInUsd) {\n        IUniswapV2Pair _pair = IUniswapV2Pair(address(_asset));\n        (uint256 _reserve0, uint256 _reserve1, ) = _pair.getReserves();\n\n        address _token0 = _pair.token0();\n        address _token1 = _pair.token1();\n\n        _reserve0 = OracleHelpers.scaleDecimal(_reserve0, IERC20Metadata(_token0).decimals(), 18);\n        _reserve1 = OracleHelpers.scaleDecimal(_reserve1, IERC20Metadata(_token1).decimals(), 18);\n\n        uint256 _token0Price = underlyingOracle.getPriceInUsd(_token0);\n        uint256 _token1Price = underlyingOracle.getPriceInUsd(_token1);\n\n        uint256 _sqrtK = (_reserve0 * _reserve1).sqrt();\n        uint256 _sqrtP0xP1 = (_token0Price * _token1Price).sqrt();\n\n        _priceInUsd = (2 * (_sqrtK * _sqrtP0xP1)) / _pair.totalSupply();\n    }\n}\n"
    },
    "contracts/periphery/tokens/USDPeggedTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\n\n/**\n * @title Oracle for USD hard pegged token\n * @dev This oracle shouldn't be used for stable coins! Its purpose is for a specific use case that's the Synth USD token.\n */\ncontract USDPeggedTokenOracle is ITokenOracle {\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address) external pure override returns (uint256 _priceInUsd) {\n        return 1e18;\n    }\n}\n"
    },
    "contracts/periphery/tokens/VPoolTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../interfaces/periphery/IOracle.sol\";\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\nimport \"../../interfaces/external/vesper/IVesperPool.sol\";\n\n/**\n * @title Oracle for vPool token\n */\ncontract VPoolTokenOracle is ITokenOracle {\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address token_) external view override returns (uint256 _priceInUsd) {\n        IVesperPool _vToken = IVesperPool(token_);\n        address _underlyingAddress = _vToken.token();\n        _priceInUsd =\n            (IOracle(msg.sender).getPriceInUsd(_underlyingAddress) * _vToken.pricePerShare()) /\n            10**IERC20Metadata(_underlyingAddress).decimals();\n    }\n}\n"
    },
    "contracts/periphery/tokens/VspMainnetOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../../features/UsingMaxDeviation.sol\";\nimport \"../../features/UsingStalePeriod.sol\";\nimport \"../../interfaces/periphery/IUpdatableOracle.sol\";\nimport \"../../interfaces/core/IUniswapV2LikePriceProvider.sol\";\n\n/**\n * @title VSP oracle (mainnet)\n */\ncontract VspMainnetOracle is IUpdatableOracle, UsingMaxDeviation, UsingStalePeriod {\n    uint256 public constant ONE_VSP = 1e18;\n    address public constant VSP_ADDRESS = 0x1b40183EFB4Dd766f11bDa7A7c3AD8982e998421;\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    constructor(uint256 maxDeviation_, uint256 stalePeriod_)\n        UsingMaxDeviation(maxDeviation_)\n        UsingStalePeriod(stalePeriod_)\n    {}\n\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address _asset) external view returns (uint256 _priceInUsd) {\n        require(address(_asset) == VSP_ADDRESS, \"invalid-token\");\n        uint256 _lastUpdatedAt;\n        IPriceProvidersAggregator _aggregator = addressProvider.providersAggregator();\n\n        (_priceInUsd, _lastUpdatedAt) = _aggregator.quoteTokenToUsd(\n            DataTypes.Provider.UNISWAP_V2,\n            VSP_ADDRESS,\n            ONE_VSP\n        );\n        (uint256 _priceInUsd1, uint256 _lastUpdatedAt1) = _aggregator.quoteTokenToUsd(\n            DataTypes.Provider.SUSHISWAP,\n            VSP_ADDRESS,\n            ONE_VSP\n        );\n\n        require(\n            _priceInUsd > 0 && _priceInUsd1 > 0 && !_priceIsStale(_asset, Math.min(_lastUpdatedAt, _lastUpdatedAt1)),\n            \"one-or-both-prices-invalid\"\n        );\n        require(_isDeviationOK(_priceInUsd, _priceInUsd1), \"prices-deviation-too-high\");\n    }\n\n    /// @inheritdoc IUpdatableOracle\n    function update() external override {\n        IAddressProvider _addressProvider = addressProvider;\n        IPriceProvidersAggregator _aggregator = _addressProvider.providersAggregator();\n        address _stableCoin = _addressProvider.stableCoinProvider().getStableCoinIfPegged();\n\n        IUniswapV2LikePriceProvider _uniswapV2PriceProvider = IUniswapV2LikePriceProvider(\n            address(_aggregator.priceProviders(DataTypes.Provider.UNISWAP_V2))\n        );\n        IUniswapV2LikePriceProvider _sushiswapPriceProvider = IUniswapV2LikePriceProvider(\n            address(_aggregator.priceProviders(DataTypes.Provider.SUSHISWAP))\n        );\n\n        _uniswapV2PriceProvider.updateOrAdd(VSP_ADDRESS, WETH_ADDRESS);\n        _uniswapV2PriceProvider.updateOrAdd(WETH_ADDRESS, _stableCoin);\n        _sushiswapPriceProvider.updateOrAdd(VSP_ADDRESS, WETH_ADDRESS);\n        _sushiswapPriceProvider.updateOrAdd(WETH_ADDRESS, _stableCoin);\n    }\n}\n"
    },
    "contracts/periphery/tokens/YEarnTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\nimport \"../../interfaces/periphery/IOracle.sol\";\nimport \"../../interfaces/external/yearn/IYearn.sol\";\n\n/**\n * @title Oracle for Yearn tokens\n */\ncontract YEarnTokenOracle is ITokenOracle {\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address token_) external view returns (uint256 _priceInUsd) {\n        IYearn _yToken = IYearn(token_);\n        uint256 _underlyingPrice = IOracle(msg.sender).getPriceInUsd(_yToken.token());\n        return (_yToken.getPricePerFullShare() * _underlyingPrice) / 1e18; // getPricePerFullShare is scaled by 1e18\n    }\n}\n"
    },
    "contracts/periphery/VTokenFraxLendOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol\";\nimport \"../interfaces/external/vesper/IVesperPool.sol\";\n\n/**\n * @title Oracle for vPool token (FraxLend)\n */\ncontract VTokenFraxLendOracle {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n\n    IVesperPool public immutable vToken;\n    AggregatorV3Interface public immutable aggregator;\n    uint8 public immutable underlyingDecimals;\n\n    constructor(AggregatorV3Interface aggregator_, IVesperPool vToken_) {\n        aggregator = aggregator_;\n        vToken = vToken_;\n        underlyingDecimals = IERC20Metadata(vToken_.token()).decimals();\n    }\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        int256 _answer;\n        (roundId, _answer, startedAt, updatedAt, answeredInRound) = aggregator.latestRoundData();\n        answer = ((_answer.toUint256() * vToken.pricePerShare()) / 10**underlyingDecimals).toInt256();\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 5000
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}