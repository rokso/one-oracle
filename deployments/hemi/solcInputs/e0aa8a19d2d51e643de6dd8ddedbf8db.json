{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"./AggregatorV2V3Interface.sol\";\n\ninterface FeedRegistryInterface {\n  struct Phase {\n    uint16 phaseId;\n    uint80 startingAggregatorRoundId;\n    uint80 endingAggregatorRoundId;\n  }\n\n  event FeedProposed(\n    address indexed asset,\n    address indexed denomination,\n    address indexed proposedAggregator,\n    address currentAggregator,\n    address sender\n  );\n  event FeedConfirmed(\n    address indexed asset,\n    address indexed denomination,\n    address indexed latestAggregator,\n    address previousAggregator,\n    uint16 nextPhaseId,\n    address sender\n  );\n\n  // V3 AggregatorV3Interface\n\n  function decimals(address base, address quote) external view returns (uint8);\n\n  function description(address base, address quote) external view returns (string memory);\n\n  function version(address base, address quote) external view returns (uint256);\n\n  function latestRoundData(address base, address quote)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function getRoundData(\n    address base,\n    address quote,\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  // V2 AggregatorInterface\n\n  function latestAnswer(address base, address quote) external view returns (int256 answer);\n\n  function latestTimestamp(address base, address quote) external view returns (uint256 timestamp);\n\n  function latestRound(address base, address quote) external view returns (uint256 roundId);\n\n  function getAnswer(\n    address base,\n    address quote,\n    uint256 roundId\n  ) external view returns (int256 answer);\n\n  function getTimestamp(\n    address base,\n    address quote,\n    uint256 roundId\n  ) external view returns (uint256 timestamp);\n\n  // Registry getters\n\n  function getFeed(address base, address quote) external view returns (AggregatorV2V3Interface aggregator);\n\n  function getPhaseFeed(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (AggregatorV2V3Interface aggregator);\n\n  function isFeedEnabled(address aggregator) external view returns (bool);\n\n  function getPhase(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (Phase memory phase);\n\n  // Round helpers\n\n  function getRoundFeed(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (AggregatorV2V3Interface aggregator);\n\n  function getPhaseRange(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (uint80 startingRoundId, uint80 endingRoundId);\n\n  function getPreviousRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (uint80 previousRoundId);\n\n  function getNextRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (uint80 nextRoundId);\n\n  // Feed management\n\n  function proposeFeed(\n    address base,\n    address quote,\n    address aggregator\n  ) external;\n\n  function confirmFeed(\n    address base,\n    address quote,\n    address aggregator\n  ) external;\n\n  // Proposed aggregator\n\n  function getProposedFeed(address base, address quote)\n    external\n    view\n    returns (AggregatorV2V3Interface proposedAggregator);\n\n  function proposedGetRoundData(\n    address base,\n    address quote,\n    uint80 roundId\n  )\n    external\n    view\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function proposedLatestRoundData(address base, address quote)\n    external\n    view\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  // Phases\n  function getCurrentPhaseId(address base, address quote) external view returns (uint16 currentPhaseId);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPyth.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./PythStructs.sol\";\nimport \"./IPythEvents.sol\";\n\n/// @title Consume prices from the Pyth Network (https://pyth.network/).\n/// @dev Please refer to the guidance at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how to consume prices safely.\n/// @author Pyth Data Association\ninterface IPyth is IPythEvents {\n    /// @notice Returns the price of a price feed without any sanity checks.\n    /// @dev This function returns the most recent price update in this contract without any recency checks.\n    /// This function is unsafe as the returned price update may be arbitrarily far in the past.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use `getPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price that is no older than `age` seconds of the current time.\n    /// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.\n    /// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.\n    /// However, if the price is not recent this function returns the latest available price.\n    ///\n    /// The returned price can be from arbitrarily far in the past; this function makes no guarantees that\n    /// the returned price is recent or useful for any particular application.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds\n    /// of the current time.\n    /// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Update price feeds with given update messages.\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    /// Prices will be updated if they are more recent than the current stored prices.\n    /// The call will succeed even if the update is not the most recent.\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    function updatePriceFeeds(bytes[] calldata updateData) external payable;\n\n    /// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is\n    /// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the\n    /// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    /// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime\n    /// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have\n    /// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.\n    /// Otherwise, it calls updatePriceFeeds method to update the prices.\n    ///\n    /// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`\n    function updatePriceFeedsIfNecessary(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64[] calldata publishTimes\n    ) external payable;\n\n    /// @notice Returns the required fee to update an array of price updates.\n    /// @param updateData Array of price update data.\n    /// @return feeAmount The required fee in Wei.\n    function getUpdateFee(\n        bytes[] calldata updateData\n    ) external view returns (uint feeAmount);\n\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\n    /// within `minPublishTime` and `maxPublishTime`.\n    ///\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\n    /// otherwise, please consider using `updatePriceFeeds`. This method may store the price updates on-chain, if they\n    /// are more recent than the current stored prices.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n\n    /// @notice Similar to `parsePriceFeedUpdates` but ensures the updates returned are\n    /// the first updates published in minPublishTime. That is, if there are multiple updates for a given timestamp,\n    /// this method will return the first update. This method may store the price updates on-chain, if they\n    /// are more recent than the current stored prices.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range and uniqueness condition.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdatesUnique(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPythEvents.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @title IPythEvents contains the events that Pyth contract emits.\n/// @dev This interface can be used for listening to the updates for off-chain and testing purposes.\ninterface IPythEvents {\n    /// @dev Emitted when the price feed with `id` has received a fresh update.\n    /// @param id The Pyth Price Feed ID.\n    /// @param publishTime Publish time of the given price update.\n    /// @param price Price of the given price update.\n    /// @param conf Confidence interval of the given price update.\n    event PriceFeedUpdate(\n        bytes32 indexed id,\n        uint64 publishTime,\n        int64 price,\n        uint64 conf\n    );\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/PythStructs.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ncontract PythStructs {\n    // A price with a degree of uncertainty, represented as a price +- a confidence interval.\n    //\n    // The confidence interval roughly corresponds to the standard error of a normal distribution.\n    // Both the price and confidence are stored in a fixed-point numeric representation,\n    // `x * (10^expo)`, where `expo` is the exponent.\n    //\n    // Please refer to the documentation at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how\n    // to how this price safely.\n    struct Price {\n        // Price\n        int64 price;\n        // Confidence interval around the price\n        uint64 conf;\n        // Price exponent\n        int32 expo;\n        // Unix timestamp describing when the price was published\n        uint publishTime;\n    }\n\n    // PriceFeed represents a current aggregate price from pyth publisher feeds.\n    struct PriceFeed {\n        // The price ID.\n        bytes32 id;\n        // Latest available price\n        Price price;\n        // Latest available exponentially-weighted moving average price\n        Price emaPrice;\n    }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/CalldataExtractor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"./RedstoneConstants.sol\";\n\n/**\n * @title The base contract with the main logic of data extraction from calldata\n * @author The Redstone Oracles team\n * @dev This contract was created to reuse the same logic in the RedstoneConsumerBase\n * and the ProxyConnector contracts\n */\ncontract CalldataExtractor is RedstoneConstants {\n\n  error DataPackageTimestampMustNotBeZero();\n  error DataPackageTimestampsMustBeEqual();\n  error RedstonePayloadMustHaveAtLeastOneDataPackage();\n  error TooLargeValueByteSize(uint256 valueByteSize);\n\n  function extractTimestampsAndAssertAllAreEqual() public pure returns (uint256 extractedTimestamp) {\n    uint256 calldataNegativeOffset = _extractByteSizeOfUnsignedMetadata();\n    uint256 dataPackagesCount;\n    (dataPackagesCount, calldataNegativeOffset) = _extractDataPackagesCountFromCalldata(calldataNegativeOffset);\n\n    if (dataPackagesCount == 0) {\n      revert RedstonePayloadMustHaveAtLeastOneDataPackage();\n    }\n\n    for (uint256 dataPackageIndex = 0; dataPackageIndex < dataPackagesCount; dataPackageIndex++) {\n      uint256 dataPackageByteSize = _getDataPackageByteSize(calldataNegativeOffset);\n\n      // Extracting timestamp for the current data package\n      uint48 dataPackageTimestamp; // uint48, because timestamp uses 6 bytes\n      uint256 timestampNegativeOffset = (calldataNegativeOffset + TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS);\n      uint256 timestampOffset = msg.data.length - timestampNegativeOffset;\n      assembly {\n        dataPackageTimestamp := calldataload(timestampOffset)\n      }\n\n      if (dataPackageTimestamp == 0) {\n        revert DataPackageTimestampMustNotBeZero();\n      }\n\n      if (extractedTimestamp == 0) {\n        extractedTimestamp = dataPackageTimestamp;\n      } else if (dataPackageTimestamp != extractedTimestamp) {\n        revert DataPackageTimestampsMustBeEqual();\n      }\n\n      calldataNegativeOffset += dataPackageByteSize;\n    }\n  }\n\n  function _getDataPackageByteSize(uint256 calldataNegativeOffset) internal pure returns (uint256) {\n    (\n      uint256 dataPointsCount,\n      uint256 eachDataPointValueByteSize\n    ) = _extractDataPointsDetailsForDataPackage(calldataNegativeOffset);\n\n    return\n      dataPointsCount *\n      (DATA_POINT_SYMBOL_BS + eachDataPointValueByteSize) +\n      DATA_PACKAGE_WITHOUT_DATA_POINTS_BS;\n  }\n\n  function _extractByteSizeOfUnsignedMetadata() internal pure returns (uint256) {\n    // Checking if the calldata ends with the RedStone marker\n    bool hasValidRedstoneMarker;\n    assembly {\n      let calldataLast32Bytes := calldataload(sub(calldatasize(), STANDARD_SLOT_BS))\n      hasValidRedstoneMarker := eq(\n        REDSTONE_MARKER_MASK,\n        and(calldataLast32Bytes, REDSTONE_MARKER_MASK)\n      )\n    }\n    if (!hasValidRedstoneMarker) {\n      revert CalldataMustHaveValidPayload();\n    }\n\n    // Using uint24, because unsigned metadata byte size number has 3 bytes\n    uint24 unsignedMetadataByteSize;\n    if (REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS > msg.data.length) {\n      revert CalldataOverOrUnderFlow();\n    }\n    assembly {\n      unsignedMetadataByteSize := calldataload(\n        sub(calldatasize(), REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS)\n      )\n    }\n    uint256 calldataNegativeOffset = unsignedMetadataByteSize\n      + UNSIGNED_METADATA_BYTE_SIZE_BS\n      + REDSTONE_MARKER_BS;\n    if (calldataNegativeOffset + DATA_PACKAGES_COUNT_BS > msg.data.length) {\n      revert IncorrectUnsignedMetadataSize();\n    }\n    return calldataNegativeOffset;\n  }\n\n  // We return uint16, because unsigned metadata byte size number has 2 bytes\n  function _extractDataPackagesCountFromCalldata(uint256 calldataNegativeOffset)\n    internal\n    pure\n    returns (uint16 dataPackagesCount, uint256 nextCalldataNegativeOffset)\n  {\n    uint256 calldataNegativeOffsetWithStandardSlot = calldataNegativeOffset + STANDARD_SLOT_BS;\n    if (calldataNegativeOffsetWithStandardSlot > msg.data.length) {\n      revert CalldataOverOrUnderFlow();\n    }\n    assembly {\n      dataPackagesCount := calldataload(\n        sub(calldatasize(), calldataNegativeOffsetWithStandardSlot)\n      )\n    }\n    return (dataPackagesCount, calldataNegativeOffset + DATA_PACKAGES_COUNT_BS);\n  }\n\n  function _extractDataPointValueAndDataFeedId(\n    uint256 dataPointNegativeOffset,\n    uint256 dataPointValueByteSize\n  ) internal pure virtual returns (bytes32 dataPointDataFeedId, uint256 dataPointValue) {\n    uint256 dataPointCalldataOffset = msg.data.length - dataPointNegativeOffset;\n    assembly {\n      dataPointDataFeedId := calldataload(dataPointCalldataOffset)\n      dataPointValue := calldataload(add(dataPointCalldataOffset, DATA_POINT_SYMBOL_BS))\n    }\n    if (dataPointValueByteSize >= 33) {\n      revert TooLargeValueByteSize(dataPointValueByteSize);\n    }\n    unchecked {\n      dataPointValue = dataPointValue >> (32 - dataPointValueByteSize) * 8; \n    }\n  }\n\n  function _extractDataPointsDetailsForDataPackage(uint256 calldataNegativeOffsetForDataPackage)\n    internal\n    pure\n    returns (uint256 dataPointsCount, uint256 eachDataPointValueByteSize)\n  {\n    // Using uint24, because data points count byte size number has 3 bytes\n    uint24 dataPointsCount_;\n\n    // Using uint32, because data point value byte size has 4 bytes\n    uint32 eachDataPointValueByteSize_;\n\n    // Extract data points count\n    uint256 calldataOffset = msg.data.length - (calldataNegativeOffsetForDataPackage + SIG_BS + STANDARD_SLOT_BS);\n    assembly {\n      dataPointsCount_ := calldataload(calldataOffset)\n    }\n\n    // Extract each data point value size\n    calldataOffset = calldataOffset - DATA_POINTS_COUNT_BS;\n    assembly {\n      eachDataPointValueByteSize_ := calldataload(calldataOffset)\n    }\n\n    // Prepare returned values\n    dataPointsCount = dataPointsCount_;\n    eachDataPointValueByteSize = eachDataPointValueByteSize_;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneConstants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\n/**\n * @title The base contract with helpful constants\n * @author The Redstone Oracles team\n * @dev It mainly contains redstone-related values, which improve readability\n * of other contracts (e.g. CalldataExtractor and RedstoneConsumerBase)\n */\ncontract RedstoneConstants {\n  // === Abbreviations ===\n  // BS - Bytes size\n  // PTR - Pointer (memory location)\n  // SIG - Signature\n\n  // Solidity and YUL constants\n  uint256 internal constant STANDARD_SLOT_BS = 32;\n  uint256 internal constant FREE_MEMORY_PTR = 0x40;\n  uint256 internal constant BYTES_ARR_LEN_VAR_BS = 32;\n  uint256 internal constant FUNCTION_SIGNATURE_BS = 4;\n  uint256 internal constant REVERT_MSG_OFFSET = 68; // Revert message structure described here: https://ethereum.stackexchange.com/a/66173/106364\n  uint256 internal constant STRING_ERR_MESSAGE_MASK = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n\n  // RedStone protocol consts\n  uint256 internal constant SIG_BS = 65;\n  uint256 internal constant TIMESTAMP_BS = 6;\n  uint256 internal constant DATA_PACKAGES_COUNT_BS = 2;\n  uint256 internal constant DATA_POINTS_COUNT_BS = 3;\n  uint256 internal constant DATA_POINT_VALUE_BYTE_SIZE_BS = 4;\n  uint256 internal constant DATA_POINT_SYMBOL_BS = 32;\n  uint256 internal constant DEFAULT_DATA_POINT_VALUE_BS = 32;\n  uint256 internal constant UNSIGNED_METADATA_BYTE_SIZE_BS = 3;\n  uint256 internal constant REDSTONE_MARKER_BS = 9; // byte size of 0x000002ed57011e0000\n  uint256 internal constant REDSTONE_MARKER_MASK = 0x0000000000000000000000000000000000000000000000000002ed57011e0000;\n\n  // Derived values (based on consts)\n  uint256 internal constant TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS = 104; // SIG_BS + DATA_POINTS_COUNT_BS + DATA_POINT_VALUE_BYTE_SIZE_BS + STANDARD_SLOT_BS\n  uint256 internal constant DATA_PACKAGE_WITHOUT_DATA_POINTS_BS = 78; // DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS + SIG_BS\n  uint256 internal constant DATA_PACKAGE_WITHOUT_DATA_POINTS_AND_SIG_BS = 13; // DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS\n  uint256 internal constant REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS = 41; // REDSTONE_MARKER_BS + STANDARD_SLOT_BS\n\n  // Error messages\n  error CalldataOverOrUnderFlow();\n  error IncorrectUnsignedMetadataSize();\n  error InsufficientNumberOfUniqueSigners(uint256 receivedSignersCount, uint256 requiredSignersCount);\n  error EachSignerMustProvideTheSameValue();\n  error EmptyCalldataPointersArr();\n  error InvalidCalldataPointer();\n  error CalldataMustHaveValidPayload();\n  error SignerNotAuthorised(address receivedSigner);\n  error DataTimestampCannotBeZero();\n  error TimestampsMustBeEqual();\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"./RedstoneConstants.sol\";\nimport \"./RedstoneDefaultsLib.sol\";\nimport \"./CalldataExtractor.sol\";\nimport \"../libs/BitmapLib.sol\";\nimport \"../libs/SignatureLib.sol\";\n\n/**\n * @title The base contract with the main Redstone logic\n * @author The Redstone Oracles team\n * @dev Do not use this contract directly in consumer contracts, take a\n * look at `RedstoneConsumerNumericBase` and `RedstoneConsumerBytesBase` instead\n */\nabstract contract RedstoneConsumerBase is CalldataExtractor {\n\n  error GetDataServiceIdNotImplemented();\n\n  /* ========== VIRTUAL FUNCTIONS (MAY BE OVERRIDDEN IN CHILD CONTRACTS) ========== */\n\n  /**\n   * @dev This function must be implemented by the child consumer contract.\n   * It should return dataServiceId which DataServiceWrapper will use if not provided explicitly .\n   * If not overridden, value will always have to be provided explicitly in DataServiceWrapper.\n   * @return dataServiceId being consumed by contract\n   */\n  function getDataServiceId() public view virtual returns (string memory) {\n    revert GetDataServiceIdNotImplemented();\n  }\n\n  /**\n   * @dev This function must be implemented by the child consumer contract.\n   * It should return a unique index for a given signer address if the signer\n   * is authorised, otherwise it should revert\n   * @param receivedSigner The address of a signer, recovered from ECDSA signature\n   * @return Unique index for a signer in the range [0..255]\n   */\n  function getAuthorisedSignerIndex(address receivedSigner) public view virtual returns (uint8);\n\n  /**\n   * @dev This function may be overridden by the child consumer contract.\n   * It should validate the timestamp against the current time (block.timestamp)\n   * It should revert with a helpful message if the timestamp is not valid\n   * @param receivedTimestampMilliseconds Timestamp extracted from calldata\n   */\n  function validateTimestamp(uint256 receivedTimestampMilliseconds) public view virtual {\n    RedstoneDefaultsLib.validateTimestamp(receivedTimestampMilliseconds);\n  }\n\n  /**\n   * @dev This function should be overridden by the child consumer contract.\n   * @return The minimum required value of unique authorised signers\n   */\n  function getUniqueSignersThreshold() public view virtual returns (uint8) {\n    return 1;\n  }\n\n  /**\n   * @dev This function may be overridden by the child consumer contract.\n   * It should aggregate values from different signers to a single uint value.\n   * By default, it calculates the median value\n   * @param values An array of uint256 values from different signers\n   * @return Result of the aggregation in the form of a single number\n   */\n  function aggregateValues(uint256[] memory values) public view virtual returns (uint256) {\n    return RedstoneDefaultsLib.aggregateValues(values);\n  }\n\n  /* ========== FUNCTIONS WITH IMPLEMENTATION (CAN NOT BE OVERRIDDEN) ========== */\n\n  /**\n   * @dev This is an internal helpful function for secure extraction oracle values\n   * from the tx calldata. Security is achieved by signatures verification, timestamp\n   * validation, and aggregating values from different authorised signers into a\n   * single numeric value. If any of the required conditions (e.g. packages with different \n   * timestamps or insufficient number of authorised signers) do not match, the function \n   * will revert.\n   *\n   * Note! You should not call this function in a consumer contract. You can use\n   * `getOracleNumericValuesFromTxMsg` or `getOracleNumericValueFromTxMsg` instead.\n   *\n   * @param dataFeedIds An array of unique data feed identifiers\n   * @return An array of the extracted and verified oracle values in the same order\n   * as they are requested in dataFeedIds array\n   * @return dataPackagesTimestamp timestamp equal for all data packages\n   */\n  function _securelyExtractOracleValuesAndTimestampFromTxMsg(bytes32[] memory dataFeedIds)\n    internal\n    view\n    returns (uint256[] memory, uint256 dataPackagesTimestamp)\n  {\n    // Initializing helpful variables and allocating memory\n    uint256[] memory uniqueSignerCountForDataFeedIds = new uint256[](dataFeedIds.length);\n    uint256[] memory signersBitmapForDataFeedIds = new uint256[](dataFeedIds.length);\n    uint256[][] memory valuesForDataFeeds = new uint256[][](dataFeedIds.length);\n    for (uint256 i = 0; i < dataFeedIds.length;) {\n      // The line below is commented because newly allocated arrays are filled with zeros\n      // But we left it for better readability\n      // signersBitmapForDataFeedIds[i] = 0; // <- setting to an empty bitmap\n      valuesForDataFeeds[i] = new uint256[](getUniqueSignersThreshold());\n      unchecked {\n        i++;\n      }\n    }\n\n    // Extracting the number of data packages from calldata\n    uint256 calldataNegativeOffset = _extractByteSizeOfUnsignedMetadata();\n    uint256 dataPackagesCount;\n    (dataPackagesCount, calldataNegativeOffset) = _extractDataPackagesCountFromCalldata(calldataNegativeOffset);\n\n    // Saving current free memory pointer\n    uint256 freeMemPtr;\n    assembly {\n      freeMemPtr := mload(FREE_MEMORY_PTR)\n    }\n\n    // Data packages extraction in a loop\n    for (uint256 dataPackageIndex = 0; dataPackageIndex < dataPackagesCount;) {\n      // Extract data package details and update calldata offset\n      uint256 dataPackageTimestamp;\n      (calldataNegativeOffset, dataPackageTimestamp) = _extractDataPackage(\n        dataFeedIds,\n        uniqueSignerCountForDataFeedIds,\n        signersBitmapForDataFeedIds,\n        valuesForDataFeeds,\n        calldataNegativeOffset\n      );\n\n      if (dataPackageTimestamp == 0) {\n        revert DataTimestampCannotBeZero();\n      }\n\n      if (dataPackageTimestamp != dataPackagesTimestamp && dataPackagesTimestamp != 0) {\n        revert TimestampsMustBeEqual();\n      }\n\n      dataPackagesTimestamp = dataPackageTimestamp;\n\n      // Shifting memory pointer back to the \"safe\" value\n      assembly {\n        mstore(FREE_MEMORY_PTR, freeMemPtr)\n      }\n      unchecked {\n        dataPackageIndex++;\n      }\n    }\n\n    // Validating numbers of unique signers and calculating aggregated values for each dataFeedId\n    return (_getAggregatedValues(valuesForDataFeeds, uniqueSignerCountForDataFeedIds), dataPackagesTimestamp);\n  }\n\n  /**\n   * @dev This is a private helpful function, which extracts data for a data package based\n   * on the given negative calldata offset, verifies them, and in the case of successful\n   * verification updates the corresponding data package values in memory\n   *\n   * @param dataFeedIds an array of unique data feed identifiers\n   * @param uniqueSignerCountForDataFeedIds an array with the numbers of unique signers\n   * for each data feed\n   * @param signersBitmapForDataFeedIds an array of signer bitmaps for data feeds\n   * @param valuesForDataFeeds 2-dimensional array, valuesForDataFeeds[i][j] contains\n   * j-th value for the i-th data feed\n   * @param calldataNegativeOffset negative calldata offset for the given data package\n   *\n   * @return nextCalldataNegativeOffset negative calldata offset for the next data package\n   * @return dataPackageTimestamp data package timestamp\n   */\n  function _extractDataPackage(\n    bytes32[] memory dataFeedIds,\n    uint256[] memory uniqueSignerCountForDataFeedIds,\n    uint256[] memory signersBitmapForDataFeedIds,\n    uint256[][] memory valuesForDataFeeds,\n    uint256 calldataNegativeOffset\n  ) private view returns (uint256 nextCalldataNegativeOffset, uint256 dataPackageTimestamp) {\n    uint256 signerIndex;\n\n    (\n      uint256 dataPointsCount,\n      uint256 eachDataPointValueByteSize\n    ) = _extractDataPointsDetailsForDataPackage(calldataNegativeOffset);\n\n    // We use scopes to resolve problem with too deep stack\n    {\n      address signerAddress;\n      bytes32 signedHash;\n      bytes memory signedMessage;\n      uint256 signedMessageBytesCount;\n      uint48 extractedTimestamp;\n\n      signedMessageBytesCount = dataPointsCount * (eachDataPointValueByteSize + DATA_POINT_SYMBOL_BS)\n        + DATA_PACKAGE_WITHOUT_DATA_POINTS_AND_SIG_BS; //DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS\n\n      uint256 timestampCalldataOffset = msg.data.length - \n        (calldataNegativeOffset + TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS);\n\n      uint256 signedMessageCalldataOffset = msg.data.length - \n        (calldataNegativeOffset + SIG_BS + signedMessageBytesCount);\n\n      assembly {\n        // Extracting the signed message\n        signedMessage := extractBytesFromCalldata(\n          signedMessageCalldataOffset,\n          signedMessageBytesCount\n        )\n\n        // Hashing the signed message\n        signedHash := keccak256(add(signedMessage, BYTES_ARR_LEN_VAR_BS), signedMessageBytesCount)\n\n        // Extracting timestamp\n        extractedTimestamp := calldataload(timestampCalldataOffset)\n\n        function initByteArray(bytesCount) -> ptr {\n          ptr := mload(FREE_MEMORY_PTR)\n          mstore(ptr, bytesCount)\n          ptr := add(ptr, BYTES_ARR_LEN_VAR_BS)\n          mstore(FREE_MEMORY_PTR, add(ptr, bytesCount))\n        }\n\n        function extractBytesFromCalldata(offset, bytesCount) -> extractedBytes {\n          let extractedBytesStartPtr := initByteArray(bytesCount)\n          calldatacopy(\n            extractedBytesStartPtr,\n            offset,\n            bytesCount\n          )\n          extractedBytes := sub(extractedBytesStartPtr, BYTES_ARR_LEN_VAR_BS)\n        }\n      }\n\n      dataPackageTimestamp = extractedTimestamp;\n\n      // Verifying the off-chain signature against on-chain hashed data\n      signerAddress = SignatureLib.recoverSignerAddress(\n        signedHash,\n        calldataNegativeOffset + SIG_BS\n      );\n      signerIndex = getAuthorisedSignerIndex(signerAddress);\n    }\n\n    // Updating helpful arrays\n    {\n      calldataNegativeOffset = calldataNegativeOffset + DATA_PACKAGE_WITHOUT_DATA_POINTS_BS;\n      bytes32 dataPointDataFeedId;\n      uint256 dataPointValue;\n      for (uint256 dataPointIndex = 0; dataPointIndex < dataPointsCount;) {\n        calldataNegativeOffset = calldataNegativeOffset + eachDataPointValueByteSize + DATA_POINT_SYMBOL_BS;\n        // Extracting data feed id and value for the current data point\n        (dataPointDataFeedId, dataPointValue) = _extractDataPointValueAndDataFeedId(\n          calldataNegativeOffset,\n          eachDataPointValueByteSize\n        );\n\n        for (\n          uint256 dataFeedIdIndex = 0;\n          dataFeedIdIndex < dataFeedIds.length;\n        ) {\n          if (dataPointDataFeedId == dataFeedIds[dataFeedIdIndex]) {\n            uint256 bitmapSignersForDataFeedId = signersBitmapForDataFeedIds[dataFeedIdIndex];\n\n            if (\n              !BitmapLib.getBitFromBitmap(bitmapSignersForDataFeedId, signerIndex) && /* current signer was not counted for current dataFeedId */\n              uniqueSignerCountForDataFeedIds[dataFeedIdIndex] < getUniqueSignersThreshold()\n            ) {\n              // Add new value\n              valuesForDataFeeds[dataFeedIdIndex][uniqueSignerCountForDataFeedIds[dataFeedIdIndex]] = dataPointValue;\n\n              // Increase unique signer counter\n              uniqueSignerCountForDataFeedIds[dataFeedIdIndex]++;\n\n              // Update signers bitmap\n              signersBitmapForDataFeedIds[dataFeedIdIndex] = BitmapLib.setBitInBitmap(\n                bitmapSignersForDataFeedId,\n                signerIndex\n              );\n            }\n\n            // Breaking, as there couldn't be several indexes for the same feed ID\n            break;\n          }\n          unchecked {\n            dataFeedIdIndex++;\n          }\n        }\n        unchecked {\n           dataPointIndex++;\n        }\n      }\n    }\n\n    return (calldataNegativeOffset, dataPackageTimestamp);\n  }\n\n  /**\n   * @dev This is a private helpful function, which aggregates values from different\n   * authorised signers for the given arrays of values for each data feed\n   *\n   * @param valuesForDataFeeds 2-dimensional array, valuesForDataFeeds[i][j] contains\n   * j-th value for the i-th data feed\n   * @param uniqueSignerCountForDataFeedIds an array with the numbers of unique signers\n   * for each data feed\n   *\n   * @return An array of the aggregated values\n   */\n  function _getAggregatedValues(\n    uint256[][] memory valuesForDataFeeds,\n    uint256[] memory uniqueSignerCountForDataFeedIds\n  ) private view returns (uint256[] memory) {\n    uint256[] memory aggregatedValues = new uint256[](valuesForDataFeeds.length);\n    uint256 uniqueSignersThreshold = getUniqueSignersThreshold();\n\n    for (uint256 dataFeedIndex = 0; dataFeedIndex < valuesForDataFeeds.length; dataFeedIndex++) {\n      if (uniqueSignerCountForDataFeedIds[dataFeedIndex] < uniqueSignersThreshold) {\n        revert InsufficientNumberOfUniqueSigners(\n          uniqueSignerCountForDataFeedIds[dataFeedIndex],\n          uniqueSignersThreshold);\n      }\n      uint256 aggregatedValueForDataFeedId = aggregateValues(valuesForDataFeeds[dataFeedIndex]);\n      aggregatedValues[dataFeedIndex] = aggregatedValueForDataFeedId;\n    }\n\n    return aggregatedValues;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneConsumerNumericBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"./RedstoneConsumerBase.sol\";\n\n/**\n * @title The base contract for Redstone consumers' contracts that allows to\n * securely calculate numeric redstone oracle values\n * @author The Redstone Oracles team\n * @dev This contract can extend other contracts to allow them\n * securely fetch Redstone oracle data from transactions calldata\n */\nabstract contract RedstoneConsumerNumericBase is RedstoneConsumerBase {\n  /**\n   * @dev This function can be used in a consumer contract to securely extract an\n   * oracle value for a given data feed id. Security is achieved by\n   * signatures verification, timestamp validation, and aggregating values\n   * from different authorised signers into a single numeric value. If any of the\n   * required conditions do not match, the function will revert.\n   * Note! This function expects that tx calldata contains redstone payload in the end\n   * Learn more about redstone payload here: https://github.com/redstone-finance/redstone-oracles-monorepo/tree/main/packages/evm-connector#readme\n   * @param dataFeedId bytes32 value that uniquely identifies the data feed\n   * @return Extracted and verified numeric oracle value for the given data feed id\n   */\n  function getOracleNumericValueFromTxMsg(bytes32 dataFeedId)\n    internal\n    view\n    virtual\n    returns (uint256)\n  {\n    bytes32[] memory dataFeedIds = new bytes32[](1);\n    dataFeedIds[0] = dataFeedId;\n    return getOracleNumericValuesFromTxMsg(dataFeedIds)[0];\n  }\n\n  /**\n   * @dev This function can be used in a consumer contract to securely extract several\n   * numeric oracle values for a given array of data feed ids. Security is achieved by\n   * signatures verification, timestamp validation, and aggregating values\n   * from different authorised signers into a single numeric value. If any of the\n   * required conditions do not match, the function will revert.\n   * Note! This function expects that tx calldata contains redstone payload in the end\n   * Learn more about redstone payload here: https://github.com/redstone-finance/redstone-oracles-monorepo/tree/main/packages/evm-connector#readme\n   * @param dataFeedIds An array of unique data feed identifiers\n   * @return An array of the extracted and verified oracle values in the same order\n   * as they are requested in the dataFeedIds array\n   */\n  function getOracleNumericValuesFromTxMsg(bytes32[] memory dataFeedIds)\n    internal\n    view\n    virtual\n    returns (uint256[] memory)\n  {\n    (uint256[] memory values, uint256 timestamp) = _securelyExtractOracleValuesAndTimestampFromTxMsg(dataFeedIds);\n    validateTimestamp(timestamp);\n    return values;\n  }\n\n  /**\n   * @dev This function can be used in a consumer contract to securely extract several\n   * numeric oracle values for a given array of data feed ids. Security is achieved by\n   * signatures verification and aggregating values from different authorised signers \n   * into a single numeric value. If any of the required conditions do not match, \n   * the function will revert.\n   * Note! This function returns the timestamp of the packages (it requires it to be \n   * the same for all), but does not validate this timestamp.\n   * Note! This function expects that tx calldata contains redstone payload in the end\n   * Learn more about redstone payload here: https://github.com/redstone-finance/redstone-oracles-monorepo/tree/main/packages/evm-connector#readme\n   * @param dataFeedIds An array of unique data feed identifiers\n   * @return An array of the extracted and verified oracle values in the same order\n   * as they are requested in the dataFeedIds array and data packages timestamp\n   */\n   function getOracleNumericValuesAndTimestampFromTxMsg(bytes32[] memory dataFeedIds)\n    internal\n    view\n    virtual\n    returns (uint256[] memory, uint256)\n  {\n    return _securelyExtractOracleValuesAndTimestampFromTxMsg(dataFeedIds);\n  }\n\n  /**\n   * @dev This function works similarly to the `getOracleNumericValuesFromTxMsg` with the\n   * only difference that it allows to request oracle data for an array of data feeds\n   * that may contain duplicates\n   * \n   * @param dataFeedIdsWithDuplicates An array of data feed identifiers (duplicates are allowed)\n   * @return An array of the extracted and verified oracle values in the same order\n   * as they are requested in the dataFeedIdsWithDuplicates array\n   */\n  function getOracleNumericValuesWithDuplicatesFromTxMsg(bytes32[] memory dataFeedIdsWithDuplicates) internal view returns (uint256[] memory) {\n    // Building an array without duplicates\n    bytes32[] memory dataFeedIdsWithoutDuplicates = new bytes32[](dataFeedIdsWithDuplicates.length);\n    bool alreadyIncluded;\n    uint256 uniqueDataFeedIdsCount = 0;\n\n    for (uint256 indexWithDup = 0; indexWithDup < dataFeedIdsWithDuplicates.length; indexWithDup++) {\n      // Checking if current element is already included in `dataFeedIdsWithoutDuplicates`\n      alreadyIncluded = false;\n      for (uint256 indexWithoutDup = 0; indexWithoutDup < uniqueDataFeedIdsCount; indexWithoutDup++) {\n        if (dataFeedIdsWithoutDuplicates[indexWithoutDup] == dataFeedIdsWithDuplicates[indexWithDup]) {\n          alreadyIncluded = true;\n          break;\n        }\n      }\n\n      // Adding if not included\n      if (!alreadyIncluded) {\n        dataFeedIdsWithoutDuplicates[uniqueDataFeedIdsCount] = dataFeedIdsWithDuplicates[indexWithDup];\n        uniqueDataFeedIdsCount++;\n      }\n    }\n\n    // Overriding dataFeedIdsWithoutDuplicates.length\n    // Equivalent to: dataFeedIdsWithoutDuplicates.length = uniqueDataFeedIdsCount;\n    assembly {\n      mstore(dataFeedIdsWithoutDuplicates, uniqueDataFeedIdsCount)\n    }\n\n    // Requesting oracle values (without duplicates)\n    (uint256[] memory valuesWithoutDuplicates, uint256 timestamp) = _securelyExtractOracleValuesAndTimestampFromTxMsg(dataFeedIdsWithoutDuplicates);\n    validateTimestamp(timestamp);\n\n    // Preparing result values array\n    uint256[] memory valuesWithDuplicates = new uint256[](dataFeedIdsWithDuplicates.length);\n    for (uint256 indexWithDup = 0; indexWithDup < dataFeedIdsWithDuplicates.length; indexWithDup++) {\n      for (uint256 indexWithoutDup = 0; indexWithoutDup < dataFeedIdsWithoutDuplicates.length; indexWithoutDup++) {\n        if (dataFeedIdsWithDuplicates[indexWithDup] == dataFeedIdsWithoutDuplicates[indexWithoutDup]) {\n          valuesWithDuplicates[indexWithDup] = valuesWithoutDuplicates[indexWithoutDup];\n          break;\n        }\n      }\n    }\n\n    return valuesWithDuplicates;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneDefaultsLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"../libs/NumericArrayLib.sol\";\n\n/**\n * @title Default implementations of virtual redstone consumer base functions\n * @author The Redstone Oracles team\n */\nlibrary RedstoneDefaultsLib {\n  uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS = 3 minutes;\n  uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_AHEAD_SECONDS = 1 minutes;\n\n  error TimestampFromTooLongFuture(uint256 receivedTimestampSeconds, uint256 blockTimestamp);\n  error TimestampIsTooOld(uint256 receivedTimestampSeconds, uint256 blockTimestamp);\n\n  function validateTimestamp(uint256 receivedTimestampMilliseconds) internal view {\n    // Getting data timestamp from future seems quite unlikely\n    // But we've already spent too much time with different cases\n    // Where block.timestamp was less than dataPackage.timestamp.\n    // Some blockchains may case this problem as well.\n    // That's why we add MAX_BLOCK_TIMESTAMP_DELAY\n    // and allow data \"from future\" but with a small delay\n    uint256 receivedTimestampSeconds = receivedTimestampMilliseconds / 1000;\n\n    if (block.timestamp < receivedTimestampSeconds) {\n      if ((receivedTimestampSeconds - block.timestamp) > DEFAULT_MAX_DATA_TIMESTAMP_AHEAD_SECONDS) {\n        revert TimestampFromTooLongFuture(receivedTimestampSeconds, block.timestamp);\n      }\n    } else if ((block.timestamp - receivedTimestampSeconds) > DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS) {\n      revert TimestampIsTooOld(receivedTimestampSeconds, block.timestamp);\n    }\n  }\n\n  function aggregateValues(uint256[] memory values) internal pure returns (uint256) {\n    return NumericArrayLib.pickMedian(values);\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/data-services/PrimaryProdDataServiceConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"../core/RedstoneConsumerNumericBase.sol\";\n\ncontract PrimaryProdDataServiceConsumerBase is RedstoneConsumerNumericBase {\n  function getDataServiceId() public view virtual override returns (string memory) {\n    return \"redstone-primary-prod\";\n  }\n\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 3;\n  }\n\n  function getAuthorisedSignerIndex(\n    address signerAddress\n  ) public view virtual override returns (uint8) {\n    if (signerAddress == 0x8BB8F32Df04c8b654987DAaeD53D6B6091e3B774) {\n      return 0;\n    } else if (signerAddress == 0xdEB22f54738d54976C4c0fe5ce6d408E40d88499) {\n      return 1;\n    } else if (signerAddress == 0x51Ce04Be4b3E32572C4Ec9135221d0691Ba7d202) {\n      return 2;\n    } else if (signerAddress == 0xDD682daEC5A90dD295d14DA4b0bec9281017b5bE) {\n      return 3;\n    } else if (signerAddress == 0x9c5AE89C4Af6aA32cE58588DBaF90d18a855B6de) {\n      return 4;\n    } else {\n      revert SignerNotAuthorised(signerAddress);\n    }\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/libs/BitmapLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nlibrary BitmapLib {\n  function setBitInBitmap(uint256 bitmap, uint256 bitIndex) internal pure returns (uint256) {\n    return bitmap | (1 << bitIndex);\n  }\n\n  function getBitFromBitmap(uint256 bitmap, uint256 bitIndex) internal pure returns (bool) {\n    uint256 bitAtIndex = bitmap & (1 << bitIndex);\n    return bitAtIndex > 0;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/libs/NumericArrayLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nlibrary NumericArrayLib {\n  // This function sort array in memory using bubble sort algorithm,\n  // which performs even better than quick sort for small arrays\n\n  uint256 constant BYTES_ARR_LEN_VAR_BS = 32;\n  uint256 constant UINT256_VALUE_BS = 32;\n\n  error CanNotPickMedianOfEmptyArray();\n\n  // This function modifies the array\n  function pickMedian(uint256[] memory arr) internal pure returns (uint256) {\n    if (arr.length == 2) {\n      return (arr[0] + arr[1]) / 2;\n    }\n    if (arr.length == 0) {\n      revert CanNotPickMedianOfEmptyArray();\n    }\n    sort(arr);\n    uint256 middleIndex = arr.length / 2;\n    if (arr.length % 2 == 0) {\n      uint256 sum = arr[middleIndex - 1] + arr[middleIndex];\n      return sum / 2;\n    } else {\n      return arr[middleIndex];\n    }\n  }\n\n  function sort(uint256[] memory arr) internal pure {\n    assembly {\n      let arrLength := mload(arr)\n      let valuesPtr := add(arr, BYTES_ARR_LEN_VAR_BS)\n      let endPtr := add(valuesPtr, mul(arrLength, UINT256_VALUE_BS))\n      for {\n        let arrIPtr := valuesPtr\n      } lt(arrIPtr, endPtr) {\n        arrIPtr := add(arrIPtr, UINT256_VALUE_BS) // arrIPtr += 32\n      } {\n        for {\n          let arrJPtr := valuesPtr\n        } lt(arrJPtr, arrIPtr) {\n          arrJPtr := add(arrJPtr, UINT256_VALUE_BS) // arrJPtr += 32\n        } {\n          let arrI := mload(arrIPtr)\n          let arrJ := mload(arrJPtr)\n          if lt(arrI, arrJ) {\n            mstore(arrIPtr, arrJ)\n            mstore(arrJPtr, arrI)\n          }\n        }\n      }\n    }\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/libs/SignatureLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nlibrary SignatureLib {\n  uint256 constant ECDSA_SIG_R_BS = 32;\n  uint256 constant ECDSA_SIG_S_BS = 32;\n\n  function recoverSignerAddress(bytes32 signedHash, uint256 signatureCalldataNegativeOffset)\n    internal\n    pure\n    returns (address)\n  {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n    assembly {\n      let signatureCalldataStartPos := sub(calldatasize(), signatureCalldataNegativeOffset)\n      r := calldataload(signatureCalldataStartPos)\n      signatureCalldataStartPos := add(signatureCalldataStartPos, ECDSA_SIG_R_BS)\n      s := calldataload(signatureCalldataStartPos)\n      signatureCalldataStartPos := add(signatureCalldataStartPos, ECDSA_SIG_S_BS)\n      v := byte(0, calldataload(signatureCalldataStartPos)) // last byte of the signature memory array\n    }\n    return ecrecover(signedHash, v, r, s);\n  }\n}\n"
    },
    "@umb-network/toolbox/dist/contracts/IChain.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.8;\npragma abicoder v2;\n\ninterface IChain {\n  struct Block {\n    bytes32 root;\n    uint32 dataTimestamp;\n  }\n\n  struct FirstClassData {\n    uint224 value;\n    uint32 dataTimestamp;\n  }\n\n  function isForeign() external pure returns (bool);\n\n  function blocks(uint256) external view returns (Block memory);\n\n  function fcds(bytes32) external view returns (FirstClassData memory);\n\n  function blocksCount() external view returns (uint32);\n\n  function blocksCountOffset() external view returns (uint32);\n\n  function padding() external view returns (uint16);\n\n  function getName() external pure returns (bytes32);\n\n  function recoverSigner(bytes32 affidavit, uint8 _v, bytes32 _r, bytes32 _s) external pure returns (address);\n\n  function getStatus() external view returns(\n    uint256 blockNumber,\n    uint16 timePadding,\n    uint32 lastDataTimestamp,\n    uint32 lastBlockId,\n    address nextLeader,\n    uint32 nextBlockId,\n    address[] memory validators,\n    uint256[] memory powers,\n    string[] memory locations,\n    uint256 staked\n  );\n\n  function getBlockId() external view returns (uint32);\n\n  // this function does not works for past timestamps\n  function getBlockIdAtTimestamp(uint256 _timestamp) external view returns (uint32);\n\n  function getLatestBlockId() external view returns (uint32);\n\n  function getLeaderIndex(uint256 _numberOfValidators, uint256 _timestamp) external view returns (uint256);\n\n  function getNextLeaderAddress() external view returns (address);\n\n  function getLeaderAddress() external view returns (address);\n\n  function getLeaderAddressAtTime(uint232 _timestamp) external view returns (address);\n\n  function hashLeaf(bytes calldata _key, bytes calldata _value) external pure returns (bytes32);\n\n  function verifyProof(bytes32[] calldata _proof, bytes32 _root, bytes32 _leaf) external pure returns (bool);\n\n  function verifyProofForBlock(\n    uint256 _blockId,\n    bytes32[] calldata _proof,\n    bytes calldata _key,\n    bytes calldata _value\n  ) external view returns (bool);\n\n  function bytesToBytes32Array(\n    bytes calldata _data,\n    uint256 _offset,\n    uint256 _items\n  ) external pure returns (bytes32[] memory);\n\n  function verifyProofs(\n    uint32[] memory _blockIds,\n    bytes memory _proofs,\n    uint256[] memory _proofItemsCounter,\n    bytes32[] memory _leaves\n  ) external view returns (bool[] memory results);\n  \n  function getBlockRoot(uint256 _blockId) external view returns (bytes32);\n\n  function getBlockTimestamp(uint32 _blockId) external view returns (uint32);\n\n  function getCurrentValues(bytes32[] calldata _keys)\n  external view returns (uint256[] memory values, uint32[] memory timestamps);\n\n  function getCurrentValue(bytes32 _key) external view returns (uint256 value, uint256 timestamp);\n}\n"
    },
    "@umb-network/toolbox/dist/contracts/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.8;\n\ninterface IRegistry {\n  function registry(bytes32 _name) external view returns (address);\n\n  function requireAndGetAddress(bytes32 _name) external view returns (address);\n\n  function getAddress(bytes32 _bytes) external view returns (address);\n\n  function getAddressByString(string memory _name) external view returns (address);\n\n  function stringToBytes32(string memory _string) external pure returns (bytes32);\n}\n"
    },
    "@uniswap/lib/contracts/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n        // else z = 0\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\nimport './Babylonian.sol';\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n    uint private constant Q112 = uint(1) << RESOLUTION;\n    uint private constant Q224 = Q112 << RESOLUTION;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\n        return uq112x112(self._x / uint224(x));\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\n        uint z;\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\n        return uq144x112(z);\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // equivalent to encode(numerator).div(denominator)\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n\n    // take the reciprocal of a UQ112x112\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        require(self._x != 0, 'FixedPoint: ZERO_RECIPROCAL');\n        return uq112x112(uint224(Q224 / self._x));\n    }\n\n    // square root of a UQ112x112\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x)) << 56));\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol": {
      "content": "pragma solidity >=0.5.0;\n\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport '@uniswap/lib/contracts/libraries/FixedPoint.sol';\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n    using FixedPoint for *;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2 ** 32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(\n        address pair\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n            // counterfactual\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n        }\n    }\n}\n"
    },
    "contracts/access/Governable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/core/IAddressProvider.sol\";\n\n/**\n * @notice Contract module which provides access control mechanism, where\n * the governor account is granted with exclusive access to specific functions.\n * @dev Uses the AddressProvider to get the governor\n */\nabstract contract Governable {\n    IAddressProvider public constant addressProvider = IAddressProvider(0xfbA0816A81bcAbBf3829bED28618177a2bf0e82A);\n\n    /// @dev Throws if called by any account other than the governor.\n    modifier onlyGovernor() {\n        require(msg.sender == addressProvider.governor(), \"not-governor\");\n        _;\n    }\n}\n"
    },
    "contracts/core/ChainlinkAvalanchePriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./ChainlinkPriceProvider.sol\";\n\n/**\n * @title ChainLink's price provider for Avalanche network\n */\ncontract ChainlinkAvalanchePriceProvider is ChainlinkPriceProvider {\n    constructor() {\n        // Avalanche's aggregators: https://docs.chain.link/docs/avalanche-price-feeds/\n        _setAggregator(0x63a72806098Bd3D9520cC43356dD78afe5D386D9, AggregatorV3Interface(0x3CA13391E9fb38a75330fb28f8cc2eB3D9ceceED)); // AAVE.e\n        _setAggregator(0x2147EFFF675e4A4eE1C2f918d181cDBd7a8E208f, AggregatorV3Interface(0x7B0ca9A6D03FE0467A31Ca850f5bcA51e027B3aF)); // ALPHA.e\n        _setAggregator(0x027dbcA046ca156De9622cD1e2D907d375e53aa7, AggregatorV3Interface(0xcf667FB6Bd30c520A435391c50caDcDe15e5e12f)); // AMPL\n        _setAggregator(0x19860CCB0A68fd4213aB9D8266F7bBf05A8dDe98, AggregatorV3Interface(0x827f8a0dC5c943F7524Dda178E2e7F275AAd743f)); // BUSD.e\n        _setAggregator(0x249848BeCA43aC405b8102Ec90Dd5F22CA513c06, AggregatorV3Interface(0x7CF8A6090A9053B01F3DF4D4e6CfEdd8c90d9027)); // CRV.e\n        _setAggregator(0xd586E7F844cEa2F87f50152665BCbc2C279D8d70, AggregatorV3Interface(0x51D7180edA2260cc4F6e4EebB82FEF5c3c2B8300)); // DAI.e\n        _setAggregator(0x6e84a6216eA6dACC71eE8E6b0a5B7322EEbC0fDd, AggregatorV3Interface(0x02D35d3a8aC3e1626d3eE09A78Dd87286F5E8e3a)); // JOE\n        _setAggregator(0x5947BB275c521040051D82396192181b413227A3, AggregatorV3Interface(0x49ccd9ca821EfEab2b98c60dC60F518E765EDe9a)); // LINK.e\n        _setAggregator(0x130966628846BFd36ff31a822705796e8cb8C18D, AggregatorV3Interface(0x54EdAB30a7134A16a54218AE64C73e1DAf48a8Fb)); // MIM\n        _setAggregator(0x8729438EB15e2C8B576fCc6AeCdA6A148776C0F5, AggregatorV3Interface(0x36E039e6391A5E7A7267650979fdf613f659be5D)); // QI\n        _setAggregator(0xCE1bFFBD5374Dac86a2893119683F4911a2F7814, AggregatorV3Interface(0x4F3ddF9378a4865cf4f28BE51E10AECb83B7daeE)); // SPELL\n        _setAggregator(0x37B608519F91f70F2EeB0e5Ed9AF4061722e4F76, AggregatorV3Interface(0x449A373A090d8A1e5F74c63Ef831Ceff39E94563)); // SUSHI.e\n        _setAggregator(0x1C20E891Bab6b1727d14Da358FAe2984Ed9B59EB, AggregatorV3Interface(0x9Cf3Ef104A973b351B2c032AA6793c3A6F76b448)); // TUSD\n        _setAggregator(0x8eBAf22B6F053dFFeaf46f4Dd9eFA95D89ba8580, AggregatorV3Interface(0x9a1372f9b1B71B3A5a72E092AE67E172dBd7Daaa)); // UNI.e\n        _setAggregator(0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664, AggregatorV3Interface(0xF096872672F44d6EBA71458D74fe67F9a77a23B9)); // USDC.e\n        _setAggregator(0xc7198437980c041c805A1EDcbA50c1Ce5db95118, AggregatorV3Interface(0xEBE676ee90Fe1112671f19b6B7459bC678B67e8a)); // USDT.e\n        _setAggregator(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7, AggregatorV3Interface(0x0A77230d17318075983913bC2145DB16C7366156)); // WAVAX\n        _setAggregator(0x50b7545627a5162F82A992c33b87aDc75187B218, AggregatorV3Interface(0x2779D32d5166BAaa2B2b658333bA7e6Ec0C65743)); // WBTC.e\n        _setAggregator(0x49D5c2BdFfac6CE2BFdB6640F4F80f226bc10bAB, AggregatorV3Interface(0x976B3D034E162d8bD72D6b9C989d545b839003b0)); // WETH.e\n        _setAggregator(0xd1c3f94DE7e5B45fa4eDBBA472491a9f4B166FC4, AggregatorV3Interface(0x4Cf57DC9028187b9DAaF773c8ecA941036989238)); // XAVA\n        _setAggregator(0x9eAaC1B23d935365bD7b542Fe22cEEe2922f52dc, AggregatorV3Interface(0x28043B1Ebd41860B93EC1F1eC19560760B6dB556)); // YFI.e\n    }\n}\n"
    },
    "contracts/core/ChainlinkBasePriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./ChainlinkPriceProvider.sol\";\n\n/**\n * @title Chainlink's price provider for optimism network\n */\ncontract ChainlinkBasePriceProvider is ChainlinkPriceProvider {\n    constructor() {\n        // optimism aggregators: https://docs.chain.link/data-feeds/price-feeds/addresses?network=base\n        // Note: These are NOT all available aggregators, not adding them all to avoid too expensive deployment cost\n        _setAggregator(0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913, AggregatorV3Interface(0x7e860098F58bBFC8648a4311b374B1D669a2bc6B)); // USDC\n        _setAggregator(0x3932FBCB64859BA68cD3eA5B2a2694Fe1daF4F03, AggregatorV3Interface(0xCCADC697c55bbB68dc5bCdf8d3CBe83CdD4E071E)); // WBTC\n        _setAggregator(0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb, AggregatorV3Interface(0x591e79239a7d679378eC8c847e5038150364C78F)); // DAI\n        _setAggregator(0x4200000000000000000000000000000000000006, AggregatorV3Interface(0x71041dddad3595F9CEd3DcCFBe3D1F4b0a16Bb70)); // WETH               \n    }\n}\n"
    },
    "contracts/core/ChainlinkFeedPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol\";\nimport \"./ChainlinkPriceProvider.sol\";\nimport \"../libraries/OracleHelpers.sol\";\n\n/**\n * @title ChainLink's price provider that uses price feed (only available on Mainnet currently)\n * @dev This contract is more expensive (+ ~1.3k) than others contracts (that don't use feed)\n * because they get decimals during aggregator addition\n */\ncontract ChainlinkFeedPriceProvider is ChainlinkPriceProvider {\n    using SafeCast for int256;\n    using OracleHelpers for uint256;\n\n    address public constant USD = address(840); // Chainlink follows https://en.wikipedia.org/wiki/ISO_4217\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant BTC = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\n    FeedRegistryInterface public constant PRICE_FEED =\n        FeedRegistryInterface(0x47Fb2585D2C56Fe188D0E6ec628a38b74fCeeeDf);\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(address token_) public view override returns (uint256 _priceInUsd, uint256 _lastUpdatedAt) {\n        int256 _price;\n\n        AggregatorV3Interface _aggregator = aggregators[token_];\n        if (address(_aggregator) != address(0)) {\n            (, _price, , _lastUpdatedAt, ) = _aggregator.latestRoundData();\n            return (_price.toUint256() * TO_SCALE, _lastUpdatedAt);\n        }\n\n        if (token_ == WETH) {\n            token_ = ETH;\n        } else if (token_ == WBTC) {\n            token_ = BTC;\n        }\n        (, _price, , _lastUpdatedAt, ) = PRICE_FEED.latestRoundData(token_, USD);\n        _priceInUsd = _price.toUint256().scaleDecimal(PRICE_FEED.decimals(token_, USD), USD_DECIMALS);\n    }\n}\n"
    },
    "contracts/core/ChainlinkMainnetPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol\";\nimport \"./ChainlinkPriceProvider.sol\";\nimport \"../libraries/OracleHelpers.sol\";\n\n/**\n * @title Chainlink's price provider for Mainnet network\n * @dev Not uses price feed in order to save gas\n */\ncontract ChainlinkMainnetPriceProvider is ChainlinkPriceProvider {\n    constructor() {\n        // Mainnet's aggregators: https://docs.chain.link/docs/ethereum-addresses/\n        // Note: These are NOT all available aggregators, not adding them all to avoid too expensive deployment cost\n        _setAggregator(0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9, AggregatorV3Interface(0x547a514d5e3769680Ce22B2361c10Ea13619e8a9)); // AAVE\n        _setAggregator(0x85f138bfEE4ef8e540890CFb48F620571d67Eda3, AggregatorV3Interface(0xFF3EEb22B5E3dE6e705b44749C2559d704923FD7)); // WAVAX\n        _setAggregator(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599, AggregatorV3Interface(0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c)); // WBTC\n        _setAggregator(0xc00e94Cb662C3520282E6f5717214004A7f26888, AggregatorV3Interface(0xdbd020CAeF83eFd542f4De03e3cF0C28A4428bd5)); // COMP\n        _setAggregator(0xD533a949740bb3306d119CC777fa900bA034cd52, AggregatorV3Interface(0xCd627aA160A6fA45Eb793D19Ef54f5062F20f33f)); // CRV\n        _setAggregator(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B, AggregatorV3Interface(0xd962fC30A72A84cE50161031391756Bf2876Af5D)); // CVX\n        _setAggregator(0x6B175474E89094C44Da98b954EedeAC495271d0F, AggregatorV3Interface(0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9)); // DAI\n        _setAggregator(0x1494CA1F11D487c2bBe4543E90080AeBa4BA3C2b, AggregatorV3Interface(0xD2A593BF7594aCE1faD597adb697b5645d5edDB2)); // DPI\n        _setAggregator(0xC18360217D8F7Ab5e7c516566761Ea12Ce7F9D72, AggregatorV3Interface(0x5C00128d4d1c2F4f652C267d7bcdD7aC99C16E16)); // ENS\n        _setAggregator(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419)); // WETH\n        _setAggregator(0x853d955aCEf822Db058eb8505911ED77F175b99e, AggregatorV3Interface(0xB9E1E3A9feFf48998E45Fa90847ed4D467E8BcfD)); // FRAX\n        _setAggregator(0xc944E90C64B2c07662A292be6244BDf05Cda44a7, AggregatorV3Interface(0x86cF33a451dE9dc61a2862FD94FF4ad4Bd65A5d2)); // GRT\n        _setAggregator(0x514910771AF9Ca656af840dff83E8264EcF986CA, AggregatorV3Interface(0x2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c)); // LINK\n        _setAggregator(0x7c9f4C87d911613Fe9ca58b579f737911AAD2D43, AggregatorV3Interface(0x7bAC85A8a13A4BcD8abb3eB7d6b4d632c5a57676)); // WMATIC\n        _setAggregator(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3, AggregatorV3Interface(0x7A364e8770418566e3eb2001A96116E6138Eb32F)); // MIM\n        _setAggregator(0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2, AggregatorV3Interface(0xec1D1B3b0443256cc3860e24a46F108e699484Aa)); // MKR\n        _setAggregator(0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F, AggregatorV3Interface(0xDC3EA94CD0AC27d9A86C180091e7f78C683d3699)); // SNX\n        _setAggregator(0x090185f2135308BaD17527004364eBcC2D37e5F6, AggregatorV3Interface(0x8c110B94C5f1d347fAcF5E1E938AB2db60E3c9a8)); // SPELL\n        _setAggregator(0x6B3595068778DD592e39A122f4f5a5cF09C90fE2, AggregatorV3Interface(0xCc70F09A6CC17553b2E31954cD36E4A2d89501f7)); // SUSHI\n        _setAggregator(0x0000000000085d4780B73119b644AE5ecd22b376, AggregatorV3Interface(0xec746eCF986E2927Abd291a2A1716c940100f8Ba)); // TUSD\n        _setAggregator(0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984, AggregatorV3Interface(0x553303d460EE0afB37EdFf9bE42922D8FF63220e)); // UNI\n        _setAggregator(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, AggregatorV3Interface(0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6)); // USDC\n        _setAggregator(0xdAC17F958D2ee523a2206206994597C13D831ec7, AggregatorV3Interface(0x3E7d1eAB13ad0104d2750B8863b489D65364e32D)); // USDT\n        _setAggregator(0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e, AggregatorV3Interface(0xA027702dbb89fbd58938e4324ac03B58d812b0E1)); // YFI\n    }\n}\n"
    },
    "contracts/core/ChainlinkOptimismPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./ChainlinkPriceProvider.sol\";\n\n/**\n * @title Chainlink's price provider for optimism network\n */\ncontract ChainlinkOptimismPriceProvider is ChainlinkPriceProvider {\n    constructor() {\n        // optimism aggregators: https://docs.chain.link/data-feeds/price-feeds/addresses?network=optimism\n        // Note: These are NOT all available aggregators, not adding them all to avoid too expensive deployment cost\n        _setAggregator(0x7F5c764cBc14f9669B88837ca1490cCa17c31607, AggregatorV3Interface(0x16a9FA2FDa030272Ce99B29CF780dFA30361E0f3)); // USDC\n        _setAggregator(0x68f180fcCe6836688e9084f035309E29Bf0A2095, AggregatorV3Interface(0x718A5788b89454aAE3A028AE9c111A29Be6c2a6F)); // WBTC\n        _setAggregator(0x4200000000000000000000000000000000000042, AggregatorV3Interface(0x0D276FC14719f9292D5C1eA2198673d1f4269246)); // OP\n        _setAggregator(0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1, AggregatorV3Interface(0x8dBa75e83DA73cc766A7e5a0ee71F656BAb470d6)); // DAI\n        _setAggregator(0x4200000000000000000000000000000000000006, AggregatorV3Interface(0x13e3Ee699D1909E989722E753853AE30b17e08c5)); // WETH               \n    }\n}\n"
    },
    "contracts/core/ChainlinkPolygonPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./ChainlinkPriceProvider.sol\";\n\n/**\n * @title Chainlink's price provider for Polygon network\n */\ncontract ChainlinkPolygonPriceProvider is ChainlinkPriceProvider {\n    constructor() {\n        // Polygon's aggregators: https://docs.chain.link/docs/matic-addresses/\n        _setAggregator(0x9c2C5fd7b07E95EE044DDeba0E97a665F142394f, AggregatorV3Interface(0x443C5116CdF663Eb387e72C688D276e702135C87)); // 1INCH\n        _setAggregator(0xD6DF932A45C0f255f85145f286eA0b292B21C90B, AggregatorV3Interface(0x72484B12719E23115761D5DA1646945632979bB6)); // AAVE\n        _setAggregator(0x3Cef98bb43d732E2F285eE605a8158cDE967D219, AggregatorV3Interface(0x2346Ce62bd732c62618944E51cbFa09D985d86D2)); // BAT\n        _setAggregator(0x3BA4c387f786bFEE076A58914F5Bd38d668B42c3, AggregatorV3Interface(0x82a6c4AF830caa6c97bb504425f6A66165C2c26e)); // BNB\n        _setAggregator(0xc26D47d5c33aC71AC5CF9F776D63Ba292a4F7842, AggregatorV3Interface(0xF5724884b6E99257cC003375e6b844bC776183f9)); // BNT\n        _setAggregator(0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6, AggregatorV3Interface(0xc907E116054Ad103354f2D350FD2514433D57F6f)); // WBTC\n        _setAggregator(0xD85d1e945766Fea5Eda9103F918Bd915FbCa63E6, AggregatorV3Interface(0xc9ECF45956f576681bDc01F79602A79bC2667B0c)); // CEL\n        _setAggregator(0xf1938Ce12400f9a761084E7A80d37e732a4dA056, AggregatorV3Interface(0x2409987e514Ad8B0973C2b90ee1D95051DF0ECB9)); // CHZ\n        _setAggregator(0x8505b9d2254A7Ae468c0E9dd10Ccea3A837aef5c, AggregatorV3Interface(0x2A8758b7257102461BC958279054e372C2b1bDE6)); // COMP\n        _setAggregator(0x172370d5Cd63279eFa6d502DAB29171933a610AF, AggregatorV3Interface(0x336584C8E6Dc19637A5b36206B1c79923111b405)); // CRV\n        _setAggregator(0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063, AggregatorV3Interface(0x4746DeC9e833A82EC7C2C1356372CcF2cfcD2F3D)); // DAI\n        _setAggregator(0x7eC26842F195c852Fa843bB9f6D8B583a274a157, AggregatorV3Interface(0x440A341bbC9FA86aA60A195e2409a547e48d4C0C)); // ENJ\n        _setAggregator(0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619, AggregatorV3Interface(0xF9680D99D6C9589e2a93a78A04A279e509205945)); // WETH\n        _setAggregator(0x45c32fA6DF82ead1e2EF74d17b76547EDdFaFF89, AggregatorV3Interface(0x00DBeB1e45485d53DF7C2F0dF1Aa0b6Dc30311d3)); // FRAX\n        _setAggregator(0xC9c1c1c20B3658F8787CC2FD702267791f224Ce1, AggregatorV3Interface(0x58326c0F831b2Dbf7234A4204F28Bba79AA06d5f)); // FTM\n        _setAggregator(0x1a3acf6D19267E2d3e7f898f42803e90C9219062, AggregatorV3Interface(0x6C0fe985D3cAcbCdE428b84fc9431792694d0f51)); // FXS\n        _setAggregator(0x385Eeac5cB85A38A9a07A70c73e0a3271CfB54A7, AggregatorV3Interface(0xDD229Ce42f11D8Ee7fFf29bDB71C7b81352e11be)); // GHST\n        _setAggregator(0x5FFD62D3C3eE2E81C00A7b9079FB248e7dF024A8, AggregatorV3Interface(0x432fa0899cF1BcDb98592D7eAA23C372b8b8ddf2)); // GNO\n        _setAggregator(0x5fe2B58c013d7601147DcdD68C143A77499f5531, AggregatorV3Interface(0x3FabBfb300B1e2D7c9B84512fe9D30aeDF24C410)); // GRT\n        _setAggregator(0xFAD65Eb62a97fF5Ed91B23aFD039956aaCa6e93b, AggregatorV3Interface(0x6F8F9e75C0285AecE30ADFe1BCc1955f145d971A)); // HT\n        _setAggregator(0x42f37A1296b2981F7C3cAcEd84c5096b2Eb0C72C, AggregatorV3Interface(0x5438E60A06C7447432512264Fa57e2FeD3224b33)); // KEEP\n        _setAggregator(0x1C954E8fe737F99f68Fa1CCda3e51ebDB291948C, AggregatorV3Interface(0x10e5f3DFc81B3e5Ef4e648C4454D04e79E1E41E2)); // KNC\n        _setAggregator(0x53E0bca35eC356BD5ddDFebbD1Fc0fD03FaBad39, AggregatorV3Interface(0xd9FFdb71EbE7496cC440152d43986Aae0AB76665)); // LINK\n        _setAggregator(0x3962F4A0A0051DccE0be73A7e09cEf5756736712, AggregatorV3Interface(0xBAaF11CeDA1d1Ca9Cf01748F8196653c9656a400)); // LPT\n        _setAggregator(0xA1c57f48F0Deb89f569dFbE6E2B7f46D33606fD4, AggregatorV3Interface(0xA1CbF3Fe43BC3501e3Fc4b573e822c70e76A7512)); // MANA\n        _setAggregator(0x6f7C932e7684666C9fd1d44527765433e01fF61d, AggregatorV3Interface(0xa070427bF5bA5709f70e98b94Cb2F435a242C46C)); // MKR\n        _setAggregator(0x41b3966B4FF7b427969ddf5da3627d6AEAE9a48E, AggregatorV3Interface(0x666bb13b3ED3816504E8c30D0F9B9C16b371774b)); // NEXO\n        _setAggregator(0x282d8efCe846A88B159800bd4130ad77443Fa1A1, AggregatorV3Interface(0xdcda79097C44353Dee65684328793695bd34A629)); // OCEAN\n        _setAggregator(0x62414D03084EeB269E18C970a21f45D2967F0170, AggregatorV3Interface(0x93FfEE768F74208a7b9f2a4426f0F6BCbb1D09de)); // OMG\n        _setAggregator(0x6F3B3286fd86d8b47EC737CEB3D0D354cc657B3e, AggregatorV3Interface(0x56D55D34EcC616e71ae998aCcba79F236ff2ff46)); // PAX\n        _setAggregator(0x553d3D295e0f695B9228246232eDF400ed3560B5, AggregatorV3Interface(0x0f6914d8e7e1214CDb3A4C6fbf729b75C69DF608)); // PAXG\n        _setAggregator(0xcB059C5573646047D6d88dDdb87B745C18161d3b, AggregatorV3Interface(0xC741F7752BAe936fCE97933b755884AF66fB69C1)); // POLY\n        _setAggregator(0xBbba073C31bF03b8ACf7c28EF0738DeCF3695683, AggregatorV3Interface(0x3D49406EDd4D52Fb7FFd25485f32E073b529C924)); // SAND\n        _setAggregator(0x50B728D8D964fd00C2d0AAD81718b71311feF68a, AggregatorV3Interface(0xbF90A5D9B6EE9019028dbFc2a9E50056d5252894)); // SNX\n        _setAggregator(0x6Bf2eb299E51Fc5DF30Dec81D9445dDe70e3F185, AggregatorV3Interface(0xd8F8a7a38A1ac326312000d0a0218BF3216BfAbB)); // SRM\n        _setAggregator(0x0b3F868E0BE5597D5DB7fEB59E1CADBb0fdDa50a, AggregatorV3Interface(0x49B0c695039243BBfEb8EcD054EB70061fd54aa0)); // SUSHI\n        _setAggregator(0xB46E0ae620EFd98516f49bb00263317096C114b2, AggregatorV3Interface(0x38611b09F8f2D520c14eA973765C225Bf57B9Eac)); // THETA\n        _setAggregator(0x2e1AD108fF1D8C782fcBbB89AAd783aC49586756, AggregatorV3Interface(0x7C5D415B64312D38c56B54358449d0a4058339d2)); // TUSD\n        _setAggregator(0x3066818837c5e6eD6601bd5a91B0762877A6B731, AggregatorV3Interface(0x33D9B1BAaDcF4b26ab6F8E83e9cb8a611B2B3956)); // UMA\n        _setAggregator(0xb33EaAd8d922B1083446DC23f610c2567fB5180f, AggregatorV3Interface(0xdf0Fb4e4F928d2dCB76f438575fDD8682386e13C)); // UNI\n        _setAggregator(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174, AggregatorV3Interface(0xfE4A8cc5b5B2366C1B58Bea3858e81843581b2F7)); // USDC\n        _setAggregator(0xc2132D05D31c914a87C6611C10748AEb04B58e8F, AggregatorV3Interface(0x0A6513e40db6EB1b165753AD52E80663aeA50545)); // USDT\n        _setAggregator(0xDA537104D6A5edd53c6fBba9A898708E465260b6, AggregatorV3Interface(0x9d3A43c111E7b2C6601705D9fcF7a70c95b1dc55)); // YFI\n        _setAggregator(0x5559Edb74751A0edE9DeA4DC23aeE72cCA6bE3D5, AggregatorV3Interface(0x6EA4d89474d9410939d429B786208c74853A5B47)); // ZRX\n    }\n}\n"
    },
    "contracts/core/ChainlinkPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../interfaces/core/IChainlinkPriceProvider.sol\";\nimport \"./PriceProvider.sol\";\nimport \"../access/Governable.sol\";\n\n/**\n * @title ChainLink's price provider\n * @dev This contract wraps chainlink aggregators\n */\ncontract ChainlinkPriceProvider is IChainlinkPriceProvider, PriceProvider, Governable {\n    using SafeCast for int256;\n\n    uint256 public constant CHAINLINK_DECIMALS = 8;\n    uint256 public constant TO_SCALE = 10**(USD_DECIMALS - CHAINLINK_DECIMALS);\n\n    /**\n     * @notice Aggregators map (token => aggregator)\n     */\n    mapping(address => AggregatorV3Interface) public aggregators;\n\n    /// Emitted when an aggregator is updated\n    event AggregatorUpdated(address token, AggregatorV3Interface oldAggregator, AggregatorV3Interface newAggregator);\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(address token_)\n        public\n        view\n        virtual\n        override(IPriceProvider, PriceProvider)\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        AggregatorV3Interface _aggregator = aggregators[token_];\n        require(address(_aggregator) != address(0), \"token-without-aggregator\");\n        int256 _price;\n        (, _price, , _lastUpdatedAt, ) = _aggregator.latestRoundData();\n        return (_price.toUint256() * TO_SCALE, _lastUpdatedAt);\n    }\n\n    /// @inheritdoc IChainlinkPriceProvider\n    function updateAggregator(address token_, AggregatorV3Interface aggregator_) external override onlyGovernor {\n        require(token_ != address(0), \"token-is-null\");\n        AggregatorV3Interface _current = aggregators[token_];\n        require(aggregator_ != _current, \"same-as-current\");\n        _setAggregator(token_, aggregator_);\n        emit AggregatorUpdated(token_, _current, aggregator_);\n    }\n\n    function _setAggregator(address token_, AggregatorV3Interface aggregator_) internal {\n        require(address(aggregator_) == address(0) || aggregator_.decimals() == CHAINLINK_DECIMALS, \"invalid-decimals\");\n        aggregators[token_] = aggregator_;\n    }\n}\n"
    },
    "contracts/core/PriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../interfaces/core/IPriceProvider.sol\";\n\n/**\n * @title Price providers' super class that implements common functions\n */\nabstract contract PriceProvider is IPriceProvider {\n    uint256 public constant USD_DECIMALS = 18;\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(address token_) public view virtual returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /// @inheritdoc IPriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        view\n        virtual\n        override\n        returns (uint256 _amountOut, uint256 _tokenInLastUpdatedAt, uint256 _tokenOutLastUpdatedAt)\n    {\n        uint256 _amountInUsd;\n        (_amountInUsd, _tokenInLastUpdatedAt) = quoteTokenToUsd(tokenIn_, amountIn_);\n        (_amountOut, _tokenOutLastUpdatedAt) = quoteUsdToToken(tokenOut_, _amountInUsd);\n    }\n\n    /// @inheritdoc IPriceProvider\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        uint256 _price;\n        (_price, _lastUpdatedAt) = getPriceInUsd(token_);\n        _amountOut = (amountIn_ * _price) / 10 ** IERC20Metadata(token_).decimals();\n    }\n\n    /// @inheritdoc IPriceProvider\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        uint256 _price;\n        (_price, _lastUpdatedAt) = getPriceInUsd(token_);\n        if (_price == 0) {\n            return (0, 0);\n        }\n        _amountOut = (amountIn_ * 10 ** IERC20Metadata(token_).decimals()) / _price;\n    }\n}\n"
    },
    "contracts/core/PythMainnetPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./PythPriceProvider.sol\";\n\n/**\n * @title Pyth's price provider with Mainnet pre-setup\n */\ncontract PythMainnetPriceProvider is PythPriceProvider {\n    constructor(IPyth pyth_) PythPriceProvider(pyth_) {\n        feedIds[0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48] = 0xeaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a; // USDC\n        feedIds[0x6B175474E89094C44Da98b954EedeAC495271d0F] = 0xb0948a5e5313200c632b51bb5ca32f6de0d36e9950a942d19751e833f70dabfd; // DAI\n        feedIds[0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2] = 0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace; // WETH\n        feedIds[0x64351fC9810aDAd17A690E4e1717Df5e7e085160] = 0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace; // msETH\n        feedIds[0x853d955aCEf822Db058eb8505911ED77F175b99e] = 0xc3d5d8d6d17081b3d0bbca6e2fa3a6704bb9a9561d9f9e1dc52db47629f862ad; // FRAX\n        feedIds[0xac3E018457B222d93114458476f3E3416Abbe38F] = 0xb2bb466ff5386a63c18aa7c3bc953cb540c755e2aa99dafb13bc4c177692bed0; // sfrxETH\n        feedIds[0xae78736Cd615f374D3085123A210448E74Fc6393] = 0xa0255134973f4fdf2f8f7808354274a3b1ebc6ee438be898d045e8b56ba1fe13; // rETH\n        feedIds[0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84] = 0x846ae1bdb6300b817cee5fdee2a6da192775030db5615b94a465f53bd40850b5; // stETH\n        feedIds[0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599] = 0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43; // WBTC\n        feedIds[0x8b4F8aD3801B4015Dea6DA1D36f063Cbf4e231c7] = 0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43; // msBTC\n        feedIds[0xBe9895146f7AF43049ca1c1AE358B0541Ea49704] = 0x15ecddd26d49e1a8f1de9376ebebc03916ede873447c1255d2d5891b92ce5717; // cbETH\n    }\n}\n"
    },
    "contracts/core/PythPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IPyth} from \"@pythnetwork/pyth-sdk-solidity/IPyth.sol\";\nimport {PythStructs} from \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {IPythPriceProvider} from \"../interfaces/core/IPythPriceProvider.sol\";\nimport {IPriceProvider, PriceProvider} from \"./PriceProvider.sol\";\nimport {Governable} from \"../access/Governable.sol\";\n\n/**\n * @title Pyth's price provider\n * @dev This contract wraps Pyth contract\n */\ncontract PythPriceProvider is IPythPriceProvider, PriceProvider, Governable {\n    using SafeCast for int256;\n    using Address for address payable;\n\n    int256 internal constant MIN_EXPONENT = -18;\n    int256 internal constant MAX_EXPONENT = 0;\n    uint256 internal constant MAX_TIME_TOLERANCE = 1 minutes;\n\n    /// @notice Pyth main contract\n    IPyth public immutable pyth;\n\n    /// @notice Feed ids map (token => feedId)\n    mapping(address => bytes32) public feedIds;\n\n    /// @notice Emitted when an aggregator is updated\n    event FeedIdUpdated(address token, bytes32 feedId);\n\n    constructor(IPyth pyth_) {\n        pyth = pyth_;\n    }\n\n    /// @notice Get update fee (native coin)\n    function getUpdateFee(bytes[] calldata updateData_) external view returns (uint _feeAmount) {\n        return pyth.getUpdateFee(updateData_);\n    }\n\n    /// @notice Update Pyth's prices\n    function updatePrice(bytes[] calldata updateData_) external payable {\n        uint256 _fee = pyth.getUpdateFee(updateData_);\n        require(msg.value >= _fee, \"value-too-low\");\n\n        pyth.updatePriceFeeds{value: _fee}(updateData_);\n\n        if (msg.value > _fee) {\n            payable(msg.sender).sendValue(msg.value - _fee);\n        }\n    }\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(\n        address token_\n    )\n        public\n        view\n        virtual\n        override(IPriceProvider, PriceProvider)\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        bytes32 _feedId = feedIds[token_];\n\n        if (_feedId == bytes32(0)) {\n            return (0, 0);\n        }\n\n        PythStructs.Price memory _p = pyth.getPriceUnsafe(_feedId);\n        _lastUpdatedAt = _p.publishTime;\n\n        if (_lastUpdatedAt < block.timestamp && block.timestamp - _lastUpdatedAt > MAX_TIME_TOLERANCE) {\n            return (0, 0);\n        }\n\n        if (_lastUpdatedAt > block.timestamp && _lastUpdatedAt - block.timestamp > MAX_TIME_TOLERANCE) {\n            return (0, 0);\n        }\n\n        if (_p.price == 0) {\n            return (0, 0);\n        }\n\n        if (_p.expo < MIN_EXPONENT || _p.expo > MAX_EXPONENT) {\n            return (0, 0);\n        }\n\n        uint256 _toScale = (10 ** int256(18 + _p.expo).toUint256());\n        _priceInUsd = int256(_p.price).toUint256() * _toScale;\n    }\n\n    /// @inheritdoc IPythPriceProvider\n    function updateFeedId(address token_, bytes32 feedId_) external override onlyGovernor {\n        require(token_ != address(0), \"token-is-null\");\n\n        feedIds[token_] = feedId_;\n\n        emit FeedIdUpdated(token_, feedId_);\n    }\n}\n"
    },
    "contracts/core/RedstoneHemiPushPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./ChainlinkPriceProvider.sol\";\n\n/**\n * @title Redstone's push price provider for Hemi network. Redstone push price feed is 100% compatible with Chainlink.\n */\ncontract RedstoneHemiPushPriceProvider is ChainlinkPriceProvider {\n    constructor() {\n        _setAggregator(0x824D8FcDC36E81618377D140BEC12c3B7E4e4cbA, AggregatorV3Interface(0x31a36CdF4465ba61ce78F5CDbA26FDF8ec361803)); // USDC\n        _setAggregator(0xbbA60da06c2c5424f03f7434542280FCAd453d10, AggregatorV3Interface(0xe8D9FbC10e00ecc9f0694617075fDAF657a76FB2)); // USDT\n        _setAggregator(0x03C7054BCB39f7b2e5B2c7AcB37583e32D70Cfa3, AggregatorV3Interface(0xE23eCA12D7D2ED3829499556F6dCE06642AFd990)); // WBTC\n        _setAggregator(0x4200000000000000000000000000000000000006, AggregatorV3Interface(0xb9D0073aCb296719C26a8BF156e4b599174fe1d5)); // WETH\n    }\n}\n"
    },
    "contracts/core/RedstoneMainnetPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./RedstonePriceProvider.sol\";\n\n/**\n * @title Redstone's price provider with Mainnet pre-setup\n */\ncontract RedstoneMainnetPriceProvider is RedstonePriceProvider {\n    constructor() {\n        feeds[bytes32(\"USDC\")].push(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n        feeds[bytes32(\"DAI\")].push(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n        feeds[bytes32(\"ETH\")].push(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH\n        feeds[bytes32(\"ETH\")].push(0x64351fC9810aDAd17A690E4e1717Df5e7e085160); // msETH\n        feeds[bytes32(\"FRAX\")].push(0x853d955aCEf822Db058eb8505911ED77F175b99e);\n        feeds[bytes32(\"sfrxETH\")].push(0xac3E018457B222d93114458476f3E3416Abbe38F);\n        feeds[bytes32(\"rETH\")].push(0xae78736Cd615f374D3085123A210448E74Fc6393);\n        feeds[bytes32(\"stETH\")].push(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);\n        feeds[bytes32(\"BTC\")].push(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599); // WBTC\n        feeds[bytes32(\"BTC\")].push(0x8b4F8aD3801B4015Dea6DA1D36f063Cbf4e231c7); // msBTC\n    }\n}\n"
    },
    "contracts/core/RedstonePriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {PrimaryProdDataServiceConsumerBase} from \"@redstone-finance/evm-connector/contracts/data-services/PrimaryProdDataServiceConsumerBase.sol\";\nimport {IRedstonePriceProvider} from \"../interfaces/core/IRedstonePriceProvider.sol\";\nimport {IPriceProvider, PriceProvider} from \"./PriceProvider.sol\";\nimport {Governable} from \"../access/Governable.sol\";\n\n/**\n * @title Redstone's price provider\n */\ncontract RedstonePriceProvider is\n    IRedstonePriceProvider,\n    PrimaryProdDataServiceConsumerBase,\n    PriceProvider,\n    Governable\n{\n    uint256 public constant REDSTONE_DECIMALS = 8;\n    uint256 public constant TO_SCALE = 10 ** (USD_DECIMALS - REDSTONE_DECIMALS);\n    uint256 internal constant MAX_TIME_TOLERANCE = 1 minutes;\n\n    struct Cache {\n        uint256 price;\n        uint256 priceTimestamp;\n    }\n\n    /// @notice Feed ids (feedId => token)\n    mapping(bytes32 => address[]) internal feeds;\n\n    /// @notice Price cache\n    mapping(address => Cache) internal cache;\n\n    /// @notice Emitted when an feed id is updated\n    event FeedIdUpdated(bytes32 feedId, address[] tokens);\n\n    /// @notice The cache timestamp was updated.\n    /// @param price The Redstone price.\n    /// @param priceTimestamp The timestamp contained within the price data packages.\n    event CacheUpdated(uint256 price, uint256 priceTimestamp);\n\n    /// @notice Get tokens of a feed\n    function tokensOf(bytes32 feedId_) external view returns (address[] memory tokens_) {\n        return feeds[feedId_];\n    }\n\n    /// @notice Update price for the tokens related to the `dataFeedIds_`\n    function updatePrice(bytes32[] memory dataFeedIds_) external {\n        (uint256[] memory _values, uint256 _timestamp) = _securelyExtractOracleValuesAndTimestampFromTxMsg(\n            dataFeedIds_\n        );\n\n        uint256 _valuesLength = _values.length;\n        require(_valuesLength == dataFeedIds_.length, \"invalid-data\");\n\n        _timestamp /= 1000; // Redstone uses milliseconds\n\n        for (uint256 i; i < _valuesLength; ++i) {\n            address[] memory _tokens = feeds[dataFeedIds_[i]];\n            uint256 _tokensLength = _tokens.length;\n            for (uint j; j < _tokensLength; ++j) {\n                address _token = _tokens[j];\n                require(_token != address(0), \"feed-unknown\");\n                if (_timestamp != cache[_token].priceTimestamp) {\n                    cache[_token] = Cache({price: _values[i] * TO_SCALE, priceTimestamp: _timestamp});\n                }\n            }\n        }\n    }\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(\n        address token_\n    )\n        public\n        view\n        virtual\n        override(IPriceProvider, PriceProvider)\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        Cache memory _cache = cache[token_];\n        _lastUpdatedAt = _cache.priceTimestamp;\n        _priceInUsd = _cache.price;\n\n        if (_lastUpdatedAt == 0) {\n            return (0, 0);\n        }\n\n        if (_lastUpdatedAt < block.timestamp && block.timestamp - _lastUpdatedAt > MAX_TIME_TOLERANCE) {\n            return (0, 0);\n        }\n\n        if (_lastUpdatedAt > block.timestamp && _lastUpdatedAt - block.timestamp > MAX_TIME_TOLERANCE) {\n            return (0, 0);\n        }\n    }\n\n    /// @inheritdoc IRedstonePriceProvider\n    /// @dev The feed should be denominated in USD\n    function updateFeed(bytes32 feedId_, address[] memory tokens_) external override onlyGovernor {\n        require(feedId_ != bytes32(0), \"id-is-null\");\n\n        feeds[feedId_] = tokens_;\n\n        emit FeedIdUpdated(feedId_, tokens_);\n    }\n}\n"
    },
    "contracts/core/UmbrellaPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@umb-network/toolbox/dist/contracts/IChain.sol\";\nimport \"@umb-network/toolbox/dist/contracts/IRegistry.sol\";\nimport \"../access/Governable.sol\";\nimport \"../interfaces/core/IUmbrellaPriceProvider.sol\";\nimport \"./PriceProvider.sol\";\n\n/**\n * @notice Umbrella's price provider\n */\ncontract UmbrellaPriceProvider is IUmbrellaPriceProvider, PriceProvider, Governable {\n    bytes32 private constant CHAIN = bytes32(\"Chain\");\n\n    /**\n     * @notice token => Umbrella's key mapping (e.g. WBTC => \"BTC-USD\")\n     */\n    mapping(address => bytes32) public keyOfToken;\n\n    /**\n     * @notice Umbrella's Registry\n     * @dev Stores the other Umbrella's contracts' addresses\n     */\n    IRegistry public immutable registry;\n\n    event KeyOfTokenUpdated(address indexed token, bytes32 oldKey, bytes32 newKey);\n\n    constructor(IRegistry registry_) {\n        require(address(registry_) != address(0), \"registry-is-null\");\n        registry = registry_;\n    }\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(address token_)\n        public\n        view\n        virtual\n        override(IPriceProvider, PriceProvider)\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        (_priceInUsd, _lastUpdatedAt) = _chain().getCurrentValue(keyOfToken[token_]);\n        require(_lastUpdatedAt > 0, \"invalid-quote\");\n    }\n\n    /**\n     * @notice Get Umbrella's main contract\n     */\n    function _chain() internal view returns (IChain umbChain) {\n        umbChain = IChain(registry.getAddress(CHAIN));\n    }\n\n    /**\n     * @notice Build key from quote/base string in bytes format\n     * @dev The standard parser `bytes32(bytes)` will right pad with zeros\n     * but Umbrella expects left padded bytes as key\n     * @dev See if there is a simpler way to do the same as this function\n     */\n    function _toKey(bytes memory quotePairAsBytes_) private pure returns (bytes32) {\n        bytes memory _aux = new bytes(32);\n        uint256 _len = quotePairAsBytes_.length;\n        for (uint256 i; i < _len; ++i) {\n            uint256 _idx = 32 - _len + i;\n            _aux[_idx] = quotePairAsBytes_[i];\n        }\n        return bytes32(_aux);\n    }\n\n    /**\n     * @notice Update Umbrella's key of a token\n     * Use `BASE-QUOTE` format (e.g. BTC-USD, ETH-USD, etc)\n     */\n    function updateKeyOfToken(address token_, string memory quotePair_) external onlyGovernor {\n        require(token_ != address(0), \"address-is-null\");\n        bytes32 _currentKey = keyOfToken[token_];\n        bytes32 _newKey = _toKey(bytes(quotePair_));\n        keyOfToken[token_] = _newKey;\n        emit KeyOfTokenUpdated(token_, _currentKey, _newKey);\n    }\n}\n"
    },
    "contracts/core/UniswapV2LikePriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@uniswap/lib/contracts/libraries/FixedPoint.sol\";\nimport \"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"../access/Governable.sol\";\nimport \"../interfaces/core/IUniswapV2LikePriceProvider.sol\";\nimport \"./PriceProvider.sol\";\n\n/**\n * @title UniswapV2 (and forks) TWAP Oracle implementation\n * Based on https://github.com/Uniswap/v2-periphery/blob/master/contracts/examples/ExampleOracleSimple.sol\n */\ncontract UniswapV2LikePriceProvider is IUniswapV2LikePriceProvider, Governable, PriceProvider {\n    using FixedPoint for *;\n\n    /**\n     * @notice The UniswapV2-like factory's address\n     */\n    address public immutable factory;\n\n    /**\n     * @notice The native wrapped token (e.g. WETH, WAVAX, WMATIC, etc)\n     */\n    address public immutable nativeToken;\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    uint256 public override defaultTwapPeriod;\n\n    struct Oracle {\n        address token0;\n        address token1;\n        uint256 price0CumulativeLast;\n        uint256 price1CumulativeLast;\n        uint32 blockTimestampLast;\n        FixedPoint.uq112x112 price0Average;\n        FixedPoint.uq112x112 price1Average;\n    }\n\n    /**\n     * @notice Oracles'\n     * @dev pair => twapPeriod => oracle\n     */\n    mapping(IUniswapV2Pair => mapping(uint256 => Oracle)) public oracles;\n\n    /// @notice Emitted when default TWAP period is updated\n    event DefaultTwapPeriodUpdated(uint256 oldTwapPeriod, uint256 newTwapPeriod);\n\n    constructor(\n        address factory_,\n        uint256 defaultTwapPeriod_,\n        address nativeToken_\n    ) {\n        require(factory_ != address(0), \"factory-is-null\");\n        defaultTwapPeriod = defaultTwapPeriod_;\n        factory = factory_;\n        nativeToken = nativeToken_;\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function hasOracle(IUniswapV2Pair pair_) external view override returns (bool) {\n        return hasOracle(pair_, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function hasOracle(IUniswapV2Pair pair_, uint256 twapPeriod_) public view override returns (bool) {\n        return oracles[pair_][twapPeriod_].blockTimestampLast > 0;\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function pairFor(address token0_, address token1_) public view override returns (IUniswapV2Pair _pair) {\n        _pair = IUniswapV2Pair(IUniswapV2Factory(factory).getPair(token0_, token1_));\n    }\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(address token_)\n        public\n        view\n        override(IPriceProvider, PriceProvider)\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        return getPriceInUsd(token_, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function getPriceInUsd(address token_, uint256 twapPeriod_)\n        public\n        view\n        override\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        IStableCoinProvider _stableCoinProvider = addressProvider.stableCoinProvider();\n        require(address(_stableCoinProvider) != address(0), \"stable-coin-not-supported\");\n\n        uint256 _stableCoinAmount;\n        (_stableCoinAmount, _lastUpdatedAt, ) = quote(\n            token_,\n            _stableCoinProvider.getStableCoinIfPegged(),\n            twapPeriod_,\n            10**IERC20Metadata(token_).decimals() // ONE\n        );\n        _priceInUsd = _stableCoinProvider.toUsdRepresentation(_stableCoinAmount);\n    }\n\n    /// @inheritdoc IPriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        view\n        override(IPriceProvider, PriceProvider)\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        return quote(tokenIn_, tokenOut_, defaultTwapPeriod, amountIn_);\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_,\n        uint256 amountIn_\n    )\n        public\n        view\n        override\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        if (tokenIn_ == tokenOut_) {\n            return (amountIn_, block.timestamp, block.timestamp);\n        }\n\n        if (hasOracle(pairFor(tokenIn_, tokenOut_), twapPeriod_)) {\n            (_amountOut, _tokenInLastUpdatedAt) = _getAmountOut(tokenIn_, tokenOut_, twapPeriod_, amountIn_);\n            _tokenOutLastUpdatedAt = _tokenInLastUpdatedAt;\n        } else {\n            (_amountOut, _tokenInLastUpdatedAt) = _getAmountOut(tokenIn_, nativeToken, twapPeriod_, amountIn_);\n            (_amountOut, _tokenOutLastUpdatedAt) = _getAmountOut(nativeToken, tokenOut_, twapPeriod_, _amountOut);\n        }\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint256 twapPeriod_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        uint256 _price;\n        (_price, _lastUpdatedAt) = getPriceInUsd(token_, twapPeriod_);\n        _amountOut = (amountIn_ * _price) / 10**IERC20Metadata(token_).decimals();\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint256 twapPeriod_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        uint256 _price;\n        (_price, _lastUpdatedAt) = getPriceInUsd(token_, twapPeriod_);\n        _amountOut = (amountIn_ * 10**IERC20Metadata(token_).decimals()) / _price;\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function updateAndQuote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        override\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        return updateAndQuote(tokenIn_, tokenOut_, defaultTwapPeriod, amountIn_);\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function updateAndQuote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_,\n        uint256 amountIn_\n    )\n        public\n        override\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        updateOrAdd(tokenIn_, tokenOut_, twapPeriod_);\n        return quote(tokenIn_, tokenOut_, twapPeriod_, amountIn_);\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function updateOrAdd(address tokenIn_, address tokenOut_) external override {\n        updateOrAdd(tokenIn_, tokenOut_, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function updateOrAdd(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_\n    ) public override {\n        IUniswapV2Pair _pair = pairFor(tokenIn_, tokenOut_);\n        if (!hasOracle(_pair, twapPeriod_)) {\n            _addOracleFor(_pair, twapPeriod_);\n        }\n        _updateIfNeeded(_pair, twapPeriod_);\n    }\n\n    /**\n     * @notice Create new oracle\n     * @param pair_ The pair to get prices from\n     * @param twapPeriod_ The TWAP period\n     */\n    function _addOracleFor(IUniswapV2Pair pair_, uint256 twapPeriod_) private {\n        require(address(pair_) != address(0), \"invalid-pair\");\n\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = pair_.getReserves();\n\n        require(_reserve0 != 0 && _reserve1 != 0, \"no-reserves\");\n\n        oracles[pair_][twapPeriod_] = Oracle({\n            token0: pair_.token0(),\n            token1: pair_.token1(),\n            price0CumulativeLast: pair_.price0CumulativeLast(),\n            price1CumulativeLast: pair_.price1CumulativeLast(),\n            blockTimestampLast: _blockTimestampLast,\n            price0Average: uint112(0).encode(),\n            price1Average: uint112(0).encode()\n        });\n    }\n\n    /**\n     * @notice Get the output amount for a given oracle\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param twapPeriod_ The TWAP period\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function _getAmountOut(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_,\n        uint256 amountIn_\n    ) private view returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        Oracle memory _oracle = oracles[pairFor(tokenIn_, tokenOut_)][twapPeriod_];\n        if (tokenIn_ == _oracle.token0) {\n            _amountOut = _oracle.price0Average.mul(amountIn_).decode144();\n        } else {\n            _amountOut = _oracle.price1Average.mul(amountIn_).decode144();\n        }\n        _lastUpdatedAt = _oracle.blockTimestampLast;\n    }\n\n    /**\n     * @notice Update an oracle\n     * @param pair_ The pair to update\n     * @param twapPeriod_ The TWAP period\n     * @return True if updated was performed\n     */\n    function _updateIfNeeded(IUniswapV2Pair pair_, uint256 twapPeriod_) private returns (bool) {\n        Oracle storage _oracle = oracles[pair_][twapPeriod_];\n\n        (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) = UniswapV2OracleLibrary\n            .currentCumulativePrices(address(pair_));\n        uint32 timeElapsed;\n        unchecked {\n            timeElapsed = blockTimestamp - _oracle.blockTimestampLast; // overflow is desired\n        }\n        // ensure that at least one full period has passed since the last update\n        if (timeElapsed < twapPeriod_) return false;\n\n        uint256 price0new;\n        uint256 price1new;\n\n        unchecked {\n            price0new = price0Cumulative - _oracle.price0CumulativeLast;\n            price1new = price1Cumulative - _oracle.price1CumulativeLast;\n        }\n\n        // overflow is desired, casting never truncates\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\n        _oracle.price0Average = FixedPoint.uq112x112(uint224(price0new / timeElapsed));\n        _oracle.price1Average = FixedPoint.uq112x112(uint224(price1new / timeElapsed));\n        _oracle.price0CumulativeLast = price0Cumulative;\n        _oracle.price1CumulativeLast = price1Cumulative;\n        _oracle.blockTimestampLast = blockTimestamp;\n        return true;\n    }\n\n    /// @inheritdoc IUniswapV2LikePriceProvider\n    function updateDefaultTwapPeriod(uint256 newDefaultTwapPeriod_) external override onlyGovernor {\n        emit DefaultTwapPeriodUpdated(defaultTwapPeriod, newDefaultTwapPeriod_);\n        defaultTwapPeriod = newDefaultTwapPeriod_;\n    }\n}\n"
    },
    "contracts/core/UniswapV3PriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../access/Governable.sol\";\nimport \"../interfaces/utils/IUniswapV3CrossPoolOracle.sol\";\nimport \"../interfaces/core/IUniswapV3PriceProvider.sol\";\nimport \"./PriceProvider.sol\";\n\ncontract UniswapV3PriceProvider is IUniswapV3PriceProvider, Governable, PriceProvider {\n    /**\n     * @notice The UniswapV3CrossPoolOracle contract\n     * @dev This contract encapsulates UniswapV3 oracle logic\n     */\n    IUniswapV3CrossPoolOracle public immutable crossPoolOracle;\n\n    /**\n     * @notice The time-weighted average price (TWAP) period\n     * @dev See more: https://docs.uniswap.org/protocol/concepts/V3-overview/oracle\n     */\n    uint32 public override defaultTwapPeriod;\n\n    /**\n     * @notice The default pool fee to use\n     * @dev Use 1e6 for 100% (e.g 3000 is 0.3%)\n     */\n    uint24 public defaultPoolFee;\n\n    /// @notice Emitted when the default TWAP period is updated\n    event DefaultTwapPeriodUpdated(uint32 oldDefaultTwapPeriod, uint32 newDefaultTwapPeriod);\n\n    /// @notice Emitted when the default pool fee updated\n    event DefaultPoolFeeUpdated(uint24 oldDefaultPoolFee, uint24 newDefaultPoolFee);\n\n    constructor(\n        IUniswapV3CrossPoolOracle crossPoolOracle_,\n        uint32 defaultTwapPeriod_,\n        uint24 defaultFee_\n    ) {\n        require(address(crossPoolOracle_) != address(0), \"cross-pool-is-null\");\n        crossPoolOracle = crossPoolOracle_;\n        defaultTwapPeriod = defaultTwapPeriod_;\n        defaultPoolFee = defaultFee_;\n    }\n\n    /// @inheritdoc IPriceProvider\n    function getPriceInUsd(address token_)\n        public\n        view\n        override(IPriceProvider, PriceProvider)\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        return getPriceInUsd(token_, defaultPoolFee, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function getPriceInUsd(address token_, uint32 twapPeriod_)\n        public\n        view\n        override\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        return getPriceInUsd(token_, defaultPoolFee, twapPeriod_);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function getPriceInUsd(address token_, uint24 poolFee_)\n        public\n        view\n        override\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt)\n    {\n        return getPriceInUsd(token_, poolFee_, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function getPriceInUsd(\n        address token_,\n        uint24 poolFee_,\n        uint32 twapPeriod_\n    ) public view override returns (uint256 _priceInUsd, uint256 _lastUpdatedAt) {\n        IStableCoinProvider _stableCoinProvider = addressProvider.stableCoinProvider();\n        require(address(_stableCoinProvider) != address(0), \"stable-coin-not-supported\");\n\n        uint256 _stableCoinAmount;\n        (_stableCoinAmount, _lastUpdatedAt, ) = quote(\n            token_,\n            _stableCoinProvider.getStableCoinIfPegged(),\n            poolFee_,\n            twapPeriod_,\n            10**IERC20Metadata(token_).decimals() // ONE\n        );\n\n        _priceInUsd = _stableCoinProvider.toUsdRepresentation(_stableCoinAmount);\n    }\n\n    /// @inheritdoc IPriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        view\n        override(IPriceProvider, PriceProvider)\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        return quote(tokenIn_, tokenOut_, defaultPoolFee, defaultTwapPeriod, amountIn_);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint32 twapPeriod_,\n        uint256 amountIn_\n    )\n        external\n        view\n        override\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        return quote(tokenIn_, tokenOut_, defaultPoolFee, twapPeriod_, amountIn_);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint24 poolFee_,\n        uint256 amountIn_\n    )\n        external\n        view\n        override\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        return quote(tokenIn_, tokenOut_, poolFee_, defaultTwapPeriod, amountIn_);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint24 poolFee_,\n        uint32 twapPeriod_,\n        uint256 amountIn_\n    )\n        public\n        view\n        override\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        if (tokenIn_ == tokenOut_) {\n            return (amountIn_, block.timestamp, block.timestamp);\n        }\n\n        if (tokenIn_ == crossPoolOracle.nativeToken()) {\n            _amountOut = crossPoolOracle.ethToAsset(amountIn_, tokenOut_, poolFee_, twapPeriod_);\n        } else if (tokenOut_ == crossPoolOracle.nativeToken()) {\n            _amountOut = crossPoolOracle.assetToEth(tokenIn_, amountIn_, poolFee_, twapPeriod_);\n        } else {\n            _amountOut = crossPoolOracle.assetToAsset(tokenIn_, amountIn_, tokenOut_, poolFee_, twapPeriod_);\n        }\n        _tokenInLastUpdatedAt = block.timestamp;\n        _tokenOutLastUpdatedAt = block.timestamp;\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        return quoteTokenToUsd(token_, amountIn_, poolFee_, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint32 twapPeriod_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        return quoteTokenToUsd(token_, amountIn_, defaultPoolFee, twapPeriod_);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_,\n        uint32 twapPeriod_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        uint256 _price;\n        (_price, _lastUpdatedAt) = getPriceInUsd(token_, poolFee_, twapPeriod_);\n        _amountOut = (amountIn_ * _price) / 10**IERC20Metadata(token_).decimals();\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        return quoteUsdToToken(token_, amountIn_, poolFee_, defaultTwapPeriod);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint32 twapPeriod_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        return quoteUsdToToken(token_, amountIn_, defaultPoolFee, twapPeriod_);\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_,\n        uint32 twapPeriod_\n    ) public view override returns (uint256 _amountOut, uint256 _lastUpdatedAt) {\n        uint256 _price;\n        (_price, _lastUpdatedAt) = getPriceInUsd(token_, poolFee_, twapPeriod_);\n        _amountOut = (amountIn_ * 10**IERC20Metadata(token_).decimals()) / _price;\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function updateDefaultTwapPeriod(uint32 newDefaultTwapPeriod_) external onlyGovernor {\n        emit DefaultTwapPeriodUpdated(defaultTwapPeriod, newDefaultTwapPeriod_);\n        defaultTwapPeriod = newDefaultTwapPeriod_;\n    }\n\n    /// @inheritdoc IUniswapV3PriceProvider\n    function updateDefaultPoolFee(uint24 newDefaultPoolFee_) external onlyGovernor {\n        emit DefaultPoolFeeUpdated(defaultPoolFee, newDefaultPoolFee_);\n        defaultPoolFee = newDefaultPoolFee_;\n    }\n}\n"
    },
    "contracts/features/UsingStalePeriod.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../access/Governable.sol\";\n\n/**\n * @title Stale price check feature, useful when checking if prices are fresh enough\n */\nabstract contract UsingStalePeriod is Governable {\n    /// @notice The default stale period. It's used to determine if a price is invalid (i.e. outdated)\n    uint256 public defaultStalePeriod;\n\n    /// @notice Custom stale period, used for token that has different stale window (e.g. some stable coins have 24h window)\n    mapping(address => uint256) customStalePeriod;\n\n    /// @notice Emitted when custom stale period is updated\n    event CustomStalePeriodUpdated(address token, uint256 oldStalePeriod, uint256 newStalePeriod);\n\n    /// @notice Emitted when default stale period is updated\n    event DefaultStalePeriodUpdated(uint256 oldStalePeriod, uint256 newStalePeriod);\n\n    constructor(uint256 defaultStalePeriod_) {\n        defaultStalePeriod = defaultStalePeriod_;\n    }\n\n    /**\n     * @notice Get stale period of a token\n     */\n    function stalePeriodOf(address token_) public view returns (uint256 _stalePeriod) {\n        _stalePeriod = customStalePeriod[token_];\n        if (_stalePeriod == 0) {\n            _stalePeriod = defaultStalePeriod;\n        }\n    }\n\n    /**\n     * @notice Check if a price timestamp is outdated\n     * @dev Uses default stale period\n     * @param timeOfLastUpdate_ The price timestamp\n     * @return true if price is stale (outdated)\n     */\n    function _priceIsStale(address token_, uint256 timeOfLastUpdate_) internal view returns (bool) {\n        return _priceIsStale(timeOfLastUpdate_, stalePeriodOf(token_));\n    }\n\n    /**\n     * @notice Check if a price timestamp is outdated\n     * @param timeOfLastUpdate_ The price timestamp\n     * @param stalePeriod_ The maximum acceptable outdated period\n     * @return true if price is stale (outdated)\n     */\n    function _priceIsStale(uint256 timeOfLastUpdate_, uint256 stalePeriod_) internal view returns (bool) {\n        return block.timestamp - timeOfLastUpdate_ > stalePeriod_;\n    }\n\n    /**\n     * @notice Update custom stale period\n     * @dev Use `0` as `stalePeriod_` to remove custom stale period\n     */\n    function updateCustomStalePeriod(address token_, uint256 stalePeriod_) external onlyGovernor {\n        require(token_ != address(0), \"token-is-null\");\n        emit CustomStalePeriodUpdated(token_, customStalePeriod[token_], stalePeriod_);\n        if (stalePeriod_ > 0) {\n            customStalePeriod[token_] = stalePeriod_;\n        } else {\n            delete customStalePeriod[token_];\n        }\n    }\n\n    /**\n     * @notice Update default stale period\n     */\n    function updateDefaultStalePeriod(uint256 stalePeriod_) external onlyGovernor {\n        emit DefaultStalePeriodUpdated(defaultStalePeriod, stalePeriod_);\n        defaultStalePeriod = stalePeriod_;\n    }\n}\n"
    },
    "contracts/interfaces/core/IAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./IStableCoinProvider.sol\";\nimport \"./IPriceProvidersAggregator.sol\";\n\ninterface IAddressProvider {\n    function governor() external view returns (address);\n\n    function providersAggregator() external view returns (IPriceProvidersAggregator);\n\n    function stableCoinProvider() external view returns (IStableCoinProvider);\n\n    function updateProvidersAggregator(IPriceProvidersAggregator providersAggregator_) external;\n}\n"
    },
    "contracts/interfaces/core/IChainlinkPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./IPriceProvider.sol\";\n\ninterface IChainlinkPriceProvider is IPriceProvider {\n    /**\n     * @notice Update token's aggregator\n     */\n    function updateAggregator(address token_, AggregatorV3Interface aggregator_) external;\n}\n"
    },
    "contracts/interfaces/core/IPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IPriceProvider {\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of asset\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(address token_) external view returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(address token_, uint256 amountIn_)\n        external\n        view\n        returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetOut\n     * @param amountIn_ Input amount in USD\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(address token_, uint256 amountIn_)\n        external\n        view\n        returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n}\n"
    },
    "contracts/interfaces/core/IPriceProvidersAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../libraries/DataTypes.sol\";\nimport \"./IPriceProvider.sol\";\n\n/**\n * @notice PriceProvidersAggregator interface\n * @dev Worth noting that the `_lastUpdatedAt` logic depends on the underlying price provider. In summary:\n * ChainLink: returns the last updated date from the aggregator\n * UniswapV2: returns the date of the latest pair oracle update\n * UniswapV3: assumes that the price is always updated (returns block.timestamp)\n * Umbrella (FCD): returns the last updated date returned from their oracle contract\n * Umbrella (Passport): returns the date of the latest pallet submission\n * Anytime that a quote performs more than one query, it uses the oldest date as the `_lastUpdatedAt`.\n * See more: https://github.com/bloqpriv/one-oracle/issues/64\n */\ninterface IPriceProvidersAggregator {\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param provider_ The price provider to get quote from\n     * @param token_ The address of asset\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(\n        DataTypes.Provider provider_,\n        address token_\n    ) external view returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Provider Providers' mapping\n     */\n    function priceProviders(DataTypes.Provider provider_) external view returns (IPriceProvider _priceProvider);\n\n    /**\n     * @notice Get quote\n     * @param provider_ The price provider to get quote from\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        DataTypes.Provider provider_,\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external view returns (uint256 _amountOut, uint256 _tokenInLastUpdatedAt, uint256 _tokenOutLastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @dev If providers aren't the same, uses native token as \"bridge\"\n     * @param providerIn_ The price provider to get quote for the tokenIn\n     * @param tokenIn_ The address of assetIn\n     * @param providerOut_ The price provider to get quote for the tokenOut\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _nativeTokenLastUpdatedAt Last updated timestamp of native token (i.e. WETH) used when providers aren't the same\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        DataTypes.Provider providerIn_,\n        address tokenIn_,\n        DataTypes.Provider providerOut_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _nativeTokenLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param provider_ The price provider to get quote from\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(\n        DataTypes.Provider provider_,\n        address token_,\n        uint256 amountIn_\n    ) external view returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param provider_ The price provider to get quote from\n     * @param token_ The address of assetOut\n     * @param amountIn_ Input amount in USD\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(\n        DataTypes.Provider provider_,\n        address token_,\n        uint256 amountIn_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Set a price provider\n     * @dev Administrative function\n     * @param provider_ The provider (from enum)\n     * @param priceProvider_ The price provider contract\n     */\n    function setPriceProvider(DataTypes.Provider provider_, IPriceProvider priceProvider_) external;\n}\n"
    },
    "contracts/interfaces/core/IPythPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./IPriceProvider.sol\";\n\ninterface IPythPriceProvider is IPriceProvider {\n    /**\n     * @notice Update token's feed id\n     */\n    function updateFeedId(address token_, bytes32 feedId_) external;\n}\n"
    },
    "contracts/interfaces/core/IRedstonePriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./IPriceProvider.sol\";\n\ninterface IRedstonePriceProvider is IPriceProvider {\n    /**\n     * @notice Update feed id\n     */\n    function updateFeed(bytes32 feedId_, address[] memory tokens_) external;\n}\n"
    },
    "contracts/interfaces/core/IStableCoinProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IStableCoinProvider {\n    /**\n     * @notice Return the stable coin if pegged\n     * @dev Check price relation between both stable coins and revert if peg is too loose\n     * @return _stableCoin The primary stable coin if pass all checks\n     */\n    function getStableCoinIfPegged() external view returns (address _stableCoin);\n\n    /**\n     * @notice Convert given amount of stable coin to USD representation (18 decimals)\n     */\n    function toUsdRepresentation(uint256 stableCoinAmount_) external view returns (uint256 _usdAmount);\n}\n"
    },
    "contracts/interfaces/core/IUmbrellaPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./IPriceProvider.sol\";\n\ninterface IUmbrellaPriceProvider is IPriceProvider {}\n"
    },
    "contracts/interfaces/core/IUniswapV2LikePriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"./IPriceProvider.sol\";\n\ninterface IUniswapV2LikePriceProvider is IPriceProvider {\n    /**\n     * @notice The default time-weighted average price (TWAP) period\n     * Used when a period isn't specified\n     * @dev See more: https://docs.uniswap.org/protocol/concepts/V3-overview/oracle\n     */\n    function defaultTwapPeriod() external view returns (uint256);\n\n    /**\n     * @notice Check if there is an oracle for the PAIR-TWAP key\n     * @param pair_ The pair\n     * @param twapPeriod_ The TWAP period\n     * @return True if exists\n     */\n    function hasOracle(IUniswapV2Pair pair_, uint256 twapPeriod_) external view returns (bool);\n\n    /**\n     * @notice Check if there is an oracle for the PAIR-TWAP key\n     * @dev Uses `defaultTwapPeriod`\n     * @param pair_ The pair\n     * @return True if exists\n     */\n    function hasOracle(IUniswapV2Pair pair_) external view returns (bool);\n\n    /**\n     * @notice Returns the pair's contract\n     */\n    function pairFor(address token0_, address token1_) external view returns (IUniswapV2Pair _pair);\n\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of assetIn\n     * @param twapPeriod_ The TWAP period\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(address token_, uint256 twapPeriod_)\n        external\n        view\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param twapPeriod_ The TWAP period\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_,\n        uint256 amountIn_\n    )\n        external\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @param twapPeriod_ The TWAP period\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint256 twapPeriod_\n    ) external view returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetIn\n     * @param amountIn_ Input amount in USD\n     * @param twapPeriod_ The TWAP period\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint256 twapPeriod_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @dev Will update the oracle if needed before getting quote\n     * @dev Uses `defaultTwapPeriod`\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function updateAndQuote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote\n     * @dev Will update the oracle if needed before getting quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param twapPeriod_ The TWAP period\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function updateAndQuote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_,\n        uint256 amountIn_\n    )\n        external\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Update the default TWAP period\n     * @dev Administrative function\n     * @param newDefaultTwapPeriod_ The new default period\n     */\n    function updateDefaultTwapPeriod(uint256 newDefaultTwapPeriod_) external;\n\n    /**\n     * @notice Update cumulative and average price of pair\n     * @dev Will create the pair if it doesn't exist\n     * @dev Uses `defaultTwapPeriod`\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     */\n    function updateOrAdd(address tokenIn_, address tokenOut_) external;\n\n    /**\n     * @notice Update cumulative and average price of pair\n     * @dev Will create the pair if it doesn't exist\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param twapPeriod_ The TWAP period\n     */\n    function updateOrAdd(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 twapPeriod_\n    ) external;\n}\n"
    },
    "contracts/interfaces/core/IUniswapV3PriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./IPriceProvider.sol\";\n\ninterface IUniswapV3PriceProvider is IPriceProvider {\n    /**\n     * @notice The default time-weighted average price (TWAP) period\n     * Used when a period isn't specified\n     * @dev See more: https://docs.uniswap.org/protocol/concepts/V3-overview/oracle\n     */\n    function defaultTwapPeriod() external view returns (uint32);\n\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of assetIn\n     * @param poolFee_ The pools' fees\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(address token_, uint24 poolFee_)\n        external\n        view\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of assetIn\n     * @param twapPeriod_ The TWAP period\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(address token_, uint32 twapPeriod_)\n        external\n        view\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of assetIn\n     * @param poolFee_ The pools' fees\n     * @param twapPeriod_ The TWAP period\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(\n        address token_,\n        uint24 poolFee_,\n        uint32 twapPeriod_\n    ) external view returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param twapPeriod_ The TWAP period\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint32 twapPeriod_,\n        uint256 amountIn_\n    )\n        external\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param poolFee_ The pools' fees\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint24 poolFee_,\n        uint256 amountIn_\n    )\n        external\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param poolFee_ The pools' fees\n     * @param twapPeriod_ The TWAP period\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint24 poolFee_,\n        uint32 twapPeriod_,\n        uint256 amountIn_\n    )\n        external\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @param poolFee_ The pools' fees\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_\n    ) external view returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @param twapPeriod_ The TWAP period\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint32 twapPeriod_\n    ) external view returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @param poolFee_ The pools' fees\n     * @param twapPeriod_ The TWAP period\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_,\n        uint32 twapPeriod_\n    ) external view returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetIn\n     * @param amountIn_ Input amount in USD\n     * @param poolFee_ The TWAP period\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetIn\n     * @param amountIn_ Input amount in USD\n     * @param twapPeriod_ The TWAP period\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint32 twapPeriod_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetIn\n     * @param amountIn_ Input amount in USD\n     * @param poolFee_ The TWAP period\n     * @param twapPeriod_ The TWAP period\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(\n        address token_,\n        uint256 amountIn_,\n        uint24 poolFee_,\n        uint32 twapPeriod_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Update the default TWAP period\n     * @dev Administrative function\n     * @param newDefaultTwapPeriod_ The new default period\n     */\n    function updateDefaultTwapPeriod(uint32 newDefaultTwapPeriod_) external;\n\n    /**\n     * @notice Update the default pool fee\n     * @dev Administrative function\n     * @param newDefaultPoolFee_ The new default period\n     */\n    function updateDefaultPoolFee(uint24 newDefaultPoolFee_) external;\n}\n"
    },
    "contracts/interfaces/periphery/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IOracle {\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of asset\n     * @return _priceInUsd The USD price\n     */\n    function getPriceInUsd(address token_) external view returns (uint256 _priceInUsd);\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external view returns (uint256 _amountOut);\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     */\n    function quoteTokenToUsd(address token_, uint256 amountIn_) external view returns (uint256 amountOut_);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetOut\n     * @param amountIn_ Input amount in USD\n     * @return _amountOut Output amount of token\n     */\n    function quoteUsdToToken(address token_, uint256 amountIn_) external view returns (uint256 _amountOut);\n}\n"
    },
    "contracts/interfaces/periphery/ITokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ITokenOracle {\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of asset\n     * @return _priceInUsd The USD price\n     */\n    function getPriceInUsd(address token_) external view returns (uint256 _priceInUsd);\n}\n"
    },
    "contracts/interfaces/utils/IUniswapV3CrossPoolOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/**\n * @title UniswapV3 oracle with ability to query across an intermediate liquidity pool\n */\ninterface IUniswapV3CrossPoolOracle {\n    function nativeToken() external view returns (address);\n\n    function assetToEth(\n        address _tokenIn,\n        uint256 _amountIn,\n        uint24 _fee,\n        uint32 _twapPeriod\n    ) external view returns (uint256 ethAmountOut);\n\n    function ethToAsset(\n        uint256 _ethAmountIn,\n        address _tokenOut,\n        uint24 _fee,\n        uint32 _twapPeriod\n    ) external view returns (uint256 amountOut);\n\n    function assetToAsset(\n        address _tokenIn,\n        uint256 _amountIn,\n        address _tokenOut,\n        uint24 _fee,\n        uint32 _twapPeriod\n    ) external view returns (uint256 amountOut);\n\n    function assetToAssetThruRoute(\n        address _tokenIn,\n        uint256 _amountIn,\n        address _tokenOut,\n        uint32 _twapPeriod,\n        address _routeThruToken,\n        uint24[2] memory _poolFees\n    ) external view returns (uint256 amountOut);\n}\n"
    },
    "contracts/libraries/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nlibrary DataTypes {\n    /**\n     * @notice Price providers enumeration\n     */\n    enum Provider {\n        NONE,\n        CHAINLINK,\n        UNISWAP_V3,\n        UNISWAP_V2,\n        SUSHISWAP,\n        TRADERJOE,\n        PANGOLIN,\n        QUICKSWAP,\n        UMBRELLA_FIRST_CLASS,\n        UMBRELLA_PASSPORT\n    }\n}\n"
    },
    "contracts/libraries/OracleHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2;\n\nlibrary OracleHelpers {\n    function scaleDecimal(\n        uint256 amount,\n        uint256 _fromDecimal,\n        uint256 _toDecimal\n    ) internal pure returns (uint256) {\n        if (_fromDecimal > _toDecimal) {\n            return amount / (10**(_fromDecimal - _toDecimal));\n        } else if (_fromDecimal < _toDecimal) {\n            return amount * (10**(_toDecimal - _fromDecimal));\n        }\n        return amount;\n    }\n}\n"
    },
    "contracts/mock/PriceProviderMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../core/PriceProvider.sol\";\n\ncontract PriceProviderMock is PriceProvider {\n    mapping(address => uint256) public priceInUsd;\n\n    function setPriceInUsd(address token_, uint256 priceInUsd_) public {\n        priceInUsd[token_] = priceInUsd_;\n    }\n\n    function getPriceInUsd(address token_) public view override returns (uint256 _priceInUsd, uint256 _lastUpdatedAt) {\n        _priceInUsd = priceInUsd[token_];\n        _lastUpdatedAt = block.timestamp;\n    }\n\n    function checkGasOfQuote(\n        IPriceProvider _pp,\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        public\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        )\n    {\n        return _pp.quote(tokenIn_, tokenOut_, amountIn_);\n    }\n}\n"
    },
    "contracts/periphery/ChainlinkOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../interfaces/periphery/IOracle.sol\";\nimport \"../features/UsingStalePeriod.sol\";\n\n/**\n * @title Chainlink oracle\n */\ncontract ChainlinkOracle is IOracle, UsingStalePeriod {\n    constructor(uint256 stalePeriod_) UsingStalePeriod(stalePeriod_) {}\n\n    /// @inheritdoc IOracle\n    function getPriceInUsd(address token_) public view virtual returns (uint256 _priceInUsd) {\n        uint256 _lastUpdatedAt;\n        (_priceInUsd, _lastUpdatedAt) = addressProvider.providersAggregator().getPriceInUsd(\n            DataTypes.Provider.CHAINLINK,\n            token_\n        );\n        require(_priceInUsd > 0 && !_priceIsStale(token_, _lastUpdatedAt), \"price-invalid\");\n    }\n\n    /// @inheritdoc IOracle\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) public view virtual returns (uint256 _amountOut) {\n        uint256 _tokenInLastUpdatedAt;\n        uint256 _tokenOutLastUpdatedAt;\n        (_amountOut, _tokenInLastUpdatedAt, _tokenOutLastUpdatedAt) = addressProvider.providersAggregator().quote(\n            DataTypes.Provider.CHAINLINK,\n            tokenIn_,\n            tokenOut_,\n            amountIn_\n        );\n\n        require(\n            _amountOut > 0 &&\n                !_priceIsStale(tokenIn_, _tokenInLastUpdatedAt) &&\n                !_priceIsStale(tokenOut_, _tokenOutLastUpdatedAt),\n            \"price-invalid\"\n        );\n    }\n\n    /// @inheritdoc IOracle\n    function quoteTokenToUsd(address token_, uint256 amountIn_) public view virtual returns (uint256 _amountOut) {\n        uint256 _lastUpdatedAt;\n        (_amountOut, _lastUpdatedAt) = addressProvider.providersAggregator().quoteTokenToUsd(\n            DataTypes.Provider.CHAINLINK,\n            token_,\n            amountIn_\n        );\n        require(_amountOut > 0 && !_priceIsStale(token_, _lastUpdatedAt), \"price-invalid\");\n    }\n\n    /// @inheritdoc IOracle\n    function quoteUsdToToken(address token_, uint256 amountIn_) public view virtual returns (uint256 _amountOut) {\n        uint256 _lastUpdatedAt;\n        (_amountOut, _lastUpdatedAt) = addressProvider.providersAggregator().quoteUsdToToken(\n            DataTypes.Provider.CHAINLINK,\n            token_,\n            amountIn_\n        );\n        require(_amountOut > 0 && !_priceIsStale(token_, _lastUpdatedAt), \"price-invalid\");\n    }\n}\n"
    },
    "contracts/periphery/MainAndFallbackOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IOracle} from \"../interfaces/periphery/IOracle.sol\";\nimport {IPriceProvider} from \"../interfaces/core/IPriceProvider.sol\";\nimport {UsingStalePeriod} from \"../features/UsingStalePeriod.sol\";\n\n/**\n * @title Main and Fallback oracle\n * @dev Uses a primary oracle, if it doesn't support the asset, or price is staled, try getting price from the fallback.\n */\ncontract MainAndFallbackOracle is IOracle, UsingStalePeriod {\n    IPriceProvider public immutable mainProvider;\n    IPriceProvider public immutable fallbackProvider;\n\n    constructor(\n        IPriceProvider mainProvider_,\n        IPriceProvider fallbackProvider_,\n        uint256 stalePeriod_\n    ) UsingStalePeriod(stalePeriod_) {\n        require(address(mainProvider_) != address(0), \"main-is-null\");\n        require(address(fallbackProvider_) != address(0), \"fallback-is-null\");\n        mainProvider = mainProvider_;\n        fallbackProvider = fallbackProvider_;\n    }\n\n    /// @inheritdoc IOracle\n    function getPriceInUsd(address _asset) public view virtual returns (uint256) {\n        uint256 _stalePeriod = stalePeriodOf(_asset);\n\n        // 1. Check main provider\n        (uint256 _priceInUsd, uint256 _lastUpdatedAt) = mainProvider.getPriceInUsd(_asset);\n\n        if (_priceInUsd > 0 && !_priceIsStale(_lastUpdatedAt, _stalePeriod)) {\n            return _priceInUsd;\n        }\n\n        // 2. Check fallback provider\n        (_priceInUsd, _lastUpdatedAt) = fallbackProvider.getPriceInUsd(_asset);\n\n        if (_priceInUsd > 0 && !_priceIsStale(_lastUpdatedAt, _stalePeriod)) {\n            return _priceInUsd;\n        }\n\n        revert(\"both-providers-failed\");\n    }\n\n    /// @inheritdoc IOracle\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) public view virtual returns (uint256 _amountOut) {\n        _amountOut = quoteUsdToToken({token_: tokenOut_, amountIn_: quoteTokenToUsd(tokenIn_, amountIn_)});\n    }\n\n    /// @inheritdoc IOracle\n    function quoteTokenToUsd(address token_, uint256 amountIn_) public view virtual returns (uint256) {\n        uint256 _stalePeriod = stalePeriodOf(token_);\n\n        // 1. Check main provider\n        (uint256 _amountOut, uint256 _lastUpdatedAt) = mainProvider.quoteTokenToUsd(token_, amountIn_);\n\n        if (_amountOut > 0 && !_priceIsStale(_lastUpdatedAt, _stalePeriod)) {\n            return _amountOut;\n        }\n\n        // 2. Check fallback provider\n        (_amountOut, _lastUpdatedAt) = fallbackProvider.quoteTokenToUsd(token_, amountIn_);\n\n        if (_amountOut > 0 && !_priceIsStale(_lastUpdatedAt, _stalePeriod)) {\n            return _amountOut;\n        }\n\n        revert(\"both-providers-failed\");\n    }\n\n    /// @inheritdoc IOracle\n    function quoteUsdToToken(address token_, uint256 amountIn_) public view virtual returns (uint256) {\n        uint256 _stalePeriod = stalePeriodOf(token_);\n\n        // 1. Check main provider\n        (uint256 _amountOut, uint256 _lastUpdatedAt) = mainProvider.quoteUsdToToken(token_, amountIn_);\n\n        if (_amountOut > 0 && !_priceIsStale(_lastUpdatedAt, _stalePeriod)) {\n            return _amountOut;\n        }\n\n        // 2. Check fallback provider\n        (_amountOut, _lastUpdatedAt) = fallbackProvider.quoteUsdToToken(token_, amountIn_);\n\n        if (_amountOut > 0 && !_priceIsStale(_lastUpdatedAt, _stalePeriod)) {\n            return _amountOut;\n        }\n\n        revert(\"both-providers-failed\");\n    }\n}\n"
    },
    "contracts/periphery/MainOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IOracle} from \"../interfaces/periphery/IOracle.sol\";\nimport {IPriceProvider} from \"../interfaces/core/IPriceProvider.sol\";\nimport {UsingStalePeriod} from \"../features/UsingStalePeriod.sol\";\n\n/**\n * @title Main oracle\n * @dev In most cases this will wrap the Chainlink price provider\n */\ncontract MainOracle is IOracle, UsingStalePeriod {\n    IPriceProvider public immutable provider;\n\n    constructor(IPriceProvider provider_, uint256 stalePeriod_) UsingStalePeriod(stalePeriod_) {\n        provider = provider_;\n    }\n\n    /// @inheritdoc IOracle\n    function getPriceInUsd(address token_) public view virtual returns (uint256 _priceInUsd) {\n        uint256 _lastUpdatedAt;\n        (_priceInUsd, _lastUpdatedAt) = provider.getPriceInUsd(token_);\n        require(_priceInUsd > 0 && !_priceIsStale(token_, _lastUpdatedAt), \"price-invalid\");\n    }\n\n    /// @inheritdoc IOracle\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) public view virtual returns (uint256 _amountOut) {\n        uint256 _tokenInLastUpdatedAt;\n        uint256 _tokenOutLastUpdatedAt;\n        (_amountOut, _tokenInLastUpdatedAt, _tokenOutLastUpdatedAt) = provider.quote(tokenIn_, tokenOut_, amountIn_);\n\n        require(\n            _amountOut > 0 &&\n                !_priceIsStale(tokenIn_, _tokenInLastUpdatedAt) &&\n                !_priceIsStale(tokenOut_, _tokenOutLastUpdatedAt),\n            \"price-invalid\"\n        );\n    }\n\n    /// @inheritdoc IOracle\n    function quoteTokenToUsd(address token_, uint256 amountIn_) public view virtual returns (uint256 _amountOut) {\n        uint256 _lastUpdatedAt;\n        (_amountOut, _lastUpdatedAt) = provider.quoteTokenToUsd(token_, amountIn_);\n        require(_amountOut > 0 && !_priceIsStale(token_, _lastUpdatedAt), \"price-invalid\");\n    }\n\n    /// @inheritdoc IOracle\n    function quoteUsdToToken(address token_, uint256 amountIn_) public view virtual returns (uint256 _amountOut) {\n        uint256 _lastUpdatedAt;\n        (_amountOut, _lastUpdatedAt) = provider.quoteUsdToToken(token_, amountIn_);\n        require(_amountOut > 0 && !_priceIsStale(token_, _lastUpdatedAt), \"price-invalid\");\n    }\n}\n"
    },
    "contracts/periphery/PullOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IOracle} from \"../interfaces/periphery/IOracle.sol\";\nimport {IPriceProvider} from \"../interfaces/core/IPriceProvider.sol\";\n\n/**\n * @title Pull oracle\n * @dev This is the same as `MainOracle` but without stale period check because pull-oracle providers already do that\n */\ncontract PullOracle is IOracle {\n    IPriceProvider public immutable provider;\n\n    constructor(IPriceProvider provider_) {\n        provider = provider_;\n    }\n\n    /// @inheritdoc IOracle\n    function getPriceInUsd(address token_) public view virtual returns (uint256 _priceInUsd) {\n        (_priceInUsd, ) = provider.getPriceInUsd(token_);\n    }\n\n    /// @inheritdoc IOracle\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) public view virtual returns (uint256 _amountOut) {\n        (_amountOut, , ) = provider.quote(tokenIn_, tokenOut_, amountIn_);\n    }\n\n    /// @inheritdoc IOracle\n    function quoteTokenToUsd(address token_, uint256 amountIn_) public view virtual returns (uint256 _amountOut) {\n        (_amountOut, ) = provider.quoteTokenToUsd(token_, amountIn_);\n    }\n\n    /// @inheritdoc IOracle\n    function quoteUsdToToken(address token_, uint256 amountIn_) public view virtual returns (uint256 _amountOut) {\n        (_amountOut, ) = provider.quoteUsdToToken(token_, amountIn_);\n    }\n}\n"
    },
    "contracts/periphery/tokens/ChainlinkEthOnlyTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"../../interfaces/periphery/IOracle.sol\";\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\nimport \"../../features/UsingStalePeriod.sol\";\n\n/**\n * @title Chainlink Oracle for token with ETH-only price feed\n */\ncontract ChainlinkEthOnlyTokenOracle is ITokenOracle, UsingStalePeriod {\n    using SafeCast for int256;\n\n    address public immutable WETH;\n\n    mapping(address => AggregatorV3Interface) public ethFeedOf;\n\n    event EthFeedUpdated(address indexed token, AggregatorV3Interface ethFeed);\n\n    constructor(address weth_) UsingStalePeriod(24 hours) {\n        WETH = weth_;\n    }\n\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address token_) external view override returns (uint256 _priceInUsd) {\n        // TOKEN/ETH price from Chainlink\n        (, int256 _price, , uint256 _lastUpdatedAt, ) = ethFeedOf[token_].latestRoundData();\n        require(_price > 0 && !_priceIsStale(token_, _lastUpdatedAt), \"price-invalid\");\n        uint256 _priceInEth = _price.toUint256();\n\n        // ETH/USD price from Chainlink\n        uint256 _ethPriceInUsd = IOracle(msg.sender).getPriceInUsd(WETH);\n\n        // TOKEN/USD price\n        return (_priceInEth * _ethPriceInUsd) / (1e18);\n    }\n\n    /**\n     * @notice Update default stale period\n     */\n    function updateEthFeed(address token_, AggregatorV3Interface ethFeed_) external onlyGovernor {\n        emit EthFeedUpdated(token_, ethFeed_);\n        ethFeedOf[token_] = ethFeed_;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 5000
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}