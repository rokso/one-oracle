{
  "language": "Solidity",
  "sources": {
    "contracts/access/Governable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/core/IAddressProvider.sol\";\n\n/**\n * @notice Contract module which provides access control mechanism, where\n * the governor account is granted with exclusive access to specific functions.\n * @dev Uses the AddressProvider to get the governor\n */\nabstract contract Governable {\n    IAddressProvider public constant addressProvider = IAddressProvider(0xfbA0816A81bcAbBf3829bED28618177a2bf0e82A);\n\n    /// @dev Throws if called by any account other than the governor.\n    modifier onlyGovernor() {\n        require(msg.sender == addressProvider.governor(), \"not-governor\");\n        _;\n    }\n}\n"
    },
    "contracts/interfaces/core/IAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./IStableCoinProvider.sol\";\nimport \"./IPriceProvidersAggregator.sol\";\n\ninterface IAddressProvider {\n    function governor() external view returns (address);\n\n    function providersAggregator() external view returns (IPriceProvidersAggregator);\n\n    function stableCoinProvider() external view returns (IStableCoinProvider);\n\n    function updateProvidersAggregator(IPriceProvidersAggregator providersAggregator_) external;\n}\n"
    },
    "contracts/interfaces/core/IPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IPriceProvider {\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of asset\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(address token_) external view returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(address token_, uint256 amountIn_)\n        external\n        view\n        returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetOut\n     * @param amountIn_ Input amount in USD\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(address token_, uint256 amountIn_)\n        external\n        view\n        returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n}\n"
    },
    "contracts/interfaces/core/IPriceProvidersAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../libraries/DataTypes.sol\";\nimport \"./IPriceProvider.sol\";\n\n/**\n * @notice PriceProvidersAggregator interface\n * @dev Worth noting that the `_lastUpdatedAt` logic depends on the underlying price provider. In summary:\n * ChainLink: returns the last updated date from the aggregator\n * UniswapV2: returns the date of the latest pair oracle update\n * UniswapV3: assumes that the price is always updated (returns block.timestamp)\n * Flux: returns the last updated date from the aggregator\n * Umbrella (FCD): returns the last updated date returned from their oracle contract\n * Umbrella (Passport): returns the date of the latest pallet submission\n * Anytime that a quote performs more than one query, it uses the oldest date as the `_lastUpdatedAt`.\n * See more: https://github.com/bloqpriv/one-oracle/issues/64\n */\ninterface IPriceProvidersAggregator {\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param provider_ The price provider to get quote from\n     * @param token_ The address of asset\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(DataTypes.Provider provider_, address token_)\n        external\n        view\n        returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Provider Providers' mapping\n     */\n    function priceProviders(DataTypes.Provider provider_) external view returns (IPriceProvider _priceProvider);\n\n    /**\n     * @notice Get quote\n     * @param provider_ The price provider to get quote from\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        DataTypes.Provider provider_,\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote\n     * @dev If providers aren't the same, uses native token as \"bridge\"\n     * @param providerIn_ The price provider to get quote for the tokenIn\n     * @param tokenIn_ The address of assetIn\n     * @param providerOut_ The price provider to get quote for the tokenOut\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _nativeTokenLastUpdatedAt Last updated timestamp of native token (i.e. WETH) used when providers aren't the same\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        DataTypes.Provider providerIn_,\n        address tokenIn_,\n        DataTypes.Provider providerOut_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _nativeTokenLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param provider_ The price provider to get quote from\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(\n        DataTypes.Provider provider_,\n        address token_,\n        uint256 amountIn_\n    ) external view returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param provider_ The price provider to get quote from\n     * @param token_ The address of assetOut\n     * @param amountIn_ Input amount in USD\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(\n        DataTypes.Provider provider_,\n        address token_,\n        uint256 amountIn_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Set a price provider\n     * @dev Administrative function\n     * @param provider_ The provider (from enum)\n     * @param priceProvider_ The price provider contract\n     */\n    function setPriceProvider(DataTypes.Provider provider_, IPriceProvider priceProvider_) external;\n}\n"
    },
    "contracts/interfaces/core/IStableCoinProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IStableCoinProvider {\n    /**\n     * @notice Return the stable coin if pegged\n     * @dev Check price relation between both stable coins and revert if peg is too loose\n     * @return _stableCoin The primary stable coin if pass all checks\n     */\n    function getStableCoinIfPegged() external view returns (address _stableCoin);\n\n    /**\n     * @notice Convert given amount of stable coin to USD representation (18 decimals)\n     */\n    function toUsdRepresentation(uint256 stableCoinAmount_) external view returns (uint256 _usdAmount);\n}\n"
    },
    "contracts/interfaces/external/curve/ICurveAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ICurveAddressProvider {\n    function get_registry() external view returns (address);\n\n    function get_address(uint256 i) external view returns (address);\n}\n"
    },
    "contracts/interfaces/external/curve/ICurveFactoryRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ICurveFactoryRegistry {\n    function get_n_coins(address lp) external view returns (uint256);\n\n    function get_coins(address pool) external view returns (address[4] memory);\n\n    function get_meta_n_coins(address pool) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/interfaces/external/curve/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ICurvePool {\n    function get_virtual_price() external view returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 _dx,\n        uint256 _min_dy\n    ) external payable;\n}\n"
    },
    "contracts/interfaces/external/curve/ICurveRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ICurveRegistry {\n    function get_n_coins(address lp) external view returns (uint256);\n\n    function get_coins(address pool) external view returns (address[8] memory);\n\n    function get_underlying_coins(address pool) external view returns (address[8] memory);\n\n    function get_pool_from_lp_token(address lp) external view returns (address);\n\n    function is_meta(address pool) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/external/ellipsis/IEllipsisRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/* solhint-disable */\npragma solidity 0.8.9;\n\ninterface IEllipsisRegistry {\n    function get_n_coins(address pool) external view returns (uint256);\n\n    function get_pool_from_lp_token(address lp) external view returns (address);\n\n    function get_coins(address pool) external view returns (address[4] memory);\n}\n"
    },
    "contracts/interfaces/periphery/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IOracle {\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of asset\n     * @return _priceInUsd The USD price\n     */\n    function getPriceInUsd(address token_) external view returns (uint256 _priceInUsd);\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external view returns (uint256 _amountOut);\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     */\n    function quoteTokenToUsd(address token_, uint256 amountIn_) external view returns (uint256 amountOut_);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetOut\n     * @param amountIn_ Input amount in USD\n     * @return _amountOut Output amount of token\n     */\n    function quoteUsdToToken(address token_, uint256 amountIn_) external view returns (uint256 _amountOut);\n}\n"
    },
    "contracts/interfaces/periphery/ITokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ITokenOracle {\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of asset\n     * @return _priceInUsd The USD price\n     */\n    function getPriceInUsd(address token_) external view returns (uint256 _priceInUsd);\n}\n"
    },
    "contracts/libraries/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nlibrary DataTypes {\n    /**\n     * @notice Price providers enumeration\n     */\n    enum Provider {\n        NONE,\n        CHAINLINK,\n        UNISWAP_V3,\n        UNISWAP_V2,\n        SUSHISWAP,\n        TRADERJOE,\n        PANGOLIN,\n        QUICKSWAP,\n        UMBRELLA_FIRST_CLASS,\n        UMBRELLA_PASSPORT,\n        FLUX\n    }\n\n    enum ExchangeType {\n        UNISWAP_V2,\n        SUSHISWAP,\n        TRADERJOE,\n        PANGOLIN,\n        QUICKSWAP,\n        UNISWAP_V3,\n        PANCAKE_SWAP,\n        CURVE\n    }\n\n    enum SwapType {\n        EXACT_INPUT,\n        EXACT_OUTPUT\n    }\n}\n"
    },
    "contracts/periphery/tokens/CurveFactoryLpTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\nimport \"../../interfaces/external/curve/ICurveAddressProvider.sol\";\nimport \"../../interfaces/external/curve/ICurveFactoryRegistry.sol\";\nimport \"../../interfaces/external/curve/ICurvePool.sol\";\nimport \"../../interfaces/periphery/IOracle.sol\";\n\n/**\n * @title Oracle for Curve LP tokens (Factory Pools)\n */\ncontract CurveFactoryLpTokenOracle is ITokenOracle {\n    /// @dev Same address for all chains\n    ICurveAddressProvider public constant addressProvider =\n        ICurveAddressProvider(0x0000000022D53366457F9d5E68Ec105046FC4383);\n\n    /// @notice Factory Registry contract\n    ICurveFactoryRegistry public immutable registry;\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    address private immutable weth;\n\n    /// @notice LP token => coins mapping\n    mapping(address => address[]) public underlyingTokens;\n\n    /// @notice Emitted when a token is registered\n    event LpRegistered(address indexed lpToken);\n\n    constructor(address weth_) {\n        require(weth_ != address(0), \"null-weth\");\n        weth = weth_;\n        registry = ICurveFactoryRegistry(addressProvider.get_address(3));\n    }\n\n    /// @inheritdoc ITokenOracle\n    function getPriceInUsd(address lpToken_) public view override returns (uint256 _priceInUsd) {\n        address[] memory _tokens = underlyingTokens[lpToken_];\n        require(_tokens.length > 0, \"lp-is-not-registered\");\n        uint256 _min = type(uint256).max;\n        uint256 _n = _tokens.length;\n\n        for (uint256 i; i < _n; i++) {\n            uint256 _price = IOracle(msg.sender).getPriceInUsd(_tokens[i]);\n            if (_price < _min) _min = _price;\n        }\n\n        require(_min < type(uint256).max, \"no-min-underlying-price-found\");\n        require(_min > 0, \"invalid-min-price\");\n\n        return (_min * ICurvePool(lpToken_).get_virtual_price()) / 1e18;\n    }\n\n    /// @notice Check if a token is already registered\n    function isLpRegistered(address lpToken_) public view returns (bool) {\n        return underlyingTokens[lpToken_].length > 0;\n    }\n\n    /// @notice Register LP token data\n    /// @dev For factory pools, the LP and pool addresses are the same\n    function registerLp(address lpToken_) external {\n        require(!isLpRegistered(lpToken_), \"lp-already-registered\");\n\n        uint256 _n = registry.get_n_coins(lpToken_);\n        if (_n == 0) (_n, ) = registry.get_meta_n_coins(lpToken_);\n        require(_n > 0, \"invalid-factory-lp-token\");\n\n        address[4] memory _tokens = registry.get_coins(lpToken_);\n        for (uint256 i; i < _n; i++) {\n            if (_tokens[i] == ETH) {\n                underlyingTokens[lpToken_].push(weth);\n            } else {\n                underlyingTokens[lpToken_].push(_tokens[i]);\n            }\n        }\n\n        emit LpRegistered(lpToken_);\n    }\n}\n"
    },
    "contracts/periphery/tokens/CurveLpTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../interfaces/periphery/ITokenOracle.sol\";\nimport \"../../interfaces/external/curve/ICurveAddressProvider.sol\";\nimport \"../../interfaces/external/curve/ICurveRegistry.sol\";\nimport \"../../interfaces/external/curve/ICurvePool.sol\";\nimport \"../../interfaces/periphery/IOracle.sol\";\nimport \"../../access/Governable.sol\";\n\n/**\n * @title Oracle for Curve LP tokens\n */\ncontract CurveLpTokenOracle is ITokenOracle, Governable {\n    ICurveAddressProvider public immutable curveAddressProvider;\n\n    /// @notice Registry contract\n    address public immutable registry;\n\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    address internal immutable weth;\n\n    /// @notice LP token => coins mapping\n    mapping(address => address[]) public underlyingTokens;\n\n    /// @notice LP token => pool\n    mapping(address => address) public poolOf;\n\n    /// @notice Emitted when a token is registered\n    event LpRegistered(address indexed lpToken, bool isLending);\n\n    constructor(ICurveAddressProvider curveAddressProvider_, address weth_) {\n        require(address(curveAddressProvider_) != address(0), \"null-address-provider\");\n        require(weth_ != address(0), \"null-weth\");\n        curveAddressProvider = curveAddressProvider_;\n        registry = curveAddressProvider.get_registry();\n        weth = weth_;\n    }\n\n    /// @inheritdoc ITokenOracle\n    /// @dev This function is supposed to be called from `MasterOracle` only\n    function getPriceInUsd(address lpToken_) public view override returns (uint256 _priceInUsd) {\n        address _pool = poolOf[lpToken_];\n        require(_pool != address(0), \"lp-is-not-registered\");\n        address[] memory _tokens = underlyingTokens[lpToken_];\n        uint256 _min = type(uint256).max;\n        uint256 _n = _tokens.length;\n\n        for (uint256 i; i < _n; i++) {\n            // Note: `msg.sender` is the `MasterOracle` contract\n            uint256 _price = IOracle(msg.sender).getPriceInUsd(_tokens[i]);\n            if (_price < _min) _min = _price;\n        }\n\n        require(_min < type(uint256).max, \"no-min-underlying-price-found\");\n        require(_min > 0, \"invalid-min-price\");\n\n        return (_min * ICurvePool(_pool).get_virtual_price()) / 1e18;\n    }\n\n    /// @notice Register LP token data\n    function registerLp(address lpToken_) external onlyGovernor {\n        _registerLp(lpToken_, false);\n    }\n\n    /// @notice Register LP token data\n    function registerLendingLp(address lpToken_) external onlyGovernor {\n        _registerLp(lpToken_, true);\n    }\n\n    /// @notice Register LP token data\n    function _registerLp(address lpToken_, bool isLending_) internal virtual {\n        ICurveRegistry _registry = ICurveRegistry(registry);\n        address _pool = _registry.get_pool_from_lp_token(lpToken_);\n        require(_pool != address(0), \"invalid-non-factory-lp\");\n\n        address[8] memory _tokens;\n        if (isLending_) {\n            _tokens = _registry.get_underlying_coins(_pool);\n        } else {\n            _tokens = _registry.get_coins(_pool);\n        }\n\n        if (poolOf[lpToken_] != address(0)) {\n            // Clean current tokens if LP exists\n            delete underlyingTokens[lpToken_];\n        }\n\n        poolOf[lpToken_] = _pool;\n\n        uint256 _n = _registry.get_n_coins(_pool);\n        for (uint256 i; i < _n; i++) {\n            if (_tokens[i] == ETH) {\n                underlyingTokens[lpToken_].push(weth);\n            } else {\n                underlyingTokens[lpToken_].push(_tokens[i]);\n            }\n        }\n\n        emit LpRegistered(lpToken_, isLending_);\n    }\n}\n"
    },
    "contracts/periphery/tokens/EllipsisLpTokenOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../interfaces/external/ellipsis/IEllipsisRegistry.sol\";\nimport \"./CurveLpTokenOracle.sol\";\n\n/**\n * @title Oracle for Ellipsis LP tokens\n */\ncontract EllipsisLpTokenOracle is CurveLpTokenOracle {\n    constructor(ICurveAddressProvider addressProvider_, address weth_) CurveLpTokenOracle(addressProvider_, weth_) {}\n\n    /// @notice Register LP token data\n    function _registerLp(address lpToken_, bool isLending_) internal override {\n        IEllipsisRegistry _registry = IEllipsisRegistry(registry);\n        address _pool = _registry.get_pool_from_lp_token(lpToken_);\n        require(_pool != address(0), \"invalid-non-factory-lp\");\n\n        address[4] memory _tokens = _registry.get_coins(_pool);\n\n        if (poolOf[lpToken_] != address(0)) {\n            // Clean current tokens if LP exists\n            delete underlyingTokens[lpToken_];\n        }\n\n        poolOf[lpToken_] = _pool;\n\n        uint256 _n = _registry.get_n_coins(_pool);\n        for (uint256 i; i < _n; i++) {\n            if (_tokens[i] == ETH) {\n                underlyingTokens[lpToken_].push(weth);\n            } else {\n                underlyingTokens[lpToken_].push(_tokens[i]);\n            }\n        }\n\n        emit LpRegistered(lpToken_, isLending_);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 5000
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}